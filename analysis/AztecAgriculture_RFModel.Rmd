---
title: "Aztec Agricultural Productivity Model"
subtitle: "Part 3: Random Forest Model"
author: "Rudolf Cesaretti"
date: "Last run on `r Sys.Date()`"
output:
  html_document:
    toc: true
    df_print: paged
    number_sections: true
bibliography: References.bib
csl: apa.csl
link-citations: yes
---

```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 300px;
}
```



```{r, setup, include=FALSE,echo=FALSE, message=FALSE,warning=FALSE}
require(knitr)
# Set so that long lines in R will be wrapped:
opts_chunk$set(tidy.opts=list(width.cutoff=75),tidy=TRUE)
#
rm(list = ls())
```

I do four things in this R markdown document: 
Topographic/environmental metrics

  1. Calculate catchment area variables, including
      + Topographic/environmental metrics
      + 
  4. Reorganize the data and export for Script #6
  
  
# Setup 

All of the data and scripts are downloadable from the [new ASU SettlementPersist2022 github repository](https://https://github.com/rcesaret/ASUSettlementPersist2022), which can be downloaded locally as a .zip folder or cloned to your own account.

Either way, once you have done so, you will need to modify the working directory (setwd("C:/...)") path and "dir" variables in the code chunk below to match the repository location on your computer.

```{r, label='Set Local Directory Location', message=FALSE,warning=FALSE}

wd <- list()

#SET YOUR LOCAL DIRECTORY LOCATION HERE:
wd$dir <- "D:/Dropbox (ASU)/AztecAgricultureModel/AztecAgriculture/"
#wd$dir <- "C:/Users/TJ McMote/Dropbox (ASU)/AztecAgricultureModel/AztecAgriculture/"

wd$analysis <- paste0(wd$dir,"analysis/")
wd$data_r <- paste0(wd$dir,"data-raw/")
wd$data_p <- paste0(wd$dir,"data-processed/")
wd$data_f <- paste0(wd$dir,"data-final-outputs/")
wd$figs <- paste0(wd$dir,"figures/")
wd$funcs <- paste0(wd$dir,"functions/")

```



## Load R Packages and Custom Functions



```{r, label='Load Libraries', message=FALSE,warning=FALSE}
# Package names
packages <- c("tidyverse", "rgdal", "rgeos", "sp", "sf", "GISTools", "raster", 
              "Matrix", "terra","gdistance", "lwgeom", "tidyr", "stars", 
              "dismo", "purrr", "spatialEco", "whitebox", "classInt",
              "ggnewscale", "lbmech", "data.table", "tidyterra","gridExtra", 
              "cowplot", "scam", "rmarkdown", "spatialreg","spdep", "ggridges", 
              "ggnewscale", "scales", "ggstatsplot", "stringi", "fuzzyjoin", 
              "mgcv", "randomForest", "ranger", "exactextractr", "kableExtra",
              "goft", "MASS", "NSM3", "ggsn", "rlang", "FSA", "philentropy", 
              "sfdep","spdep", "Boruta", "mlbench", "caret", "DataExplorer", 
              "tableone", "mlr3", "mlr3verse", "mlr3learners", "mlr3measures", 
              "mlr3tuning", "mlr3mbo", "mlr3misc", "mlr3viz", "mlr3tuningspaces", 
              "mlr3pipelines", "mlr3hyperband", "mlr3fselect", "mlr3filters", 
              "mlr3cluster", "FSelectorRcpp", "mlr3extralearners", "mlr3spatial", 
              "mlr3spatiotempcv", "praznik", "care", "genalg")

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# load packages
invisible(lapply(packages, library, character.only = TRUE))

rm(packages,installed_packages)

#Read in custom R functions located in the wd$funcs directory folder
FUNCS <- list("RescaleSpatRast.R", "Terra_df.R", "RF_ImputeRast.R", "linear_rescale.R", "CMex_AG_Map.R")
invisible(lapply(FUNCS, function(x) source(paste0(wd$funcs,x))))
rm(FUNCS)

```

"Milpa Alta, Distrito Federal", "Tlahuac, Distrito Federal", "Xochimilco, Distrito Federal", "Axapusco, Mexico", "Ixtapaluca, Mexico", "Valle de Chalco Solidaridad, Mexico", "Chicoloapan, Mexico", "Chimalhuacan, Mexico", "Malinalco, Mexico"








# Modelling Aztec Maize Yields



Unfortunate

## Rescale Yields

10*Yield^0.65
```{r}

RescaleYields <- function(x, method, a, b){
  
  if (method == "power"){
    y <- a*x^b
  }
  
  if (method == "sigmoid"){
    y <- a/(1+exp(-x*b))-(a/2)
  }
  
  return(y)
}

METHOD = "power"
A_PAR = 10
B_PAR = 0.65


```

## BOM Chinampas
Some of the most important cases for our Aztec yield model are the chinampas of the southern Basin of Mexico. Unfortunately, these areas no longer cultivate 
write.csv(SIAP_2, paste0(wd$data_r,"SIAP_2_BOM_IrrigNoMaizeCases.csv"))
```{r}

# Read-in the SIAP 2003-2021 Yield Data
SIAP_2 <- read.csv(paste0(wd$data_p,"SIAP_2.csv"))

Chalco <- SIAP_2 %>% filter(EstadoMunicipio == "Chalco, Mexico" & AGType == "Riego" & Cultigen == "Maiz grano") %>% 
  mutate(Yield=Yield*1000, ZYield = (Yield - mean(Yield)) / sd(Yield))


MilpaAlta <- SIAP_2 %>% filter(EstadoMunicipio == "Milpa Alta, Distrito Federal" & AGType == "Riego" & Cycle == "Perennes") %>% mutate(Cultigen = "Maiz grano", AGType = "Riego", Price = NA, Value = NA, Yield_orig = NA, Yield_SIAP = NA, Planted = Planted +20, Harvested = Harvested + 20) 
MilpaAlta$Yield = (Chalco$ZYield + runif(1, min = -0.5, max = 0.5))*(400 +runif(1, min = -100, max = 200))+3800
MilpaAlta$Product = MilpaAlta$Yield*MilpaAlta$Harvested


Xochimilco <- SIAP_2 %>% filter(EstadoMunicipio == "Xochimilco, Distrito Federal" & AGType == "Riego" & Cultigen == "Lechuga") %>% mutate(Cultigen = "Maiz grano", AGType = "Riego", Price = NA, Value = NA, Yield_orig = NA, Yield_SIAP = NA, Planted = Planted +100, Harvested = Harvested + 100) 
Xochimilco$Yield = (Chalco$ZYield + runif(1, min = -0.5, max = 0.5))*(400 +runif(1, min = -100, max = 200))+4050
Xochimilco$Product = Xochimilco$Yield*Xochimilco$Harvested


Tlahuac <- SIAP_2 %>% filter(EstadoMunicipio == "Tlahuac, Distrito Federal" & AGType == "Riego" & Cultigen == "Brocoli" & Cycle == "Primavera-Verano") %>% mutate(Cultigen = "Maiz grano", AGType = "Riego", Price = NA, Value = NA, Yield_orig = NA, Yield_SIAP = NA) 
Tlahuac$Yield = (Chalco$ZYield + runif(1, min = -0.5, max = 0.5))*(400 +runif(1, min = -100, max = 200))+4000
Tlahuac$Product = Tlahuac$Yield*Tlahuac$Harvested


ValleChalco <- SIAP_2 %>% filter(EstadoMunicipio == "Valle de Chalco Solidaridad, Mexico" & AGType == "Riego" & Cycle == "Primavera-Verano" & Cultigen == "Lechuga") %>% mutate(Cultigen = "Maiz grano", AGType = "Riego", Price = NA, Value = NA, Yield_orig = NA, Yield_SIAP = NA) 
ValleChalco$Yield = (Chalco$ZYield[(length(Chalco$ZYield)-nrow(ValleChalco)):length(Chalco$ZYield)] + runif(1, min = -0.5, max = 0.5))*(400 +runif(1, min = -100, max = 200))+3900
ValleChalco$Product = ValleChalco$Yield*ValleChalco$Harvested
runif(1, min = 0.01, max = 0.5)

######################################################
########## NOT FINISHED

Ixtapaluca <- SIAP_2 %>% filter(EstadoMunicipio == "Ixtapaluca, Mexico" & AGType == "Riego" & Cycle == "Perennes") %>% mutate(Cultigen = "Maiz grano", AGType = "Riego", Price = NA, Value = NA, Yield_orig = NA, Yield_SIAP = NA, Planted = Planted +20, Harvested = Harvested + 20) 
Ixtapaluca$Yield = (Chalco$ZYield + runif(1, min = -0.5, max = 0.5))*(400 +runif(1, min = -100, max = 200))+3800
Ixtapaluca$Product = Ixtapaluca$Yield*Ixtapaluca$Harvested

Axapusco <- SIAP_2 %>% filter(EstadoMunicipio == "Axapusco, Mexico" & AGType == "Riego" & Cycle == "Perennes") %>% mutate(Cultigen = "Maiz grano", AGType = "Riego", Price = NA, Value = NA, Yield_orig = NA, Yield_SIAP = NA, Planted = Planted +20, Harvested = Harvested + 20) 
Axapusco$Yield = (Chalco$ZYield + runif(1, min = -0.5, max = 0.5))*(400 +runif(1, min = -100, max = 200))+3800
Axapusco$Product = Axapusco$Yield*Axapusco$Harvested

Nextlalpan <- SIAP_2 %>% filter(EstadoMunicipio == "Nextlalpan, Mexico" & AGType == "Riego" & Cycle == "Perennes") %>% mutate(Cultigen = "Maiz grano", AGType = "Riego", Price = NA, Value = NA, Yield_orig = NA, Yield_SIAP = NA, Planted = Planted +20, Harvested = Harvested + 20) 
Nextlalpan$Yield = (Chalco$ZYield + runif(1, min = -0.5, max = 0.5))*(400 +runif(1, min = -100, max = 200))+3800
Nextlalpan$Product = Nextlalpan$Yield*Nextlalpan$Harvested

## Other two Xaltocan area chinampas????

ADDEDCASES <- rbind(MilpaAlta, Xochimilco, Tlahuac, ValleChalco, Ixtapaluca, Axapusco, Nextlalpan)

rm(Chalco, MilpaAlta, Xochimilco, Tlahuac, ValleChalco, Ixtapaluca, Axapusco, Nextlalpan, Otumba, , , , )

##############################################################

##### This goes down below to delete the modified rows

filter(!(EstadoMunicipio == "Milpa Alta, Distrito Federal" & AGType == "Riego" & Cycle == "Perrenes")) %>%
  filter(!(EstadoMunicipio == "Xochimilco, Distrito Federal" & AGType == "Riego" & Cultigen == "Lechuga")) %>%
  filter(!(EstadoMunicipio == "Tlahuac, Distrito Federal" & AGType == "Riego" & Cultigen == "Brocoli" & Cycle == "Primavera-Verano")) %>%
  filter(!(EstadoMunicipio == "Valle de Chalco Solidaridad, Mexico" & AGType == "Riego" & Cycle == "Primavera-Verano" & Cultigen == "Lechuga")) %>%
  
```

"Valle de Chalco Solidaridad, Mexico", ", Distrito Federal", "Tlahuac, Distrito Federal", "Xochimilco, Distrito Federal",
```{r}

#Pred_Poly_ModLU <- Data2000s_poly_rs %>%  mutate(
   # AvgPctArea_ofTotal = case_when(
      EstadoMunicipio == "Ixtapaluca, Mexico" & AGType == "Riego" ~ 0.012594759,
     # EstadoMunicipio == "Valle de Chalco Solidaridad, Mexico" & AGType == "Riego" ~ 0.012594759,
     # EstadoMunicipio == "Milpa Alta, Distrito Federal" & AGType == "Riego" ~ 0.012594759,
     # EstadoMunicipio == "Tlahuac, Distrito Federal" & AGType == "Riego" ~ 0.012594759,
     # EstadoMunicipio == "Xochimilco, Distrito Federal" & AGType == "Riego" ~ 0.012594759,
      EstadoMunicipio == "Axapusco, Mexico" & AGType == "Riego" ~ 0.006730203,
	#  .default = AvgPctArea_ofTotal),
  #  cvYield = case_when(
   #   EstadoMunicipio == "Valle de Chalco Solidaridad, Mexico" & AGType == "Riego" ~ 5,
   #   EstadoMunicipio == "Milpa Alta, Distrito Federal" & AGType == "Riego" ~ 5,
   #   EstadoMunicipio == "Tlahuac, Distrito Federal" & AGType == "Riego" ~ 5,
   #   EstadoMunicipio == "Xochimilco, Distrito Federal" & AGType == "Riego" ~ 5,
	#  .default = cvYield),
  #  AvgYield = case_when(
    #  EstadoMunicipio == "Valle de Chalco Solidaridad, Mexico" & AGType == "Riego" ~ 4000,
    #  EstadoMunicipio == "Milpa Alta, Distrito Federal" & AGType == "Riego" ~ 4000,
    #  EstadoMunicipio == "Tlahuac, Distrito Federal" & AGType == "Riego" ~ 4000,
     # EstadoMunicipio == "Xochimilco, Distrito Federal" & AGType == "Riego" ~ 4000,
      EstadoMunicipio == "Nextlalpan, Mexico" & AGType == "Riego" ~ 3500,
	#  .default = AvgYield),
  #  AvgPctArea_ofArable = case_when(
    #  EstadoMunicipio == "Valle de Chalco Solidaridad, Mexico" & AGType == "Riego" ~ 0.2847692,
    #  EstadoMunicipio == "Milpa Alta, Distrito Federal" & AGType == "Riego" ~ 0.2847692,
   #   EstadoMunicipio == "Tlahuac, Distrito Federal" & AGType == "Riego" ~ 0.2847692,
   #   EstadoMunicipio == "Xochimilco, Distrito Federal" & AGType == "Riego" ~ 0.2847692,
	#  .default = AvgYield))

```



```{r}


# Read-in the SIAP 2003-2021 Yield Data
SIAP_2 <- read.csv(paste0(wd$data_p,"SIAP_2.csv"))



SIAP_2b = SIAP_2 %>% mutate(
    # convert units -- tons to kg -- for yield, yield loss and product
    Yield = Yield * 1000, Product = Product * 1000,
    # reported yield in the data == Product (tons) / hectares harvested
    Yield_orig = Yield,
    # we want to change the reported yield to == Product (tons) / hectares planted
    # to account for yield loss over the course of the growing season
    Yield = Product / Planted, 
    Yield_SIAP = Yield,
    Yield = RescaleYields(Yield, method = METHOD, a = A_PAR, b = B_PAR))

SIAP_2b = SIAP_2b %>% 
  filter(!(EstadoMunicipio == "Milpa Alta, Distrito Federal" & AGType == "Riego" & Cycle == "Perrenes")) %>%
  #filter(!(EstadoMunicipio == "Milpa Alta, Distrito Federal" & AGType == "Riego" & Cycle == "Perrenes")) %>%
  #filter(!(EstadoMunicipio == "Milpa Alta, Distrito Federal" & AGType == "Riego" & Cycle == "Perrenes")) %>%
  #filter(!(EstadoMunicipio == "Milpa Alta, Distrito Federal" & AGType == "Riego" & Cycle == "Perrenes")) %>%

SIAP_2b = cbind(SIAP_2b, ADDEDCASES) 

SIAP_2b = SIAP_2b %>% 
    # only consider Spring-Summer crop cycle yields (exclude Autumn-Winter yields)
  filter(Cycle %in% c("Primavera-Verano", "Perennes")) %>%
  mutate(CultigenGroup = case_when(
    Cultigen == "Maiz grano" ~ "Maize",
    Cultigen == "Avena forrajera seca" ~ "Fodder",
    Cultigen == "Pastos y praderas seco" ~ "Fodder",
    Cultigen == "Alfalfa verde" ~ "Fodder",
    Cultigen == "Pastos y praderas" ~ "Fodder",
    Cultigen == "Cebada forrajera en verde" ~ "Fodder",
    Cultigen == "Pastos y praderas achicalado" ~ "Fodder",
    .default = "OtherCrops")) %>%
  group_by(EstadoMunicipio, Year, AGType) %>%
    mutate(Area_AGType = sum(Planted, na.rm=T),
           Area_AGType_Maize = sum(Planted[CultigenGroup == "Maize"], na.rm=T),
           Area_AGType_Maize = ifelse(is.na(Area_AGType_Maize), 0, Area_AGType_Maize),
           Area_AGType_Fodder = sum(Planted[CultigenGroup == "Fodder"], na.rm=T),
           Area_AGType_Fodder = ifelse(is.na(Area_AGType_Fodder), 0, Area_AGType_Fodder),
           Area_AGType_OtherCrops = sum(Planted[CultigenGroup == "OtherCrops"], na.rm=T),
           Area_AGType_OtherCrops = ifelse(is.na(Area_AGType_OtherCrops), 0, Area_AGType_OtherCrops)) %>% ungroup() %>%
  group_by(EstadoMunicipio, Year) %>%
  mutate(Area_Total = sum(Planted, na.rm=T) + runif(1, min = 0.0000001, max = 0.0001),
           Area_Total_Maize = sum(Planted[CultigenGroup == "Maize"], na.rm=T) + runif(1, min = 0.0000001, max = 0.0001),
           Area_Total_Maize = ifelse(is.na(Area_Total_Maize) | Area_Total_Maize <=  0.0001, 0, Area_Total_Maize),
           Area_Total_Fodder = sum(Planted[CultigenGroup == "Fodder"], na.rm=T) + runif(1, min = 0.0000001, max = 0.0001),
           Area_Total_Fodder = ifelse(is.na(Area_Total_Fodder) | Area_Total_Fodder <=  0.0001, 0, Area_Total_Fodder),
           Area_Total_OtherCrops = sum(Planted[CultigenGroup == "OtherCrops"], na.rm=T) + runif(1, min = 0.0000001, max = 0.0001),
           Area_Total_OtherCrops = ifelse(is.na(Area_Total_OtherCrops) | Area_Total_OtherCrops <=  0.0001, 0, Area_Total_OtherCrops)) %>% ungroup() %>%
    mutate(PctArea_Maize_Crops_AGType = Area_AGType_Maize / (Area_AGType_Maize + Area_AGType_OtherCrops),
           PctArea_Maize_AGType = Area_AGType_Maize / (Area_AGType_Maize + Area_AGType_OtherCrops + Area_AGType_Fodder),
           PctArea_Maize_Crops_Total = Area_Total_Maize / (Area_Total_Maize + Area_Total_OtherCrops),
           PctArea_Maize_Total = Area_Total_Maize / (Area_Total_Maize + Area_Total_OtherCrops + Area_Total_Fodder)) %>%
    # filter the data to only include Maize from the spring-summer cycle
    filter(Cultigen == "Maiz grano", Cycle == "Primavera-Verano") %>%
    
    group_by(EstadoMunicipio, Year)

SIAP_3_rs <- SIAP_2b %>% mutate(
  Product = Yield * Planted,
  Yield_orig = Product / Harvested,
  YieldLoss = (Product / Harvested) - Yield,
  PctYieldLoss = (1 - (Yield / (Product / Harvested)))*100) %>% rowwise() %>% 
  mutate(YieldLoss = ifelse(YieldLoss < 0, 0, YieldLoss),
      PctYieldLoss = ifelse(PctYieldLoss < 0, 0, PctYieldLoss)) %>% ungroup() %>% 
  group_by(EstadoMunicipio, Year) %>%
    mutate(TotYield = (sum(Product, na.rm=T) / sum(Planted, na.rm=T)) + runif(1, min = 0.0001, max = 0.01),
           TotYield_orig = sum(Product, na.rm=T) / sum(Harvested, na.rm=T),
           TotYieldLoss = TotYield_orig - TotYield,
           TotPctYieldLoss = (1-(TotYield/TotYield_orig))*100) %>% ungroup()

rm(SIAP_2)

SIAP_4_rs = SIAP_3_rs %>% 
  # group the data by state-municipality and agriculture type
  group_by(EstadoMunicipio, AGType) %>% 
  # calculate variables for the maize yield (and yield loss) time-series: mean, standard deviation 
  # and coefficient of variation by state-municipality and agriculture type
  mutate(AvgYield = mean(Yield, na.rm=T), 
         sdYield = sd(Yield, na.rm=T), 
         cvYield = sdYield/AvgYield*100,
         AvgYieldLoss = mean(YieldLoss, na.rm=T), 
         sdYieldLoss = sd(YieldLoss, na.rm=T), 
         cvYieldLoss = sdYieldLoss/AvgYieldLoss*100,
         AvgPctYieldLoss = mean(PctYieldLoss, na.rm=T), 
         sdPctYieldLoss = sd(PctYieldLoss, na.rm=T), 
         cvPctYieldLoss = sdPctYieldLoss/AvgPctYieldLoss*100) %>% 
  # calculate variable for the number of time series cases by state-municipality and agriculture type
  add_tally() %>% 
  # ungroup the data
  ungroup() %>% 
  # calculate the maize yield Z-score by state-municipality and agriculture type
  # using the state-municipality / agriculture type mean and st.dev
  mutate(zYield = (Yield - AvgYield)/sdYield) %>% 
  # group by state-municipality
  group_by(EstadoMunicipio) %>% 
  # calculate variables for the Yield and Yield Loss  mean, standard deviation and 
  # coefficient of variation for each agriculture type by state-municipality
  mutate(AvgYield_Total = mean(unique(TotYield), na.rm=T), #sum(Product, na.rm=T) / sum(Planted, na.rm=T)
         sdYield_Total = sd(unique(TotYield), na.rm=T), 
         cvYield_Total = sdYield_Total/AvgYield_Total*100,
         AvgYield_Irrig = mean(Yield[AGType == "Riego"] , na.rm=T),
         sdYield_Irrig = sd(Yield[AGType == "Riego"] , na.rm=T),
         cvYield_Irrig = sdYield_Irrig/AvgYield_Irrig*100,
         AvgYield_Temp = mean(Yield[AGType == "Temporal"], na.rm=T),
         sdYield_Temp = sd(Yield[AGType == "Temporal"], na.rm=T),
         cvYield_Temp = sdYield_Temp/AvgYield_Temp*100,
         AvgYieldLoss_Total = mean(unique(TotYieldLoss), na.rm=T), 
         sdYieldLoss_Total = sd(unique(TotYieldLoss), na.rm=T), 
         cvYieldLoss_Total = sdYieldLoss_Total/AvgYieldLoss_Total*100,
         AvgYieldLoss_Irrig = mean(YieldLoss[AGType == "Riego"] , na.rm=T),
         sdYieldLoss_Irrig = sd(YieldLoss[AGType == "Riego"] , na.rm=T),
         cvYieldLoss_Irrig = sdYieldLoss_Irrig/AvgYieldLoss_Irrig*100,
         AvgYieldLoss_Temp = mean(YieldLoss[AGType == "Temporal"], na.rm=T),
         sdYieldLoss_Temp = sd(YieldLoss[AGType == "Temporal"], na.rm=T),
         cvYieldLoss_Temp = sdYieldLoss_Temp/AvgYieldLoss_Temp*100,
         AvgPctYieldLoss_Total = mean(unique(TotPctYieldLoss), na.rm=T), 
         sdPctYieldLoss_Total = sd(unique(TotPctYieldLoss), na.rm=T), 
         cvPctYieldLoss_Total = sdPctYieldLoss_Total/AvgPctYieldLoss_Total*100,
         AvgPctYieldLoss_Irrig = mean(PctYieldLoss[AGType == "Riego"] , na.rm=T),
         sdPctYieldLoss_Irrig = sd(PctYieldLoss[AGType == "Riego"] , na.rm=T),
         cvPctYieldLoss_Irrig = sdPctYieldLoss_Irrig/AvgPctYieldLoss_Irrig*100,
         AvgPctYieldLoss_Temp = mean(PctYieldLoss[AGType == "Temporal"], na.rm=T),
         sdPctYieldLoss_Temp = sd(PctYieldLoss[AGType == "Temporal"], na.rm=T),
         cvPctYieldLoss_Temp = sdPctYieldLoss_Temp/AvgPctYieldLoss_Temp*100) %>% 
  # calculate variable for the overall number of time series cases by state-municipality
  add_tally(name = "n_Total") %>% ungroup() %>% 
  group_by(EstadoMunicipio, AGType) %>% 
  mutate(AvgArea = mean(Area_AGType, na.rm=T),
         sdArea = sd(Area_AGType, na.rm=T),
         cvArea = sdArea/AvgArea*100,
         AvgArea_Maize = mean(Area_AGType_Maize, na.rm=T),
         sdArea_Maize = sd(Area_AGType_Maize, na.rm=T),
         cvArea_Maize = sdArea_Maize/AvgArea_Maize*100,
         AvgArea_Fodder = mean(Area_AGType_Fodder, na.rm=T),
         AvgArea_OtherCrops = mean(Area_AGType_OtherCrops, na.rm=T),
         AvgPctArea_Maize_Crops = mean(PctArea_Maize_Crops_AGType, na.rm=T),
         sdPctArea_Maize_Crops = sd(PctArea_Maize_Crops_AGType, na.rm=T),
         cvPctArea_Maize_Crops = sdPctArea_Maize_Crops/AvgPctArea_Maize_Crops*100,
         AvgPctArea_Maize = mean(PctArea_Maize_AGType, na.rm=T),
         sdPctArea_Maize = sd(PctArea_Maize_AGType, na.rm=T),
         cvPctArea_Maize = sdPctArea_Maize/AvgPctArea_Maize*100) %>%
  ungroup() %>% group_by(EstadoMunicipio) %>% 
  mutate(AvgArea_Irrig = mean(Area_AGType[AGType == "Riego"], na.rm=T),
         AvgArea_Irrig_Maize = mean(Area_AGType_Maize[AGType == "Riego"], na.rm=T),
         AvgArea_Irrig_Fodder = mean(Area_AGType_Fodder[AGType == "Riego"], na.rm=T),
         AvgArea_Irrig_OtherCrops = mean(Area_AGType_OtherCrops[AGType == "Riego"], na.rm=T),
         AvgPctArea_Maize_Crops_Irrig = mean(PctArea_Maize_Crops_AGType[AGType == "Riego"], na.rm=T),
         AvgPctArea_Maize_Irrig = mean(PctArea_Maize_AGType[AGType == "Riego"], na.rm=T),
         AvgArea_Temp = mean(Area_AGType[AGType == "Temporal"], na.rm=T),
         AvgArea_Temp_Maize = mean(Area_AGType_Maize[AGType == "Temporal"], na.rm=T),
         AvgArea_Temp_Fodder = mean(Area_AGType_Fodder[AGType == "Temporal"], na.rm=T),
         AvgArea_Temp_OtherCrops = mean(Area_AGType_OtherCrops[AGType == "Temporal"], na.rm=T),
         AvgPctArea_Maize_Crops_Temp = mean(PctArea_Maize_Crops_AGType[AGType == "Temporal"], na.rm=T),
         AvgPctArea_Maize_Temp = mean(PctArea_Maize_AGType[AGType == "Temporal"], na.rm=T),
         
         AvgArea_Total = mean(unique(Area_Total), na.rm=T), 
         sdArea_Total = sd(unique(Area_Total), na.rm=T), 
         cvArea_Total = sdArea_Total/AvgArea_Total*100,
         AvgArea_Total_Maize = mean(unique(Area_Total_Maize), na.rm=T),
         sdArea_Total_Maize = sd(unique(Area_Total_Maize), na.rm=T),
         cvArea_Total_Maize = sdArea_Total_Maize/AvgArea_Total_Maize*100,
         AvgArea_Total_Fodder = mean(unique(Area_Total_Fodder), na.rm=T),
         AvgArea_Total_OtherCrops = mean(unique(Area_Total_OtherCrops), na.rm=T),
         AvgPctArea_Maize_Crops_Total = mean(unique(PctArea_Maize_Crops_Total), na.rm=T),
         sdPctArea_Maize_Crops_Total = sd(unique(PctArea_Maize_Crops_Total), na.rm=T),
         cvPctArea_Maize_Crops_Total = sdPctArea_Maize_Crops_Total/AvgPctArea_Maize_Crops_Total*100,
         AvgPctArea_Maize_Total = mean(unique(PctArea_Maize_Total), na.rm=T),
         sdPctArea_Maize_Total = sd(unique(PctArea_Maize_Total), na.rm=T),
         cvPctArea_Maize_Total = sdPctArea_Maize_Total/AvgPctArea_Maize_Total*100) %>%
  # ungroup the data
  ungroup() %>% 
  # calculate additional variables of interest
  mutate(
    # irrigated maize % of total maize cultivation
    AvgPctMaizeArea_Irrig = AvgArea_Irrig_Maize / AvgArea_Total_Maize,
    AvgPctMaizeArea_Irrig = ifelse(is.nan(AvgPctMaizeArea_Irrig), 0, AvgPctMaizeArea_Irrig),
    # temporal maize % of total maize cultivation 
    AvgPctMaizeArea_Temp = AvgArea_Temp_Maize / AvgArea_Total_Maize,
    AvgPctMaizeArea_Temp = ifelse(is.nan(AvgPctMaizeArea_Temp), 0, AvgPctMaizeArea_Temp),
    # irrigated % of total cultivation 
    AvgPctArea_Irrig = AvgArea_Irrig / AvgArea_Total,#BY MUNICIPIO (both AGTypes have same value!)
    AvgPctArea_Irrig = ifelse(is.nan(AvgPctArea_Irrig), 0, AvgPctArea_Irrig),
    # temporal % of total cultivation 
    AvgPctArea_Temp = AvgArea_Temp / AvgArea_Total,
    AvgPctArea_Temp = ifelse(is.nan(AvgPctArea_Temp), 0, AvgPctArea_Temp),
    # calculate the maize yield and yield loss Z-score by state-municipality for all agriculture types
    zYield_Total = (Yield - AvgYield_Total)/sdYield_Total,
    zYieldLoss_Total = (YieldLoss - AvgYieldLoss_Total)/sdYieldLoss_Total,
    # TTr = "Temporal-to-Total Ratio" == the ratio of avg temporal variable values to the avg total value
    # ITr = "Irrigation-to-Total Ratio" == the ratio of avg irrigation variable values to the avg total value
    ITr_AvgYield = AvgYield_Irrig/AvgYield_Total,
    ITr_AvgYieldLoss = AvgYieldLoss_Irrig/AvgYieldLoss_Total,
    TTr_AvgYield = AvgYield_Temp/AvgYield_Total,
    TTr_AvgYieldLoss = AvgYieldLoss_Irrig/AvgYieldLoss_Total,
    ITr_cvYield = cvYield_Irrig/cvYield_Total,
    ITr_cvYieldLoss = cvYieldLoss_Irrig/cvYieldLoss_Total,
    TTr_cvYield = cvYield_Irrig/cvYield_Total,
    TTr_cvYieldLoss = cvYieldLoss_Irrig/cvYieldLoss_Total)

SIAP_5_rs = SIAP_4_rs %>% 
  # group by all of the ID variables (effectively at the resolution of each agriculture type and state-municipality)
  group_by(Estado_ID, Estado, ddr_ID, ddr, Cader_ID, Cader, Municipio_ID, Municipio, EstadoMunicipio, AGType) %>%
  # summarize the dataset by state-municipality and agriculture type
  summarize(AvgYield = mean(Yield, na.rm=T), # mean/average maize yield
            sdYield = sd(Yield, na.rm=T), # standard deviation of maize yield
            minYield = min(Yield, na.rm=T), # minimum maize yield
            maxYield = max(Yield, na.rm=T), # maximum maize yield
            medYield = median(Yield, na.rm=T), # median maize yield
            cvYield = sd(Yield, na.rm=T)/mean(Yield, na.rm=T)*100, # coefficient of variation of maize yield
            
            AvgYieldLoss = mean(YieldLoss, na.rm=T), # mean/average maize Yield Loss
            sdYieldLoss = sd(YieldLoss, na.rm=T), # standard deviation of maize Yield Loss
            minYieldLoss = min(YieldLoss, na.rm=T), # minimum maize Yield Loss
            maxYieldLoss = max(YieldLoss, na.rm=T), # maximum maize Yield Loss
            medYieldLoss = median(YieldLoss, na.rm=T), # median maize Yield Loss
            cvYieldLoss = sd(YieldLoss, na.rm=T)/mean(YieldLoss, na.rm=T)*100,# coefficient of variation of maize Yield Loss
            
            AvgPctYieldLoss = mean(PctYieldLoss, na.rm=T), # mean/average maize % Yield Loss
            sdPctYieldLoss = sd(PctYieldLoss, na.rm=T), # standard deviation of maize % Yield Loss
            minPctYieldLoss = min(PctYieldLoss, na.rm=T), # minimum maize % Yield Loss
            maxPctYieldLoss = max(PctYieldLoss, na.rm=T), # maximum maize % Yield Loss
            medPctYieldLoss = median(PctYieldLoss, na.rm=T), # median maize % Yield Loss
            cvPctYieldLoss = sd(PctYieldLoss, na.rm=T)/mean(PctYieldLoss, na.rm=T)*100,# coefficient of variation of maize % Yield Loss
            
            AvgPlanted = mean(Planted, na.rm=T), # average hectares planted in maize
            AvgHarvested = mean(Harvested, na.rm=T), # average hectares harvested in maize
            sdHarvested = sd(Harvested, na.rm=T), # standard deviation of hectares planted in maize
            cvHarvested = sdHarvested/AvgHarvested*100, # coefficient of variation of hectares planted in maize
            AvgLost = mean(Lost, na.rm=T), # average number of hectares of maize lost (i.e. planted but not harvested)
            sdLost = sd(Lost, na.rm=T), # standard deviation of hectares of maize lost (i.e. planted but not harvested)
            cvLost = sdLost/AvgLost*100, # coefficient of variation of hectares of maize lost (i.e. planted but not harvested)
            AvgProduct = mean(Product, na.rm=T), # average total kg of maize produced
            AvgValue = mean(Value, na.rm=T), # average total value in $MX of maize produced
            AvgPrice = mean(Price, na.rm=T), # average price per kg in $MX for maize
            n = mean(n, na.rm=T), # number of time series cases by state-municipality and agriculture type
            n_Total = mean(n_Total, na.rm=T), # overall number of time series cases by state-municipality
            
            AvgYield_Total = mean(AvgYield_Total, na.rm=T), # mean maize yield for all agriculture types
            sdYield_Total = mean(sdYield_Total, na.rm=T), # standard deviation of maize yield for all agriculture types
            cvYield_Total = mean(cvYield_Total, na.rm=T), # coefficient of variation of maize yield for all agriculture types
            AvgYield_Irrig = mean(AvgYield_Irrig, na.rm=T), # mean maize yield for irrigated agriculture
            sdYield_Irrig = mean(sdYield_Irrig, na.rm=T), # standard deviation of maize yield for irrigated agriculture
            cvYield_Irrig = mean(cvYield_Irrig, na.rm=T), # coefficient of variation of maize yield for irrigated agriculture
            AvgYield_Temp = mean(AvgYield_Temp, na.rm=T), # mean maize yield for temporal agriculture
            sdYield_Temp = mean(sdYield_Temp, na.rm=T), # standard deviation of maize yield for temporal agriculture
            cvYield_Temp = mean(cvYield_Temp, na.rm=T), # coefficient of variation of maize yield for temporal agriculture
            ITr_AvgYield = mean(ITr_AvgYield, na.rm=T), # irrigation-to-total ratio for mean maize yields
            ITr_cvYield = mean(ITr_cvYield, na.rm=T), # irrigation-to-total ratio for coefficient of variation of maize yields
            TTr_AvgYield = mean(TTr_AvgYield, na.rm=T), # temporal-to-total ratio for mean maize yields
            TTr_cvYield = mean(TTr_cvYield, na.rm=T), # temporal-to-total ratio for coefficient of variation of maize yields
            
            AvgYieldLoss_Total = mean(AvgYieldLoss_Total, na.rm=T), # mean maize yield loss for all agriculture types
            sdYieldLoss_Total = mean(sdYieldLoss_Total, na.rm=T), # standard deviation of maize yield loss for all agriculture types
            cvYieldLoss_Total = mean(cvYieldLoss_Total, na.rm=T), # coefficient of variation of maize yield loss for all agriculture types
            AvgYieldLoss_Irrig = mean(AvgYieldLoss_Irrig, na.rm=T), # mean maize yield loss for irrigated agriculture
            sdYieldLoss_Irrig = mean(sdYieldLoss_Irrig, na.rm=T), # standard deviation of maize yield loss for irrigated agriculture
            cvYieldLoss_Irrig = mean(cvYieldLoss_Irrig, na.rm=T), # coefficient of variation of maize yield loss for irrigated agriculture
            AvgYieldLoss_Temp = mean(AvgYieldLoss_Temp, na.rm=T), # mean maize yield loss for temporal agriculture
            sdYieldLoss_Temp = mean(sdYieldLoss_Temp, na.rm=T), # standard deviation of maize yield loss for temporal agriculture
            cvYieldLoss_Temp = mean(cvYieldLoss_Temp, na.rm=T), # coefficient of variation of maize yield loss for temporal agriculture
            AvgPctYieldLoss_Total = mean(AvgPctYieldLoss_Total, na.rm=T), # mean % maize yield loss for all agriculture types
            sdPctYieldLoss_Total = mean(sdPctYieldLoss_Total, na.rm=T), # standard deviation of % maize yield loss for all agriculture types
            cvPctYieldLoss_Total = mean(cvPctYieldLoss_Total, na.rm=T), # coefficient of variation of % maize yield loss for all agriculture types
            AvgPctYieldLoss_Irrig = mean(AvgPctYieldLoss_Irrig, na.rm=T), # mean % maize yield loss for irrigated agriculture
            sdPctYieldLoss_Irrig = mean(sdPctYieldLoss_Irrig, na.rm=T), # standard deviation of % maize yield loss for irrigated agriculture
            cvPctYieldLoss_Irrig = mean(cvPctYieldLoss_Irrig, na.rm=T), # coefficient of variation of % maize yield loss for irrigated agriculture
            AvgPctYieldLoss_Temp = mean(AvgPctYieldLoss_Temp, na.rm=T), # mean % maize yield loss for temporal agriculture
            sdPctYieldLoss_Temp = mean(sdPctYieldLoss_Temp, na.rm=T), # standard deviation of % maize yield loss for temporal agriculture
            cvPctYieldLoss_Temp = mean(cvPctYieldLoss_Temp, na.rm=T), # coefficient of variation of % maize yield loss for temporal agriculture
            ITr_AvgYieldLoss = mean(ITr_AvgYieldLoss, na.rm=T), # irrigation-to-total ratio for mean maize yield loss
            ITr_cvYieldLoss = mean(ITr_cvYieldLoss, na.rm=T),# irrigation-to-total ratio for coefficient of variation of maize yield loss
            TTr_AvgYieldLoss = mean(TTr_AvgYieldLoss, na.rm=T), # temporal-to-total ratio for mean maize yield loss
            TTr_cvYieldLoss = mean(TTr_cvYieldLoss, na.rm=T),# temporal-to-total ratio for coefficient of variation of maize yield loss
            
         AvgArea = mean(Area_AGType, na.rm=T),
         sdArea = sd(Area_AGType, na.rm=T),
         cvArea = sdArea/AvgArea*100,
         AvgArea_Maize = mean(Area_AGType_Maize, na.rm=T),
         sdArea_Maize = sd(Area_AGType_Maize, na.rm=T),
         cvArea_Maize = sdArea_Maize/AvgArea_Maize*100,
         AvgArea_Fodder = mean(Area_AGType_Fodder, na.rm=T),
         AvgArea_OtherCrops = mean(Area_AGType_OtherCrops, na.rm=T),
         AvgPctArea_Maize_Crops = mean(PctArea_Maize_Crops_AGType, na.rm=T),
         sdPctArea_Maize_Crops = sd(PctArea_Maize_Crops_AGType, na.rm=T),
         cvPctArea_Maize_Crops = sdPctArea_Maize_Crops/AvgPctArea_Maize_Crops*100,
         AvgPctArea_Maize = mean(PctArea_Maize_AGType, na.rm=T),
         sdPctArea_Maize = sd(PctArea_Maize_AGType, na.rm=T),
         cvPctArea_Maize = sdPctArea_Maize/AvgPctArea_Maize*100,
         
         AvgArea_Irrig = ifelse(is.na(mean(AvgArea_Irrig, na.rm=T)), 0, mean(AvgArea_Irrig, na.rm=T)),
         AvgArea_Irrig_Maize = ifelse(is.na(mean(AvgArea_Irrig_Maize, na.rm=T)), 0, mean(AvgArea_Irrig_Maize, na.rm=T)),
         AvgArea_Irrig_Fodder = ifelse(is.na(mean(AvgArea_Irrig_Fodder, na.rm=T)), 0, mean(AvgArea_Irrig_Fodder, na.rm=T)),
         AvgArea_Irrig_OtherCrops = ifelse(is.na(mean(AvgArea_Irrig_OtherCrops, na.rm=T)), 0, mean(AvgArea_Irrig_OtherCrops, na.rm=T)),
         AvgPctArea_Maize_Crops_Irrig = ifelse(is.na(mean(AvgPctArea_Maize_Crops_Irrig, na.rm=T)), 0, mean(AvgPctArea_Maize_Crops_Irrig, na.rm=T)),
         AvgPctArea_Maize_Irrig = ifelse(is.na(mean(AvgPctArea_Maize_Irrig, na.rm=T)), 0, mean(AvgPctArea_Maize_Irrig, na.rm=T)),
         AvgArea_Temp = ifelse(is.na(mean(AvgArea_Temp, na.rm=T)), 0, mean(AvgArea_Temp, na.rm=T)),
         AvgArea_Temp_Maize = ifelse(is.na(mean(AvgArea_Temp_Maize, na.rm=T)), 0, mean(AvgArea_Temp_Maize, na.rm=T)),
         AvgArea_Temp_Fodder = ifelse(is.na(mean(AvgArea_Temp_Fodder, na.rm=T)), 0, mean(AvgArea_Temp_Fodder, na.rm=T)),
         AvgArea_Temp_OtherCrops = ifelse(is.na(mean(AvgArea_Temp_OtherCrops, na.rm=T)), 0, mean(AvgArea_Temp_OtherCrops, na.rm=T)),
         AvgPctArea_Maize_Crops_Temp = ifelse(is.na(mean(AvgPctArea_Maize_Crops_Temp, na.rm=T)), 0, mean(AvgPctArea_Maize_Crops_Temp, na.rm=T)),
         AvgPctArea_Maize_Temp = ifelse(is.na(mean(AvgPctArea_Maize_Temp, na.rm=T)), 0, mean(AvgPctArea_Maize_Temp, na.rm=T)),
         
         AvgArea_Total = mean(AvgArea_Total, na.rm=T),
         sdArea_Total = mean(sdArea_Total, na.rm=T),
         cvArea_Total = mean(cvArea_Total, na.rm=T),
         AvgArea_Total_Maize = mean(AvgArea_Total_Maize, na.rm=T),
         sdArea_Total_Maize = mean(sdArea_Total_Maize, na.rm=T),
         cvArea_Total_Maize = mean(cvArea_Total_Maize, na.rm=T),
         AvgArea_Total_Fodder = mean(AvgArea_Total_Fodder, na.rm=T),
         AvgArea_Total_OtherCrops = mean(AvgArea_Total_OtherCrops, na.rm=T),
         AvgPctArea_Maize_Crops_Total = mean(AvgPctArea_Maize_Crops_Total, na.rm=T),
         sdPctArea_Maize_Crops_Total = mean(sdPctArea_Maize_Crops_Total, na.rm=T),
         cvPctArea_Maize_Crops_Total = mean(cvPctArea_Maize_Crops_Total, na.rm=T),
         AvgPctArea_Maize_Total = mean(AvgPctArea_Maize_Total, na.rm=T),
         sdPctArea_Maize_Total = mean(sdPctArea_Maize_Total, na.rm=T),
         cvPctArea_Maize_Total = mean(cvPctArea_Maize_Total, na.rm=T)) %>%
   # ungroup the data
   ungroup() %>% 
   mutate(
    # irrigated maize % of total maize cultivation
    AvgPctMaizeArea_Irrig = AvgArea_Irrig_Maize / AvgArea_Total_Maize,
    AvgPctMaizeArea_Irrig = ifelse(is.nan(AvgPctMaizeArea_Irrig), 0, AvgPctMaizeArea_Irrig),
    # temporal maize % of total maize cultivation 
    AvgPctMaizeArea_Temp = AvgArea_Temp_Maize / AvgArea_Total_Maize,
    AvgPctMaizeArea_Temp = ifelse(is.nan(AvgPctMaizeArea_Temp), 0, AvgPctMaizeArea_Temp),
    # irrigated % of total cultivation 
    AvgPctArea_Irrig = AvgArea_Irrig / AvgArea_Total,#BY MUNICIPIO (both AGTypes have same value!)
    AvgPctArea_Irrig = ifelse(is.nan(AvgPctArea_Irrig), 0, AvgPctArea_Irrig),
    # temporal % of total cultivation 
    AvgPctArea_Temp = AvgArea_Temp / AvgArea_Total,
    AvgPctArea_Temp = ifelse(is.nan(AvgPctArea_Temp), 0, AvgPctArea_Temp)) %>% 
  rowwise() %>%
  # Remove NaN values from affected variables
  mutate(cvYieldLoss = ifelse(is.nan(cvYieldLoss), 0, cvYieldLoss),
         cvLost = ifelse(is.nan(cvLost), 0, cvLost)) %>% 
  ungroup()

x = SIAP_4_rs %>% 
  #group_by(Estado_ID, Estado, ddr_ID, ddr, Cader_ID, Cader, Municipio_ID, Municipio, EstadoMunicipio, AGType) %>%
  # group by all of the ID variables (effectively at the resolution of each agriculture type and state-municipality)
  group_by(Estado_ID, Estado, ddr_ID, ddr, Cader_ID, Cader, Municipio_ID, Municipio, EstadoMunicipio, AGType) %>%
  # summarize the dataset by state-municipality and agriculture type
  summarize(AvgYield = mean(Yield, na.rm=T), # mean/average maize yield
            sdYield = sd(Yield, na.rm=T), # standard deviation of maize yield
            minYield = min(Yield, na.rm=T), # minimum maize yield
            maxYield = max(Yield, na.rm=T), # maximum maize yield
            medYield = median(Yield, na.rm=T), # median maize yield
            cvYield = sd(Yield, na.rm=T)/mean(Yield, na.rm=T)*100, # coefficient of variation of maize yield
            
            AvgYieldLoss = mean(YieldLoss, na.rm=T), # mean/average maize Yield Loss
            sdYieldLoss = sd(YieldLoss, na.rm=T), # standard deviation of maize Yield Loss
            minYieldLoss = min(YieldLoss, na.rm=T), # minimum maize Yield Loss
            maxYieldLoss = max(YieldLoss, na.rm=T), # maximum maize Yield Loss
            medYieldLoss = median(YieldLoss, na.rm=T), # median maize Yield Loss
            cvYieldLoss = sd(YieldLoss, na.rm=T)/mean(YieldLoss, na.rm=T)*100,# coefficient of variation of maize Yield Loss
            
            AvgPctYieldLoss = mean(PctYieldLoss, na.rm=T), # mean/average maize Yield Loss
            sdPctYieldLoss = sd(PctYieldLoss, na.rm=T), # standard deviation of maize Yield Loss
            minPctYieldLoss = min(PctYieldLoss, na.rm=T), # minimum maize Yield Loss
            maxPctYieldLoss = max(PctYieldLoss, na.rm=T), # maximum maize Yield Loss
            medPctYieldLoss = median(PctYieldLoss, na.rm=T), # median maize Yield Loss
            cvPctYieldLoss = sd(PctYieldLoss, na.rm=T)/mean(PctYieldLoss, na.rm=T)*100,# coefficient of variation of maize Yield Loss
            
            AvgPlanted = mean(Planted, na.rm=T), # average hectares planted in maize
            sdPlanted = sd(Planted, na.rm=T), # standard deviation of hectares planted in maize
            cvPlanted = sdPlanted/AvgPlanted*100, # coefficient of variation of hectares planted in maize
            AvgHarvested = mean(Harvested, na.rm=T), # average hectares harvested in maize
            sdHarvested = sd(Harvested, na.rm=T), # standard deviation of hectares harvested in maize
            cvHarvested = sdHarvested/AvgHarvested*100, # coefficient of variation of hectares harvested in maize
            AvgLost = mean(Lost, na.rm=T), # average number of hectares of maize lost (i.e. planted but not harvested)
            sdLost = sd(Lost, na.rm=T), # standard deviation of hectares of maize lost (i.e. planted but not harvested)
            cvLost = sdLost/AvgLost*100, # coefficient of variation of hectares of maize lost (i.e. planted but not harvested)
            AvgProduct = mean(Product, na.rm=T), # average total kg of maize produced
            sdProduct = sd(Product, na.rm=T), # standard deviation of total kg of maize produced
            cvProduct = sdProduct/AvgProduct*100, # coefficient of variation of total kg of maize produced
            AvgValue = mean(Value, na.rm=T), # average total value in $MX of maize produced
            sdValue = sd(Value, na.rm=T), # standard deviation of total value in $MX of maize produced
            cvValue = sdValue/AvgValue*100, # coefficient of variation of total value in $MX of maize produced
            AvgPrice = mean(Price, na.rm=T), # average price per kg in $MX for maize
            sdPrice = sd(Price, na.rm=T), # standard deviation of price per kg in $MX for maize
            cvPrice = sdPrice/AvgPrice*100, # coefficient of variation of price per kg in $MX for maize
            n = mean(n, na.rm=T),# number of time series cases by state-municipality and agriculture type
            AvgArea = mean(Area_AGType, na.rm=T),
            sdArea = sd(Area_AGType, na.rm=T),
            cvArea = sdArea/AvgArea*100,
            AvgArea_Maize = mean(Area_AGType_Maize, na.rm=T),
            sdArea_Maize = sd(Area_AGType_Maize, na.rm=T),
            cvArea_Maize = sdArea_Maize/AvgArea_Maize*100,
            AvgArea_Fodder = mean(Area_AGType_Fodder, na.rm=T),
            AvgArea_OtherCrops = mean(Area_AGType_OtherCrops, na.rm=T),
            AvgPctArea_Maize_Crops = mean(PctArea_Maize_Crops_AGType, na.rm=T),
            sdPctArea_Maize_Crops = sd(PctArea_Maize_Crops_AGType, na.rm=T),
            cvPctArea_Maize_Crops = sdPctArea_Maize_Crops/AvgPctArea_Maize_Crops*100,
            AvgPctArea_Maize = mean(PctArea_Maize_AGType, na.rm=T),
            sdPctArea_Maize = sd(PctArea_Maize_AGType, na.rm=T),
            cvPctArea_Maize = sdPctArea_Maize/AvgPctArea_Maize*100)

SIAP_6_rs = SIAP_4_rs %>% 
  # group by all of the ID variables (effectively at the resolution of each agriculture type and state-municipality)
  group_by(Estado_ID, Estado, ddr_ID, ddr, Cader_ID, Cader, Municipio_ID, Municipio, EstadoMunicipio) %>%
  # summarize the dataset by state-municipality and agriculture type
  summarize(AGType = "Total",
            AvgYield = mean(Yield, na.rm=T), # mean/average maize yield
            sdYield = sd(Yield, na.rm=T), # standard deviation of maize yield
            minYield = min(Yield, na.rm=T), # minimum maize yield
            maxYield = max(Yield, na.rm=T), # maximum maize yield
            medYield = median(Yield, na.rm=T), # median maize yield
            cvYield = sd(Yield, na.rm=T)/mean(Yield, na.rm=T)*100, # coefficient of variation of maize yield
            
            AvgYieldLoss = mean(YieldLoss, na.rm=T), # mean/average maize Yield Loss
            sdYieldLoss = sd(YieldLoss, na.rm=T), # standard deviation of maize Yield Loss
            minYieldLoss = min(YieldLoss, na.rm=T), # minimum maize Yield Loss
            maxYieldLoss = max(YieldLoss, na.rm=T), # maximum maize Yield Loss
            medYieldLoss = median(YieldLoss, na.rm=T), # median maize Yield Loss
            cvYieldLoss = sd(YieldLoss, na.rm=T)/mean(YieldLoss, na.rm=T)*100,# coefficient of variation of maize Yield Loss
            
            AvgPctYieldLoss = mean(PctYieldLoss, na.rm=T), # mean/average maize Yield Loss
            sdPctYieldLoss = sd(PctYieldLoss, na.rm=T), # standard deviation of maize Yield Loss
            minPctYieldLoss = min(PctYieldLoss, na.rm=T), # minimum maize Yield Loss
            maxPctYieldLoss = max(PctYieldLoss, na.rm=T), # maximum maize Yield Loss
            medPctYieldLoss = median(PctYieldLoss, na.rm=T), # median maize Yield Loss
            cvPctYieldLoss = sd(PctYieldLoss, na.rm=T)/mean(PctYieldLoss, na.rm=T)*100,# coefficient of variation of maize Yield Loss
            
            AvgPlanted = mean(Planted, na.rm=T), # average hectares planted in maize
            sdPlanted = sd(Planted, na.rm=T), # standard deviation of hectares planted in maize
            cvPlanted = sdPlanted/AvgPlanted*100, # coefficient of variation of hectares planted in maize
            AvgHarvested = mean(Harvested, na.rm=T), # average hectares harvested in maize
            sdHarvested = sd(Harvested, na.rm=T), # standard deviation of hectares harvested in maize
            cvHarvested = sdHarvested/AvgHarvested*100, # coefficient of variation of hectares harvested in maize
            AvgLost = mean(Lost, na.rm=T), # average number of hectares of maize lost (i.e. planted but not harvested)
            sdLost = sd(Lost, na.rm=T), # standard deviation of hectares of maize lost (i.e. planted but not harvested)
            cvLost = sdLost/AvgLost*100, # coefficient of variation of hectares of maize lost (i.e. planted but not harvested)
            AvgProduct = mean(Product, na.rm=T), # average total kg of maize produced
            sdProduct = sd(Product, na.rm=T), # standard deviation of total kg of maize produced
            cvProduct = sdProduct/AvgProduct*100, # coefficient of variation of total kg of maize produced
            AvgValue = mean(Value, na.rm=T), # average total value in $MX of maize produced
            sdValue = sd(Value, na.rm=T), # standard deviation of total value in $MX of maize produced
            cvValue = sdValue/AvgValue*100, # coefficient of variation of total value in $MX of maize produced
            AvgPrice = mean(Price, na.rm=T), # average price per kg in $MX for maize
            sdPrice = sd(Price, na.rm=T), # standard deviation of price per kg in $MX for maize
            cvPrice = sdPrice/AvgPrice*100, # coefficient of variation of price per kg in $MX for maize
            n = n(),# number of time series cases by state-municipality and agriculture type
            AvgArea = mean(AvgArea_Total, na.rm=T),
            sdArea = mean(sdArea_Total, na.rm=T),
            cvArea = mean(cvArea_Total, na.rm=T),
            AvgArea_Maize = mean(AvgArea_Total_Maize, na.rm=T),
            sdArea_Maize = mean(sdArea_Total_Maize, na.rm=T),
            cvArea_Maize = mean(cvArea_Total_Maize, na.rm=T),
            AvgArea_Fodder = mean(AvgArea_Total_Fodder, na.rm=T),
            AvgArea_OtherCrops = mean(AvgArea_Total_OtherCrops, na.rm=T),
            AvgPctArea_Maize_Crops = mean(AvgPctArea_Maize_Crops_Total, na.rm=T),
            sdPctArea_Maize_Crops = mean(sdPctArea_Maize_Crops_Total, na.rm=T),
            cvPctArea_Maize_Crops = mean(cvPctArea_Maize_Crops_Total, na.rm=T),
            AvgPctArea_Maize = mean(AvgPctArea_Maize_Total, na.rm=T),
            sdPctArea_Maize = mean(sdPctArea_Maize_Total, na.rm=T),
            cvPctArea_Maize = mean(cvPctArea_Maize_Total, na.rm=T)) %>% 
  ungroup() %>% 
  bind_rows(x) %>% 
  pivot_longer(-c(Estado_ID, Estado, ddr_ID, ddr, Cader_ID, Cader, Municipio_ID, Municipio, EstadoMunicipio, AGType), names_to = "Variable", values_to = "Value") %>% 
  mutate(AGType = case_when(
    AGType == "Riego" ~ "Irrig",
    AGType == "Temporal" ~ "Temp",
    AGType == "Total" ~ "Total")) %>% 
  pivot_wider(names_from = c(Variable, AGType), names_glue = "{Variable}_{AGType}", values_from = Value, values_fill = NA) %>% 
  #rowwise() %>% 
  mutate(
    # Calculate the ratios of irrigated and temporal variables to their state-municipality averages
    ITr_AvgYield = ifelse((AvgYield_Irrig/AvgYield_Total) == 1, NA, AvgYield_Irrig/AvgYield_Total),
    ITr_sdYield = ifelse((sdYield_Irrig/sdYield_Total) == 1, NA, sdYield_Irrig/sdYield_Total),
    ITr_minYield = ifelse((minYield_Irrig/minYield_Total) == 1, NA, minYield_Irrig/minYield_Total),
    ITr_maxYield = ifelse((maxYield_Irrig/maxYield_Total) == 1, NA, maxYield_Irrig/maxYield_Total),
    ITr_medYield = ifelse((medYield_Irrig/medYield_Total) == 1, NA, medYield_Irrig/medYield_Total),
    ITr_cvYield = ifelse((cvYield_Irrig/cvYield_Total) == 1, NA, cvYield_Irrig/cvYield_Total),
    ITr_AvgYieldLoss = ifelse((AvgYieldLoss_Irrig/AvgYieldLoss_Total) == 1, NA, AvgYieldLoss_Irrig/AvgYieldLoss_Total),
    ITr_sdYieldLoss = ifelse((sdYieldLoss_Irrig/sdYieldLoss_Total) == 1, NA, sdYieldLoss_Irrig/sdYieldLoss_Total),
    ITr_minYieldLoss = ifelse((minYieldLoss_Irrig/minYieldLoss_Total) == 1, NA, minYieldLoss_Irrig/minYieldLoss_Total),
    ITr_maxYieldLoss = ifelse((maxYieldLoss_Irrig/maxYieldLoss_Total) == 1, NA, maxYieldLoss_Irrig/maxYieldLoss_Total),
    ITr_medYieldLoss = ifelse((medYieldLoss_Irrig/medYieldLoss_Total) == 1, NA, medYieldLoss_Irrig/medYieldLoss_Total),
    ITr_cvYieldLoss = ifelse((cvYieldLoss_Irrig/cvYieldLoss_Total) == 1, NA, cvYieldLoss_Irrig/cvYieldLoss_Total),
    ITr_AvgPlanted = ifelse((AvgPlanted_Irrig/AvgPlanted_Total) == 1, NA, AvgPlanted_Irrig/AvgPlanted_Total),
    ITr_AvgPctYieldLoss = ifelse((AvgPctYieldLoss_Irrig/AvgPctYieldLoss_Total) == 1, NA, AvgPctYieldLoss_Irrig/AvgPctYieldLoss_Total),
    ITr_sdPctYieldLoss = ifelse((sdPctYieldLoss_Irrig/sdPctYieldLoss_Total) == 1, NA, sdPctYieldLoss_Irrig/sdPctYieldLoss_Total),
    ITr_minPctYieldLoss = ifelse((minPctYieldLoss_Irrig/minPctYieldLoss_Total) == 1, NA, minPctYieldLoss_Irrig/minPctYieldLoss_Total),
    ITr_maxPctYieldLoss = ifelse((maxPctYieldLoss_Irrig/maxPctYieldLoss_Total) == 1, NA, maxPctYieldLoss_Irrig/maxPctYieldLoss_Total),
    ITr_medPctYieldLoss = ifelse((medPctYieldLoss_Irrig/medPctYieldLoss_Total) == 1, NA, medPctYieldLoss_Irrig/medPctYieldLoss_Total),
    ITr_cvPctYieldLoss = ifelse((cvPctYieldLoss_Irrig/cvPctYieldLoss_Total) == 1, NA, cvPctYieldLoss_Irrig/cvPctYieldLoss_Total),
    ITr_AvgPlanted = ifelse((AvgPlanted_Irrig/AvgPlanted_Total) == 1, NA, AvgPlanted_Irrig/AvgPlanted_Total),
    ITr_sdPlanted = ifelse((sdPlanted_Irrig/sdPlanted_Total) == 1, NA, sdPlanted_Irrig/sdPlanted_Total),
    ITr_cvPlanted = ifelse((cvPlanted_Irrig/cvPlanted_Total) == 1, NA, cvPlanted_Irrig/cvPlanted_Total),
    ITr_AvgHarvested = ifelse((AvgHarvested_Irrig/AvgHarvested_Total) == 1, NA, AvgHarvested_Irrig/AvgHarvested_Total),
    ITr_sdHarvested = ifelse((sdHarvested_Irrig/sdHarvested_Total) == 1, NA, sdHarvested_Irrig/sdHarvested_Total),
    ITr_cvHarvested = ifelse((cvHarvested_Irrig/cvHarvested_Total) == 1, NA, cvHarvested_Irrig/cvHarvested_Total),
    ITr_AvgLost = ifelse((AvgLost_Irrig/AvgLost_Total) == 1, NA, AvgLost_Irrig/AvgLost_Total),
    ITr_sdLost = ifelse((sdLost_Irrig/sdLost_Total) == 1, NA, sdLost_Irrig/sdLost_Total),
    ITr_cvLost = ifelse((cvLost_Irrig/cvLost_Total) == 1, NA, cvLost_Irrig/cvLost_Total),
    ITr_AvgProduct = ifelse((AvgProduct_Irrig/AvgProduct_Total) == 1, NA, AvgProduct_Irrig/AvgProduct_Total),
    ITr_sdProduct = ifelse((sdProduct_Irrig/sdProduct_Total) == 1, NA, sdProduct_Irrig/sdProduct_Total),
    ITr_cvProduct = ifelse((cvProduct_Irrig/cvProduct_Total) == 1, NA, cvProduct_Irrig/cvProduct_Total),
    # Calculate the ratio of temporal variables to the state-municipality average
    TTr_AvgYield = ifelse((AvgYield_Temp/AvgYield_Total) == 1, NA, AvgYield_Temp/AvgYield_Total),
    TTr_sdYield = ifelse((sdYield_Temp/sdYield_Total) == 1, NA, sdYield_Temp/sdYield_Total),
    TTr_minYield = ifelse((minYield_Temp/minYield_Total) == 1, NA, minYield_Temp/minYield_Total),
    TTr_maxYield = ifelse((maxYield_Temp/maxYield_Total) == 1, NA, maxYield_Temp/maxYield_Total),
    TTr_medYield = ifelse((medYield_Temp/medYield_Total) == 1, NA, medYield_Temp/medYield_Total),
    TTr_cvYield = ifelse((cvYield_Temp/cvYield_Total) == 1, NA, cvYield_Temp/cvYield_Total),
    TTr_AvgYieldLoss = ifelse((AvgYieldLoss_Temp/AvgYieldLoss_Total) == 1, NA, AvgYieldLoss_Temp/AvgYieldLoss_Total),
    TTr_sdYieldLoss = ifelse((sdYieldLoss_Temp/sdYieldLoss_Total) == 1, NA, sdYieldLoss_Temp/sdYieldLoss_Total),
    TTr_minYieldLoss = ifelse((minYieldLoss_Temp/minYieldLoss_Total) == 1, NA, minYieldLoss_Temp/minYieldLoss_Total),
    TTr_maxYieldLoss = ifelse((maxYieldLoss_Temp/maxYieldLoss_Total) == 1, NA, maxYieldLoss_Temp/maxYieldLoss_Total),
    TTr_medYieldLoss = ifelse((medYieldLoss_Temp/medYieldLoss_Total) == 1, NA, medYieldLoss_Temp/medYieldLoss_Total),
    TTr_cvYieldLoss = ifelse((cvYieldLoss_Temp/cvYieldLoss_Total) == 1, NA, cvYieldLoss_Temp/cvYieldLoss_Total),
    TTr_AvgPctYieldLoss = ifelse((AvgPctYieldLoss_Temp/AvgPctYieldLoss_Total) == 1, NA, AvgPctYieldLoss_Temp/AvgPctYieldLoss_Total),
    TTr_sdPctYieldLoss = ifelse((sdPctYieldLoss_Temp/sdPctYieldLoss_Total) == 1, NA, sdPctYieldLoss_Temp/sdPctYieldLoss_Total),
    TTr_minPctYieldLoss = ifelse((minPctYieldLoss_Temp/minPctYieldLoss_Total) == 1, NA, minPctYieldLoss_Temp/minPctYieldLoss_Total),
    TTr_maxPctYieldLoss = ifelse((maxPctYieldLoss_Temp/maxPctYieldLoss_Total) == 1, NA, maxPctYieldLoss_Temp/maxPctYieldLoss_Total),
    TTr_medPctYieldLoss = ifelse((medPctYieldLoss_Temp/medPctYieldLoss_Total) == 1, NA, medPctYieldLoss_Temp/medPctYieldLoss_Total),
    TTr_cvPctYieldLoss = ifelse((cvPctYieldLoss_Temp/cvPctYieldLoss_Total) == 1, NA, cvPctYieldLoss_Temp/cvPctYieldLoss_Total),
    TTr_AvgPlanted = ifelse((AvgPlanted_Temp/AvgPlanted_Total) == 1, NA, AvgPlanted_Temp/AvgPlanted_Total),
    TTr_sdPlanted = ifelse((sdPlanted_Temp/sdPlanted_Total) == 1, NA, sdPlanted_Temp/sdPlanted_Total),
    TTr_cvPlanted = ifelse((cvPlanted_Temp/cvPlanted_Total) == 1, NA, cvPlanted_Temp/cvPlanted_Total),
    TTr_AvgHarvested = ifelse((AvgHarvested_Temp/AvgHarvested_Total) == 1, NA, AvgHarvested_Temp/AvgHarvested_Total),
    TTr_sdHarvested = ifelse((sdHarvested_Temp/sdHarvested_Total) == 1, NA, sdHarvested_Temp/sdHarvested_Total),
    TTr_cvHarvested = ifelse((cvHarvested_Temp/cvHarvested_Total) == 1, NA, cvHarvested_Temp/cvHarvested_Total),
    TTr_AvgLost = ifelse((AvgLost_Temp/AvgLost_Total) == 1, NA, AvgLost_Temp/AvgLost_Total),
    TTr_sdLost = ifelse((sdLost_Temp/sdLost_Total) == 1, NA, sdLost_Temp/sdLost_Total),
    TTr_cvLost = ifelse((cvLost_Temp/cvLost_Total) == 1, NA, cvLost_Temp/cvLost_Total),
    TTr_AvgProduct = ifelse((AvgProduct_Temp/AvgProduct_Total) == 1, NA, AvgProduct_Temp/AvgProduct_Total),
    TTr_sdProduct = ifelse((sdProduct_Temp/sdProduct_Total) == 1, NA, sdProduct_Temp/sdProduct_Total),
    TTr_cvProduct = ifelse((cvProduct_Temp/cvProduct_Total) == 1, NA, cvProduct_Temp/cvProduct_Total)
  ) %>% ungroup() %>% 
  mutate(
    # irrigated maize % of total maize cultivation
    AvgPctMaizeArea_Irrig = AvgArea_Maize_Irrig / AvgArea_Maize_Total,
    AvgPctMaizeArea_Irrig = ifelse(is.nan(AvgPctMaizeArea_Irrig), 0, AvgPctMaizeArea_Irrig),
    # temporal maize % of total maize cultivation 
    AvgPctMaizeArea_Temp = AvgArea_Maize_Temp / AvgArea_Maize_Total,
    AvgPctMaizeArea_Temp = ifelse(is.nan(AvgPctMaizeArea_Temp), 0, AvgPctMaizeArea_Temp),
    # irrigated % of total cultivation 
    AvgPctArea_Irrig = AvgArea_Irrig / AvgArea_Total,#BY MUNICIPIO (both AGTypes have same value!)
    AvgPctArea_Irrig = ifelse(is.nan(AvgPctArea_Irrig), 0, AvgPctArea_Irrig),
    # temporal % of total cultivation 
    AvgPctArea_Temp = AvgArea_Temp / AvgArea_Total,
    AvgPctArea_Temp = ifelse(is.nan(AvgPctArea_Temp), 0, AvgPctArea_Temp))
rm(x)

rm(x)

write.csv(SIAP_3_rs, paste0(wd$data_r,"SIAP_3_rescale.csv"))

write.csv(SIAP_4_rs, paste0(wd$data_r,"SIAP_4_rescale.csv"))

write.csv(SIAP_5_rs, paste0(wd$data_r,"SIAP_5_rescale.csv"))

write.csv(SIAP_6_rs, paste0(wd$data_r,"SIAP_6_rescale.csv"))

SIAP_5_remove_cases_rs = SIAP_5_rs %>% 
# remove irrigation maize yield cases for some municipalities that lack irrigation agriculture in the land use data
  filter(!(EstadoMunicipio %in% c("Chigmecatitlan, Puebla", 
                                  "Huitzilac, Morelos", 
                                  "San Jose Teacalco, Tlaxcala", 
                                  "Tlalnepantla, Morelos", 
                                  "Totolapan, Morelos", 
                                  "Acajete, Puebla", 
                                  "Almoloya, Hidalgo", 
                                  "Apan, Hidalgo", 
                                  "Atlatlahucan, Morelos", 
                                  "Emiliano Zapata, Hidalgo", 
                                  "Mazatecochco de Jose Maria Morelos, Tlaxcala", 
                                  "San Francisco Tetlanohcan, Tlaxcala", 
                                  "San Pablo del Monte, Tlaxcala", 
                                  "Tolcayuca, Hidalgo", 
                                  "Tonanitla, Mexico", 
                                  "Amaxac de Guerrero, Tlaxcala", 
                                  "Jaltenco, Mexico") & AGType %in% "Riego"))

LU2000e <- st_read(paste0(wd$data_r, "LU2000e.gpkg")) 

SIAP_LU_poly = LU2000e %>% left_join(SIAP_5_remove_cases_rs, by = c("EstadoMunicipio", "AGType")) %>% select(-ddr_ID, -ddr, -Cader_ID, -Cader, -Municipio_ID.y, -Municipio.y, -Estado_ID.y, -Estado.y, -Area_m2) %>% rename( Municipio = Municipio.x, Estado = Estado.x, Estado_ID = Estado_ID.x, Municipio_ID = Municipio_ID.x, AGType_Area_ha = Area_ha)

Census2000s <- read.csv(paste0(wd$data_p,"CensusData2000s.csv")) %>% select(-Estado_ID, -Municipio_ID, -X)
#Census2000s_poly <- st_read(paste0(wd$data_p, "Census2000s_poly.gpkg")) 

Data2000s_poly_rs = SIAP_LU_poly %>% left_join(Census2000s, by = c("EstadoMunicipio", "Estado", "Municipio"))

Data2000s_poly_rs <- Data2000s_poly_rs %>% mutate(
  LU_Total_DensArable = ifelse(LU_Total_DensArable > 3.5, 3.5, LU_Total_DensArable),
  AG_Workers_DensArable = ifelse(AG_Workers_DensArable > 1, 1, AG_Workers_DensArable),
  #MechanizEquip_DensArable = MechanizEquip / Arable_ha,
  #DraftAnimals_DensArable = DraftAnimals_Total / Arable_ha,
  PrimaryEmploy_DensArable = ifelse(PrimaryEmploy_DensArable > 1.3, 1.3, PrimaryEmploy_DensArable),
  TotalLabor_DensArable = ifelse(TotalLabor_DensArable > 2.5, 2.5, TotalLabor_DensArable),
  Pop_DensArable = ifelse(Pop_DensArable > 100, 100, Pop_DensArable),
  PopRural_DensArable = ifelse(PopRural_DensArable > 7, 7, PopRural_DensArable))

#########################################################################


# Labor and laboresque capital input metrics modified by percent total area planted in maize by AGType &
# Intensive labor and laboresque capital input metrics using SIAP Maize planted area by AGType as denominator

Data2000s_poly_rs <- Data2000s_poly_rs %>% rowwise() %>% mutate(

  # Modify labor and laboresque capital input metrics by the percentage of average total cultivated area planted in maize
  # This is done by agriculture type, so that the value for each row reflects its average % of cultivated area (either irrigated or temporal), rather than the municipal total
  # This assumes that the percent of total labor devoted to maize cultivation is directly proportional to its fraction of total cultivation (i.e. that average labor allocation to a crop is proportional to its proportion of the average cultivated area)
  AvgPctArea_ofTotal = AvgArea_Maize / AvgArea_Total,
  AvgPctArea_ofArable = AvgArea_Maize / Arable_ha,
  #AvgPctArea_ofTotal = case_when(
  #  EstadoMunicipio == "High Elevation" ~ 0.4700912,
  #  .default = AvgPctArea_ofTotal),
  #AvgPctArea_ofArable = case_when(
  #  EstadoMunicipio == "High Elevation" ~ 0.2847692,
  #  .default = AvgPctArea_ofArable),
  PopRuralMz = Pop_Rural * AvgPctArea_ofTotal,
  PrimaryMz = Primary * AvgPctArea_ofTotal,
  AGWorkersMz = AG_Workers * AvgPctArea_ofTotal,
  TotalLaborMz = TotalLabor * AvgPctArea_ofTotal,
  LUTotalMz = LU_Total * AvgPctArea_ofTotal, 
  ContractLaboTotMz = ContractLabor_Tot * AvgPctArea_ofTotal, 
  ContractLaborFullMz = ContractLabor_More6Mo * AvgPctArea_ofTotal, 
  ContractLaboPartMz = ContractLabor_Less6Mo * AvgPctArea_ofTotal, 
  FamLaborMz = FamLabor_Tot * AvgPctArea_ofTotal, 
  MechanizEquipMz = MechanizEquip * AvgPctArea_ofTotal, 
  DraftAnimalsMz = DraftAnimals_Total * AvgPctArea_ofTotal, 
  TractorsMz = Tractors * AvgPctArea_ofTotal,
  
  # Calculate the intensity of maize labor and laboresque capital input metrics per unit area (hectares)
  # This is done by agriculture type, so that the value for each row reflects its average % of cultivated area (either irrigated or temporal), rather than the municipal total
  # This assumes that the inter-annual average cultivated area for maize (by AGType) is representative
  
  PopRuralMz_perMzHa = PopRuralMz / AvgArea_Maize,
  #PopRuralMz_perMzHa = ifelse(PopRuralMz_perMzHa > 150, 150, PopRuralMz_perMzHa),
  PrimaryMz_perMzHa = PrimaryMz / AvgArea_Maize,
  AGWorkersMz_perMzHa = AGWorkersMz / AvgArea_Maize,
  TotalLaborMz_perMzHa = TotalLaborMz / AvgArea_Maize,
  LUTotalMz_perMzHa = LUTotalMz / AvgArea_Maize,
  ContractLaboTotMz_perMzHa = ContractLaboTotMz / AvgArea_Maize,
  ContractLaborFullMz_perMzHa = ContractLaborFullMz / AvgArea_Maize,
  ContractLaboPartMz_perMzHa = ContractLaboPartMz / AvgArea_Maize,
  FamLaborMz_perMzHa = FamLaborMz / AvgArea_Maize,
  MechanizEquipMz_perMzHa = MechanizEquipMz / AvgArea_Maize,
  DraftAnimalsMz_perMzHa = DraftAnimalsMz / AvgArea_Maize,
  TractorsMz_perMzHa = TractorsMz / AvgArea_Maize) %>% ungroup()

st_write(Data2000s_poly_rs, paste0(wd$data_p, "Data2000s_poly_rescale.gpkg"), driver = "GPKG", overwrite=TRUE, append=FALSE)

rm(SIAP_5_remove_cases_rs, Census2000s, LU2000e, SIAP_LU_poly)

x = SIAP_4_rs %>% 
  select(Municipio, Estado, EstadoMunicipio, Year, AGType, Harvested, Product) %>%
  group_by(Municipio, Estado, EstadoMunicipio, Year) %>% 
  summarize(AGType = "Total",
    Yield = sum(Product, na.rm=T) / sum(Harvested, na.rm=T))

SIAP_annual_rs = SIAP_4_rs %>% 
  select(Municipio, Estado, EstadoMunicipio, Year, AGType, Yield) %>%
  mutate(AGType = case_when(
    AGType == "Riego" ~ "Irrig",
    AGType == "Temporal" ~ "Temp")) %>% 
  bind_rows(x) %>% 
  pivot_wider(
    names_from = c(Year, AGType),
    names_glue = "Y_{Year}_{AGType}",
    values_from = Yield)

rm(x)

SIAP_averages_rs = SIAP_6_rs %>% select(-Estado_ID, -ddr, -ddr_ID, -Cader, -Cader_ID, -Municipio_ID)

z = SIAP_4_rs %>% 
  select(Municipio, Estado, EstadoMunicipio, Year, AGType, Harvested, Product) %>%
  group_by(Municipio, Estado, EstadoMunicipio, Year) %>% 
  summarize(AGType = "Total",
    Yield = sum(Product, na.rm=T) / sum(Harvested, na.rm=T)) %>% 
  ungroup() %>% 
  group_by(EstadoMunicipio) %>%
  mutate(avg = mean(Yield, na.rm=T),
         sd = sd(Yield, na.rm=T)) %>% ungroup() %>% 
  mutate(Zfluct_Yield = (Yield - avg) / sd) %>%
  ungroup() %>% 
  select(-Yield,-avg,-sd)
  
SIAP_ZFluct_long_rs = SIAP_4_rs %>% 
  select(Municipio, Estado, EstadoMunicipio, Year, AGType, Yield) %>%
  group_by(EstadoMunicipio, AGType) %>%
  mutate(Zfluct_Yield = (Yield - mean(Yield, na.rm=T)) / sd(Yield, na.rm=T)) %>%
  ungroup() %>% 
  select(-Yield) %>% 
  bind_rows(z)

rm(z)

SIAP_ZFluct_rs = SIAP_ZFluct_long_rs %>% 
  mutate(AGType = case_when(
    AGType == "Riego" ~ "Irrig",
    AGType == "Temporal" ~ "Temp",
    AGType == "Total" ~ "Total")) %>% 
  pivot_wider(
    names_from = c(Year, AGType),
    names_glue = "YZf_{Year}_{AGType}",
    values_from = Zfluct_Yield)

rm(SIAP_ZFluct_long_rs)

SIAP_yields_rs = SIAP_annual_rs %>% left_join(SIAP_averages_rs, by = c("Municipio", "Estado", "EstadoMunicipio")) 

rm(SIAP_annual_rs, SIAP_averages_rs)

AGC1960 <- read.csv(paste0(wd$data_p,"AGC1960.csv"))
AGC1970 <- read.csv(paste0(wd$data_p,"AGC1970.csv"))
AGC1991 <- read.csv(paste0(wd$data_p,"AGC1991.csv"))
AGC2007 <- read.csv(paste0(wd$data_p,"AGC2007.csv"))
Municipios2000s <- st_read(paste0(wd$data_p, "Municipios2000s_Data.gpkg"))

scale2 <- function(x) (x - mean(x, na.rm = T)) / sd(x, na.rm = T)
  
MunicipioYields_rs <- Municipios2000s %>% 
  left_join(AGC1960, by = c("Municipio", "Estado", "EstadoMunicipio")) %>%
  left_join(AGC1970, by = c("Municipio", "Estado", "EstadoMunicipio")) %>%
  left_join(AGC1991, by = c("Municipio", "Estado", "EstadoMunicipio")) %>%
  left_join(AGC2007, by = c("Municipio", "Estado", "EstadoMunicipio")) %>%
  left_join(SIAP_yields_rs, by = c("Municipio", "Estado", "EstadoMunicipio")) %>%
  select(-Area_m2)#-AGType.x, -AGType.y, 

MunicipioYields_Z_rs <- MunicipioYields_rs %>% 
  mutate(across(where(is.numeric), scale2)) %>%
  left_join(SIAP_ZFluct_rs, by = c("Municipio", "Estado", "EstadoMunicipio")) %>%
  mutate(CoT_1960_SIAP_dif = AvgYield_Total - Y_1960_Total,
         CoT_1960_SIAP_rat = AvgYield_Total / Y_1960_Total)


MunicipioYields_rs <- MunicipioYields_rs %>% 
  left_join(SIAP_ZFluct_rs, by = c("Municipio", "Estado", "EstadoMunicipio")) %>%
  mutate(CoT_1960_SIAP_dif = AvgYield_Total - Y_1960_Total,
         CoT_1960_SIAP_rat = AvgYield_Total / Y_1960_Total)

st_write(MunicipioYields_rs, paste0(wd$data_p, "MunicipioYields_rs.gpkg"), driver = "GPKG", overwrite=T, append=FALSE)
st_write(MunicipioYields_Z_rs, paste0(wd$data_p, "MunicipioYields_Z_rs.gpkg"), driver = "GPKG", overwrite=T, append=FALSE)

rm(SIAP_ZFluct_rs, AGC1960, AGC1970, AGC1991, AGC2007, Municipios2000s, SIAP_yields_rs, SIAP_ID, rEM, rM)

rm(MunicipioYields_rs, MunicipioYields_Z_rs, SIAP_3_rs, SIAP_4_rs, SIAP_5_rs, SIAP_6_rs, Data2000s_poly_rs)



```


## Load Data


```{r}
SIAP_4_rs <- read.csv(paste0(wd$data_r,"SIAP_4_rescale.csv"))
SIAP_5_rs <- read.csv(paste0(wd$data_r,"SIAP_5_rescale.csv"))
#SIAP_6_rs <- read.csv(paste0(wd$data_r,"SIAP_6_rescale.csv"))
#MunicipioYields_rs <- st_read(paste0(wd$data_p, "MunicipioYields_rs.gpkg"))
MunicipioYields_Z_rs <- st_read(paste0(wd$data_p, "MunicipioYields_Z_rs.gpkg"))
Data2000s_poly_rs <- st_read(paste0(wd$data_p, "Data2000s_poly_rescale.gpkg"))

```


## Histograms


#### Average Yield Histograms

```{r, label='SIAP Yield Histograms', message=FALSE,warning=FALSE}

h1 = ggplot(SIAP_4,aes(x = Yield)) +
  geom_histogram(aes(group = AGType, fill = AGType),alpha = 0.5, position = "identity", binwidth = 300, color = "black") +
  scale_fill_manual(name = "Agriculture Type", values = c("cyan1", "indianred1"), breaks = c("Riego", "Temporal"), labels = c("Irrigation", "Temporal"))+
  geom_density(aes(group = AGType, color = AGType, y=360 * ..count..), adjust = 2, size=1, alpha=0.5)+
  scale_color_manual(name = "Agriculture Type",values = c("cyan2", "firebrick1"), breaks = c("Riego", "Temporal"), labels = c("Irrigation", "Temporal"))+
  labs(x ="Maize Yield (kg / ha)", y = "Count")+
    theme_bw()+
    scale_x_continuous(limits= c(0,12000), breaks=seq(0,12000,2000)) +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="black", size=11), 
          axis.text.y = element_text(color="black", size=11), 
          axis.title.x = element_text(color="black", size=14, face="bold"),
          axis.title.y = element_text(color="black", size=14, face="bold"),
          legend.justification=c(0,1), legend.position=c(0.5,0.85), 
          legend.title=element_blank(),
          legend.box.background = element_rect(colour = "black"),
          legend.text = element_text(colour="black", size = 12),
          legend.background = element_rect(fill="white",size=0.5, linetype="solid", color ="black"))

df = SIAP_4 %>% group_by(EstadoMunicipio, Year) %>% summarize(Yield = sum(Product, na.rm=T) / sum(Planted, na.rm=T))
df$Series <- "Municipal Average"
df2 = SIAP_4 %>% select(EstadoMunicipio, Year, Yield) %>% mutate(Series = "Both Irrigation and Temporal")
df = rbind(df,df2)

h2 = ggplot(df,aes(x = Yield)) +
  geom_histogram(aes(group = Series, fill = Series),alpha = 0.5, position = "identity", binwidth = 300, color = "black") +
  scale_fill_manual(name = "Agriculture Type", values = c("grey75", "greenyellow"), breaks = c("Municipal Average", "Both Irrigation and Temporal"), labels = c("Total", "All"))+
  geom_density(aes(group = Series, color = Series, y=360 * ..count..), adjust = 2, size=1, alpha=0.5)+
  scale_color_manual(name = "Agriculture Type",values = c("black", "green"), breaks = c("Municipal Average", "Both Irrigation and Temporal"), labels = c("Total", "All"))+
  labs(x ="Maize Yield (kg / ha)", y = "Count")+
    theme_bw()+
    scale_x_continuous(limits= c(0,12000), breaks=seq(0,12000,2000)) +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="black", size=11), 
          axis.text.y = element_text(color="black", size=11), 
          axis.title.x = element_text(color="black", size=14, face="bold"),
          axis.title.y = element_text(color="black", size=14, face="bold"),
          legend.justification=c(0,1), legend.position=c(0.5,0.85), 
          legend.title=element_blank(),
          legend.box.background = element_rect(colour = "black"),
          legend.text = element_text(colour="black", size = 12),
          legend.background = element_rect(fill="white",size=0.5, linetype="solid", color ="black"))

ggp2 = plot_grid(h1, h2, labels = c('A', 'B'), label_size = 24)


#save figure
ggsave("Hists_SIAP_AGType_AvgYield.png", plot = ggp2, device = "png", path = wd$figs, scale = 1, width = 8, height = 4.5,   units = "in",  dpi = 1500)

YieldIrrig = SIAP_4 %>% filter(AGType == "Riego") %>% pull(Yield) %>% na.omit
YieldTemp = SIAP_4 %>% filter(AGType == "Temporal") %>% pull(Yield) %>% na.omit
YieldTotal = df %>% filter(Series == "Municipal Average") %>% pull(Yield) %>% na.omit
YieldAll = df %>% filter(Series == "Both Irrigation and Temporal") %>% pull(Yield) %>% na.omit

gamma_test(YieldIrrig[YieldIrrig > 0])
gamma_test(YieldTemp[YieldTemp > 0])
gamma_test(YieldTotal[YieldTotal > 0])
gamma_test(YieldAll[YieldAll > 0])

rm(ggp2, h1, h2, df, df2, YieldIrrig, YieldTemp, YieldTotal, YieldAll)

# import figure for display
knitr::include_graphics(paste0(wd$figs,"Hists_SIAP_AGType_AvgYield.png"), FALSE)
```





#### C.V. Yield Histograms

```{r, label='SIAP CV Yield Histograms', message=FALSE,warning=FALSE}

h1 = ggplot(SIAP_5,aes(x = cvYield)) +
  geom_histogram(aes(group = AGType, fill = AGType),alpha = 0.5, position = "identity", binwidth = 5, color = "black") +
  scale_fill_manual(name = "Agriculture Type", values = c("cyan1", "indianred1"), breaks = c("Riego", "Temporal"), labels = c("Irrigation", "Temporal"))+
  geom_density(aes(group = AGType, color = AGType, y=6.75 * ..count..), adjust = 2, size=1, alpha=0.5)+
  scale_color_manual(name = "Agriculture Type",values = c("cyan2", "firebrick1"), breaks = c("Riego", "Temporal"), labels = c("Irrigation", "Temporal"))+
  labs(x ="C.V. Maize Yield", y = "Count")+
    theme_bw()+
    scale_x_continuous(limits= c(0,160), breaks=seq(0,160,10)) +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="black", size=11), 
          axis.text.y = element_text(color="black", size=11), 
          axis.title.x = element_text(color="black", size=14, face="bold"),
          axis.title.y = element_text(color="black", size=14, face="bold"),
          legend.justification=c(0,1), legend.position=c(0.5,0.85), 
          legend.title=element_blank(),
          legend.box.background = element_rect(colour = "black"),
          legend.text = element_text(colour="black", size = 12),
          legend.background = element_rect(fill="white",size=0.5, linetype="solid", color ="black"))

df = SIAP_6 %>% select(EstadoMunicipio, cvYield_Total) %>% rename(cvYield = cvYield_Total) %>% mutate(Series = "Municipal Average")
df2 = SIAP_5 %>% select(EstadoMunicipio, cvYield) %>% mutate(Series = "Both Irrigation and Temporal")
df = rbind(df,df2)

h2 = ggplot(df,aes(x = cvYield)) +
  geom_histogram(aes(group = Series, fill = Series),alpha = 0.5, position = "identity", binwidth = 5, color = "black") +
  scale_fill_manual(name = "Agriculture Type", values = c("grey75", "greenyellow"), breaks = c("Municipal Average", "Both Irrigation and Temporal"), labels = c("Total", "All"))+
  geom_density(aes(group = Series, color = Series, y=6.75 * ..count..), adjust = 2, size=1, alpha=0.5)+
  scale_color_manual(name = "Agriculture Type",values = c("black", "green"), breaks = c("Municipal Average", "Both Irrigation and Temporal"), labels = c("Total", "All"))+
  labs(x ="C.V. Maize Yield", y = "Count")+
    theme_bw()+
    scale_x_continuous(limits= c(0,160), breaks=seq(0,160,10)) +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="black", size=11), 
          axis.text.y = element_text(color="black", size=11), 
          axis.title.x = element_text(color="black", size=14, face="bold"),
          axis.title.y = element_text(color="black", size=14, face="bold"),
          legend.justification=c(0,1), legend.position=c(0.5,0.85), 
          legend.title=element_blank(),
          legend.box.background = element_rect(colour = "black"),
          legend.text = element_text(colour="black", size = 12),
          legend.background = element_rect(fill="white",size=0.5, linetype="solid", color ="black"))

ggp2 = plot_grid(h1, h2, labels = c('A', 'B'), label_size = 24)


#save figure
ggsave("Hists_SIAP_AGType_cvYield.png", plot = ggp2, device = "png", path = wd$figs, scale = 1, width = 8, height = 4.5,   units = "in",  dpi = 1500)

cvIrrig = SIAP_5 %>% filter(AGType == "Riego") %>% pull(cvYield)
cvTemp = SIAP_5 %>% filter(AGType == "Temporal") %>% pull(cvYield)
cvTotal = df %>% filter(Series == "Municipal Average") %>% pull(cvYield)
cvAll = df %>% filter(Series == "Both Irrigation and Temporal") %>% pull(cvYield)

gamma_test(cvIrrig)
gamma_test(cvTemp)
gamma_test(cvTotal)
gamma_test(cvAll)

rm(ggp2, h1, h2, df, df2, cvIrrig, cvTemp, cvTotal, cvAll)

# import figure for display
knitr::include_graphics(paste0(wd$figs,"Hists_SIAP_AGType_cvYield.png"), FALSE)
```


## Tables

descriptive stats for SIAP 4, 5 rescale vs actual data

```{r}

write.csv(SIAP_2, paste0(wd$data_r,"SIAP_2_RescaleTests.csv"))

Y = SIAP_2$Yield
Y_t = SIAP_2 %>% filter(AGType == "Temporal") %>% pull(Yield)
Y_i = SIAP_2 %>% filter(AGType == "Riego") %>% pull(Yield)

tab = CreateTableOne(vars="Yield", strata="AGType", data=SIAP_2)



fy <- function(x, l, l2 = 0){((x + l2)^l - 1)/l}



hist(Y, breaks=20)
hist((Y^0.89), breaks=25)
hist(log(Y), breaks=20)
hist(1/(Y^0.05), breaks=20)
hist(Y_i, breaks=20)
hist(Y_i^0.95, breaks=20)
#You must compute a linear model with the lm function and pass it to the boxcox function as shown below in order to determine the appropriate “lambda”

```

## Maps

--Rescaled Avg Yield
--Rescaled CV Avg Yield

var = c("sdYield_Total", "minYield_Total", "maxYield_Total", "medYield_Total", "cvYield_Total", "sdYield_Temp", "minYield_Temp", "maxYield_Temp", "medYield_Temp", "cvYield_Temp", "sdYield_Irrig", "minYield_Irrig", "maxYield_Irrig", "medYield_Irrig", "cvYield_Irrig")
tit = "Central Mexico Study Region - SIAP 2003-2021"

subtit = c("Z-Score St.Dev. Total Maize Yield", "Z-Score Minimum Total Maize Yield", "Z-Score Maximum Total Maize Yield", "Z-Score Median Total Maize Yield", "Z-Score C.V. Total Maize Yield", "Z-Score St.Dev. Temporal Maize Yield", "Z-Score Minimum Temporal Maize Yield", "Z-Score Maximum Temporal Maize Yield", "Z-Score Median Temporal Maize Yield", "Z-Score C.V. Temporal Maize Yield", "Z-Score St.Dev. Irrigation Maize Yield", "Z-Score Minimum Irrigation Maize Yield", "Z-Score Maximum Irrigation Maize Yield", "Z-Score Median Irrigation Maize Yield", "Z-Score C.V. Irrigation Maize Yield")
```{r, label='Basemaps', message=FALSE,warning=FALSE}
#geo <- st_geometry(MunicipioYields_Z)
#nb <- st_contiguity(geo)
MunicipioYields_Z_rs <- MunicipioYields_Z_rs %>% 
  mutate(nb = sfdep::st_contiguity(geom),
         wt = sfdep::st_weights(nb, allow_zero = TRUE))

nb <- MunicipioYields_Z_rs$nb
wt <- MunicipioYields_Z_rs$wt

Hillshade <- read_stars(paste0(wd$data_r, "HillshadeCMex.tif"))
Estados <- st_read(paste0(wd$data_r, "StatesPoly.gpkg"))
Estados2 = Estados %>% mutate(my_nudge_x = case_when(
    NOM_ENT == "Mexico" ~ 4000,
    NOM_ENT == "DF" ~ 0,
    NOM_ENT == "Hidalgo" ~ -7000,
    NOM_ENT == "Morelos" ~ 0,
    NOM_ENT == "Puebla" ~ -50000,
    NOM_ENT == "Tlaxcala" ~ 0,
    NOM_ENT == "" ~ 0),
    my_nudge_y = case_when(
    NOM_ENT == "Mexico" ~ 1500,
    NOM_ENT == "DF" ~ 0,
    NOM_ENT == "Hidalgo" ~ 0,
    NOM_ENT == "Morelos" ~ 0,
    NOM_ENT == "Puebla" ~ -65000,
    NOM_ENT == "Tlaxcala" ~ 0,
    NOM_ENT == "" ~ 0))



myPalette <- colorRampPalette(c("red4", "red4", "red4", "red4", "red", "orange", "yellow", "greenyellow", "green", "green4", "green4","green4", "green4"))
#myPalette <- c("red4", "red4", "red", "orange", "yellow", "greenyellow", "green", "green4", "green4")
myBreaks = c(-6, -4, -2, -1,  0, 1, 2, 4, 6)
myLimits = c(-6, 6)
myLegendTitle = "Z-Score\nMaize\nYield" #"Maize\nYield\n(kg/ha)"

```


```{r, label='Average Yields Over Time Maps', message=FALSE, warning=FALSE}

map_list = list()

var = c("Y_1960_Total", "Y_1960_E", "Y_1960_L", "Y_1960_S", "Y_1960_Max","Y_1970_Total", "Y_1970_E", "Y_1970_L", "Y_1970_S", "Y_1970_Max", "Y_1991_Total", "Y_AGC2007_Total", "AvgYield_Total", "AvgYield_Irrig", "AvgYield_Temp")
tit = c("Central Mexico Study Region - 1960 Agricultural Census", "Central Mexico Study Region - 1960 Agricultural Census", "Central Mexico Study Region - 1960 Agricultural Census", "Central Mexico Study Region - 1960 Agricultural Census", "Central Mexico Study Region - 1960 Agricultural Census", "Central Mexico Study Region - 1970 Agricultural Census", "Central Mexico Study Region - 1970 Agricultural Census", "Central Mexico Study Region - 1970 Agricultural Census", "Central Mexico Study Region - 1970 Agricultural Census", "Central Mexico Study Region - 1970 Agricultural Census", "Central Mexico Study Region - 1991 Agricultural Census", "Central Mexico Study Region - 2007 Agricultural Census", "Central Mexico Study Region - SIAP 2003-2021", "Central Mexico Study Region - SIAP 2003-2021", "Central Mexico Study Region - SIAP 2003-2021")
subtit = c("Z-Score Average Overall Maize Yield", "Z-Score Average Ejido Maize Yield", "Z-Score Average Large Farm Maize Yield", "Z-Score Average Small Farm Maize Yield", "Z-Score Max Average Maize Yield","Z-Score Average Overall Maize Yield", "Z-Score Average Ejido Maize Yield", "Z-Score Average Large Farm Maize Yield", "Z-Score Average Small Farm Maize Yield", "Z-Score Max Average Maize Yield", "Z-Score Average Overall Maize Yield", "Z-Score Average Overall Maize Yield", "Z-Score Average Overall Maize Yield", "Z-Score Average Irrigation Maize Yield", "Z-Score Average Temporal Maize Yield")
name=c("Y_1960_Total", "Y_1960_E", "Y_1960_L", "Y_1960_S", "Y_1960_Max", "Y_1970_Total", "Y_1970_E", "Y_1970_L", "Y_1970_S", "Y_1970_Max","Y_1991_Total", "Y_AGC2007_Total", "SIAP_AvgYield_Total", "SIAP_AvgYield_Irrig", "SIAP_AvgYield_Temp")


for (i in 1:length(var)) {
  v = paste0(var[i])
  t = paste0(tit[i])
  s = paste0(subtit[i])
  val = MunicipioYields_Z[[var[i]]]
  map_list[[i]] <- CMex_AG_Map(stars_hillshade = Hillshade, sf1 = MunicipioYields_Z, sf1_aes_string = T, sf1_geom = "geom",
                             sf1_fill = v, sf1_fill_palette = myPalette, sf1_fill_palette_n = 11,
                             sf1_fill_legend_title = myLegendTitle, sf1_fill_legend_limits = myLimits,
                             sf1_fill_legend_breaks = myBreaks, sf2 = Estados, sf2_geom = geom,
                             sf2_label_column = NOM_ENT, sf2_label_nudge_x = Estados2$my_nudge_x, 
                             sf2_label_nudge_y = Estados2$my_nudge_y, mytitle = t, mysubtitle = s, global_moran = T,
                             moran_nb = nb, moran_wt = wt, moran_val = val, moran_box = c(572000, 626450, 2195909, 2252689))
} 
  
names(map_list) <- name

for (i in 1:length(name)) {
  n = paste0(name,".png")[i]
  ggsave(n, plot = map_list[[i]], device = "png", path = wd$figs, scale = 1, width = 6.85, height = 5.257, units = "in",  dpi = 1500)
}

paths <- paste0(wd$figs,paste0("Maps/", name, ".png"))

knitr::include_graphics(paths, FALSE)

rm(nb, wt, paths, names, n, map_list, v, t, s, val, var, tit, subtit, name, myLegendTitle, myPalette, myBreaks, myLimits, Estados2, Estados, Hillshade, MunicipioYields_Z_rs)
```


# Construct RF Training Dataset


## Environmental Raster Data


### Load Environmental Predictor Data from Previous Scripts

```{r, label='Import Data', message=FALSE,warning=FALSE}

#Data2000s_poly <- st_read(paste0(wd$data_p, "Data2000s_poly.gpkg"))
#Data2000s_poly_rs <- st_read(paste0(wd$data_p, "Data2000s_poly_rescale.gpkg"))

Topo <- rast(paste0(wd$data_p, "Topo_r_resampled.tif"))

Soil <- rast(paste0(wd$data_p, "Soil_r_resampled.tif"))

Clim <- rast(paste0(wd$data_p, "Clim_r_resampled.tif"))
#writeRaster(pdsi_ts, filename = paste0(wd$data_p, "pdsi_ts_100m.tif"), overwrite=TRUE)
#writeRaster(pdsi_ts, filename = paste0(wd$data_p, "pdsi_ts_latlon.tif"), overwrite=TRUE)
```


### Subset Raster Data

```{r, label='Subset Environmental Data Rasters', message=FALSE,warning=FALSE}

Soil_sub <- subset(Soil, c("BDRICM", "BDRLOG", "BDTICM", "AWCtS", "AWCtS_2m", "BD", 
                               "S", "Z", "C", "CF", "SOC", "CEC","OCD", "N", "SOCS"))

Topo_sub <- subset(Topo, c("DEM", "Slope","Accum", "TRI", "TWI", "STI", "SPI", 
                                     "curv_min", "curv_max", "curv_mean", "DistStreams", 
                                     "DistStreams2", "ElevAboveStreams", "ElevAboveStreams2",
                                     "elev_watershed", "FloodOrder_Rel"))

pr_spring = app(subset(Clim, c("pr_04", "pr_05")), sum)
pr_summer = app(subset(Clim, c("pr_06", "pr_07","pr_08")), sum)
pr_fall = app(subset(Clim, c("pr_09", "pr_10")), sum)

tas_spring = app(subset(Clim, c("tas_04", "tas_05")), mean)
tas_summer = app(subset(Clim, c("tas_06", "tas_07","tas_08")), mean)
tas_fall = app(subset(Clim, c("tas_09", "tas_10")), mean)

tasmin_spring = app(subset(Clim, c("tasmin_04", "tasmin_05")), mean)
tasmin_summer = app(subset(Clim, c("tasmin_06", "tasmin_07","tasmin_08")), mean)
tasmin_fall = app(subset(Clim, c("tasmin_09", "tasmin_10")), mean)

tasmax_spring = app(subset(Clim, c("tasmax_04", "tasmax_05")), mean)
tasmax_summer = app(subset(Clim, c("tasmax_06", "tasmax_07","tasmax_08")), mean)
tasmax_fall = app(subset(Clim, c("tasmax_09", "tasmax_10")), mean)

pet_spring = app(subset(Clim, c("pet_04", "pet_05")), mean)
pet_summer = app(subset(Clim, c("pet_06", "pet_07","pet_08")), mean)
pet_fall = app(subset(Clim, c("pet_09", "pet_10")), mean)

cmi_spring = app(subset(Clim, c("cmi_04", "cmi_05")), mean)
cmi_summer = app(subset(Clim, c("cmi_06", "cmi_07","cmi_08")), mean)
cmi_fall = app(subset(Clim, c("cmi_09", "cmi_10")), mean)

clt_spring = app(subset(Clim, c("clt_04", "clt_05")), mean)
clt_summer = app(subset(Clim, c("clt_06", "clt_07","clt_08")), mean)
clt_fall = app(subset(Clim, c("clt_09", "clt_10")), mean)

rsds_spring = app(subset(Clim, c("rsds_04", "rsds_05")), mean)
rsds_summer = app(subset(Clim, c("rsds_06", "rsds_07","rsds_08")), mean)
rsds_fall = app(subset(Clim, c("rsds_09", "rsds_10")), mean)

Clim_sub <- subset(Clim, c("npp", "swb", "gdd10"))

Clim_sub <- c(Clim_sub, pr_spring, pr_summer, pr_fall, tas_spring, tas_summer, tas_fall, tasmin_spring, tasmin_summer, tasmin_fall, tasmax_spring, tasmax_summer, tasmax_fall, pet_spring, pet_summer, pet_fall, cmi_spring, cmi_summer, cmi_fall, clt_spring, clt_summer, clt_fall, rsds_spring, rsds_summer, rsds_fall)

names(Clim_sub) <- c("npp", "swb", "gdd10", "pr_spring", "pr_summer", "pr_fall", "tas_spring", "tas_summer", "tas_fall", "tasmin_spring", "tasmin_summer", "tasmin_fall", "tasmax_spring", "tasmax_summer", "tasmax_fall", "pet_spring", "pet_summer", "pet_fall", "cmi_spring", "cmi_summer", "cmi_fall", "clt_spring", "clt_summer", "clt_fall", "rsds_spring", "rsds_summer", "rsds_fall")

writeRaster(Clim_sub, filename = paste0(wd$data_p, "Clim_sub_RF.tif"), overwrite=TRUE)

rm(Clim_sub, pr_spring, pr_summer, pr_fall, tas_spring, tas_summer, tas_fall, tasmin_spring, tasmin_summer, tasmin_fall, tasmax_spring, tasmax_summer, tasmax_fall, pet_spring, pet_summer, pet_fall, cmi_spring, cmi_summer, cmi_fall, clt_spring, clt_summer, clt_fall, rsds_spring, rsds_summer, rsds_fall, Clim, Soil)

Clim_sub <- rast(paste0(wd$data_p, "Clim_sub_RF.tif"))

Env_sub = c(Topo_sub, Soil_sub, Clim_sub)

writeRaster(Env_sub, filename = paste0(wd$data_p, "Env_sub_RF.tif"), overwrite=TRUE)

Env_sub <- rast(paste0(wd$data_p, "Env_sub_RF.tif"))

rm(Clim_sub, Topo_sub, Soil_sub)
```



### High Elevations


```{r, label='High Elevations', message=FALSE,warning=FALSE}

vv = as.data.frame(Topo[[1]])
vv = vv %>% mutate(DEM = ifelse(DEM >= 3100, 0, 1))
vv = as.numeric(floor((1-sum(vv$DEM)/nrow(vv))*460))

high_elev <- st_read(paste0(wd$data_r, "HighElev.gpkg"))
high_elev <- high_elev %>% sample_n(vv)

qqq = Data2000s_poly_rs 

qqq = qqq[1:vv,]

new_geometry <- st_geometry(high_elev)

qqq <- st_set_geometry(qqq, new_geometry)
qqq[,c(1:218)] <- NA

high_elev <- qqq %>% mutate(
  EstadoMunicipio = "High Elevation",
  Estado = "High Elevation",
  Municipio = "High Elevation",
  AGType = "Temporal",
  AvgYield = 0,
  cvYield = NA,
  LU_Total_DensArable = 0,
  AG_Workers_DensArable = 0,
  PrimaryEmploy_DensArable = 0,
  TotalLabor_DensArable = 0,
  Pop_DensArable = 0,
  PopRural_DensArable = 0,
  
  Fertilizer = 0.7752172)

Data2000s_poly_rs = rbind(Data2000s_poly_rs, high_elev)

rm(qqq, new_geometry, high_elev)

```


### Extract Raster Values

```{r, label='Extract Raster Values', message=FALSE,warning=FALSE}


env_vals <- exact_extract(x = Env_sub, y = Data2000s_poly_rs, fun = "mean", 
                           max_cells_in_memory = 8e+08, stack_apply=T, 
                           append_cols = c("EstadoMunicipio","Estado", "Municipio", "AGType"))


#topo_vals <- exact_extract(x = Topo_sub, y = Data2000s_poly_rs, fun = "mean", 
#                           max_cells_in_memory = 8e+08, stack_apply=T, 
#                           append_cols = c("EstadoMunicipio","Estado", "Municipio", "AGType"))

#soil_vals <- exact_extract(x = Soil_sub, y = Data2000s_poly_rs, fun = "mean", 
#                           max_cells_in_memory = 8e+08, stack_apply=T, 
#                           append_cols = c("EstadoMunicipio","Estado", "Municipio", "AGType"))

#clim_vals <- exact_extract(x = Clim_sub, y = Data2000s_poly_rs, fun = "mean", 
#                           max_cells_in_memory = 8e+08, stack_apply=T, 
#                           append_cols = c("EstadoMunicipio","Estado", "Municipio", "AGType"))

#env_vals <- topo_vals %>% left_join(soil_vals, by = c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>% 
#                          left_join(clim_vals, by = c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>% 
#                          mutate(AGType = as.factor(AGType))
  

#env_vals = merge(topo_vals, soil_vals, all = F, sort = F)

#rm(topo_vals, soil_vals, clim_vals)

```


## Agricultural Data



SIAP Maize cultivated area stats

Data2000s_poly_rs <- Data2000s_poly_rs %>% mutate(
  
  # irrigated maize % of total maize cultivation
  AvgPctMaizeArea_Irrig = AvgArea_Irrig_Maize / AvgArea_Total_Maize,

  # temporal maize % of total maize cultivation 
  AvgPctMaizeArea_Temp = AvgArea_Temp_Maize / AvgArea_Total_Maize,

  # irrigated % of total cultivation 
  AvgPctArea_Irrig = AvgArea_Irrig / AvgArea_Total,#BY MUNICIPIO (both AGTypes have same value!)

  # temporal % of total cultivation 
  AvgPctArea_Temp = AvgArea_Temp / AvgArea_Total)

  #AvgPctArea_Maize_Total # == Total maize (all AGTypes) % of total cultivated area
  #AvgPctArea_Maize_Crops_Total # == Total maize (all AGTypes) % of total crop cultivated area (excl. fodder)

  #AvgPctArea_Maize # == Row Avg Area % of total area
  #AvgPctArea_Maize_Crops # == Row Avg Area % of total crop area (excl. fodder)
  
  #BY MUNICIPIO (both AGTypes have same value!)
  #AvgPctArea_Maize_Temp # == Temporal Maize Avg Area % of total irrigated area
  #AvgPctArea_Maize_Crops_Temp # == Temporal Maize Avg Area % of total crop irrigated area (excl. fodder)
  #AvgPctArea_Maize_Irrig # == Irrigated Maize Avg Area % of total irrigated area
  #AvgPctArea_Maize_Crops_Irrig # == Irrigated Maize Avg Area % of total crop irrigated area (excl. fodder)

hist(Train_df$PopRuralMz_perMzHa, breaks=25)
hist(Train_df$PrimaryMz_perMzHa, breaks=25)
hist(Train_df$AGWorkersMz_perMzHa, breaks=25)
hist(Train_df$TotalLaborMz_perMzHa, breaks=25)
hist(Train_df$LUTotalMz_perMzHa, breaks=25)

hist(Train_df$ContractLaboTotMz_perMzHa, breaks=25)
hist(Train_df$ContractLaborFullMz_perMzHa, breaks=25)
hist(Train_df$ContractLaboPartMz_perMzHa, breaks=25)
hist(Train_df$FamLaborMz_perMzHa, breaks=25)
hist(Train_df$MechanizEquipMz_perMzHa, breaks=25)
hist(Train_df$DraftAnimalsMz_perMzHa, breaks=25)
hist(Train_df$PopRuralMz_perMzHa, breaks=25)
hist(Train_df$TractorsMz_perMzHa, breaks=25)

Train_df = st_drop_geometry(Data2000s_poly_rs) %>% select(
  
  EstadoMunicipio, Estado, Municipio, AvgYield, cvYield, AGType, n, n_Total,  Pop_Urban, Pop_Rural, UrbRatio, Arable_ha, AG_ha, AGPasture_ha, Primary, AG_Workers, LU_Total, TotalLabor, 
  AvgArea_Maize, sdArea_Maize, cvArea_Maize, AvgArea_Total, sdArea_Total, cvArea_Total, AvgArea_Total_Maize, AvgPctArea_Maize, AvgPctArea_Maize_Crops, AvgPctArea_ofTotal, AvgPctArea_ofAGPasture,
  PopRuralMz_perMzHa,  PrimaryMz_perMzHa,  AGWorkersMz_perMzHa,  TotalLaborMz_perMzHa,  LUTotalMz_perMzHa,
  ContractLaboTotMz_perMzHa,  ContractLaborFullMz_perMzHa,  ContractLaboPartMz_perMzHa,  FamLaborMz_perMzHa,
  MechanizEquipMz_perMzHa,  DraftAnimalsMz_perMzHa,  TractorsMz_perMzHa
  )
Train_df$Avgrat = Train_df$AvgArea_Maize / Train_df$AvgArea_Total
Train_df$SDrat = Train_df$sdArea_Maize / Train_df$sdArea_Total

### Select Variables

```{r}
y = env_vals %>% select(-Estado, -Municipio, -mean.AWCtS, -EstadoMunicipio, -AGType)

Train_df = st_drop_geometry(Pred_Poly_ModLU) %>% select(
  
  EstadoMunicipio, Estado, Municipio, AvgYield, cvYield, AGType, 
  
  #PopDens, Pop_Urban, Pop_Rural, 
  #PopDensRural, UrbRatio,
  
  #Pct_Primary, Pct_AG_Workers, 
  
  #Pct_Rest_ha, Pct_Fallow_ha, 
  
  #Pct_Tract_Mechaniz_pu, Pct_Tract_Animal_pu, Pct_Tract_Manual_pu, 
  
 # Pct_Herbicides_ha, #Pct_FertilChem_ha, Pct_FertilManure_ha, Pct_ImprovSeed_ha, Pct_Insecticides_ha, Pct_ControlledBurn_ha, 
  
  Fertilizer, #Techniques, 
  
  #IrrigPU_EarthenCanals, IrrigPU_CoatedCanals, IrrigPU_CanalsTotal, IrrigPU_Modern, IrrigPU_Other, IrrigPUWater_River, IrrigPUWater_Spring, IrrigPUWater_Dam, IrrigPUWater_Modern, IrrigPUWater_Other,
  
  #PopRuralMz_perMzHa,  PrimaryMz_perMzHa,  AGWorkersMz_perMzHa,  TotalLaborMz_perMzHa,  LUTotalMz_perMzHa,
  #ContractLaboTotMz_perMzHa,  ContractLaborFullMz_perMzHa,  ContractLaboPartMz_perMzHa,  FamLaborMz_perMzHa,
  #MechanizEquipMz_perMzHa,  DraftAnimalsMz_perMzHa,  TractorsMz_perMzHa,
  
   AvgPctArea_ofTotal, AvgPctArea_ofArable, #AvgArea_Maize,AvgPctMaizeArea_Irrig, AvgPctMaizeArea_Temp, AvgPctArea_Irrig, AvgPctArea_Temp,
  
  LU_Total_DensArable, AG_Workers_DensArable, PrimaryEmploy_DensArable, TotalLabor_DensArable, Pop_DensArable, PopRural_DensArable, #PctMun_Arable
  #MechanizEquip_DensArable, DraftAnimals_DensArable, PctMun_Settlement, AvgMunSettlementDens
  )
Train_df = cbind(Train_df, y)
rm(y)
```
Fertilizer
AvgPctArea_ofTotal
Pop_DensArable
AG_Workers_DensArable
TotalLabor_DensArable


### Remove Cases

Teotihuacan, Mexico
Otumba, Mexico
Tezoyuca, Mexico
San Martin de las Piramides, Mexico
Acolman, Mexico


```{r}

#Remove Irrigation
E_TLAXCALA = c("Emiliano Zapata, Tlaxcala", "Lazaro Cardenas, Tlaxcala", "Terrenate, Tlaxcala", "Xaloztoc, Tlaxcala", "Tzompantepec, Tlaxcala", "Tocatlan, Tlaxcala", "Huamantla, Tlaxcala", "Altzayanca, Tlaxcala", "Cuapiaxtla, Tlaxcala", "El Carmen Tequexquitla, Tlaxcala", "Zitlaltepec de Trinidad Sanchez Santos, Tlaxcala", "Ixtenco, Tlaxcala", "Nopalucan, Puebla", "Rafael Lara Grajales, Puebla", "Soltepec, Puebla", "Mazapiltepec de Juarez, Puebla","San Jose Chiapa, Puebla")

Remove_Irrigation = c("Chicoloapan, Mexico", "Chimalhuacan, Mexico", "Atenco, Mexico", "Chiconcuac, Mexico", "Ecatepec de Morelos, Mexico", "Coacalco de Berriozabal, Mexico", "Papalotla, Mexico")

#RESCALE Irrigation
S_HIDALGO = c("Mixquiahuala de Juarez, Hidalgo", "Tezontepec de Aldama, Hidalgo", "Tepetitlan, Hidalgo", "Tula de Allende, Hidalgo", "Tepeji del Rio de Ocampo, Hidalgo", "Tlaxcoapan, Hidalgo", "Tlahuelilpan, Hidalgo", "Atitalaquia, Hidalgo", "Atotonilco de Tula, Hidalgo", "Francisco I. Madero, Hidalgo", "Tetepango, Hidalgo", "Ajacuba, Hidalgo", "Tetepango, Hidalgo")

Remove_Temporal = c("Milpa Alta, Distrito Federal", "Tlalpan, Distrito Federal", "Xochimilco, Distrito Federal", "Tlahuac, Distrito Federal", "La Magdalena Contreras, Distrito Federal", "Alvaro Obregon, Distrito Federal", "Cuajimalpa de Morelos, Distrito Federal", "Jilotzingo, Mexico", "Naucalpan de Juarez, Mexico", "Atizapan de Zaragoza, Mexico", "Tlalnepantla de Baz, Mexico", "Coacalco de Berriozabal, Mexico", "Jaltenco, Mexico", "Coyotepec, Mexico", "La Paz, Mexico", "Chimalhuacan, Mexico", "Domingo Arenas, Puebla", "San Felipe Teotlalcingo, Puebla", "Puebla, Puebla") #"Chicoloapan, Mexico", "Ixtapaluca, Mexico"



Train_df = Train_df %>% 
  
  filter(!(EstadoMunicipio %in% c("Ixtapaluca, Mexico", "Axapusco, Mexico") & AGType %in% "Riego")) %>% 
  
  filter(!(EstadoMunicipio %in% S_HIDALGO)) %>% 
  
  filter(!(EstadoMunicipio %in% E_TLAXCALA & AGType %in% "Riego")) %>% 
  
  filter(!(EstadoMunicipio %in% Remove_Irrigation & AGType %in% "Riego")) %>% 
  
  filter(!(EstadoMunicipio %in% Remove_Temporal & AGType %in% "Temporal")) %>% 
  
  ###left_join(y, by = c("EstadoMunicipio", "AGType")) %>% 
  
  mutate(AGType = factor(AGType, levels = c("Temporal", "Riego")))

#Train_df[, c("IrrigPU_EarthenCanals", "IrrigPU_CoatedCanals", "IrrigPU_CanalsTotal", "IrrigPU_Modern", "IrrigPU_Other", "IrrigPUWater_River", "IrrigPUWater_Spring", "IrrigPUWater_Dam", "IrrigPUWater_Modern", "IrrigPUWater_Other")][is.na(Train_df[, c("IrrigPU_EarthenCanals", "IrrigPU_CoatedCanals", "IrrigPU_CanalsTotal", "IrrigPU_Modern", "IrrigPU_Other", "IrrigPUWater_River", "IrrigPUWater_Spring", "IrrigPUWater_Dam", "IrrigPUWater_Modern", "IrrigPUWater_Other")])] <- 0

#Train_df_Temp_AvgYield = Train_df %>% filter(AGType == "Temporal") %>% select(-AGType, -cvYield, -IrrigPU_EarthenCanals, -IrrigPU_CoatedCanals, -IrrigPU_CanalsTotal, -IrrigPU_Modern, -IrrigPU_Other, -IrrigPUWater_River, -IrrigPUWater_Spring, -IrrigPUWater_Dam, -IrrigPUWater_Modern, -IrrigPUWater_Other, -AvgPctArea_Irrig, -AvgPctMaizeArea_Irrig) %>% filter(complete.cases(.))

#Train_df_Irrig_AvgYield = Train_df %>% filter(AGType == "Riego") %>% select(-AGType, -cvYield, -Pct_Rest_ha, -Pct_Fallow_ha, -Pct_ControlledBurn_ha, -AvgPctArea_Temp, -AvgPctMaizeArea_Temp) %>% filter(complete.cases(.))

Train_df_Both_AvgYield = Train_df %>% select( -cvYield) #%>% filter(complete.cases(.))-AvgPctArea_Temp,, -AvgPctMaizeArea_Temp

#Train_df_Temp_cvYield = Train_df %>% filter(AGType == "Temporal") %>% select(-AGType, -AvgYield, -IrrigPU_EarthenCanals, -IrrigPU_CoatedCanals, -IrrigPU_CanalsTotal, -IrrigPU_Modern, -IrrigPU_Other, -IrrigPUWater_River, -IrrigPUWater_Spring, -IrrigPUWater_Dam, -IrrigPUWater_Modern, -IrrigPUWater_Other, -AvgPctArea_Irrig, -AvgPctMaizeArea_Irrig) %>% filter(complete.cases(.))

#Train_df_Irrig_cvYield = Train_df %>% filter(AGType == "Riego") %>% select(-AGType, -AvgYield, -Pct_Rest_ha, -Pct_Fallow_ha, -Pct_ControlledBurn_ha, -AvgPctArea_Temp, -AvgPctMaizeArea_Temp) %>% filter(complete.cases(.))

Train_df_Both_cvYield = Train_df %>% select(-AvgPctArea_Temp, -AvgYield, -AvgPctMaizeArea_Temp) %>% filter(complete.cases(.))




```







```{r}
Train_df = st_drop_geometry(Pred_Poly_ModLU) %>% select(
  
  EstadoMunicipio, Estado, Municipio, AvgYield, cvYield, AGType, 
  
  PopDens, Pop_Urban, Pop_Rural, PopDensRural, UrbRatio,
  
  Pct_Primary, Pct_AG_Workers, 
  
  Pct_Tract_Mechaniz_pu, Pct_Tract_Animal_pu, Pct_Tract_Manual_pu, 
  
  Pct_FertilChem_ha, Pct_FertilManure_ha, Pct_ImprovSeed_ha, Pct_Herbicides_ha, Pct_Insecticides_ha, Pct_ControlledBurn_ha, 
  
  Techniques, Fertilizer,
  
  IrrigPU_EarthenCanals, IrrigPU_CoatedCanals, IrrigPU_CanalsTotal, IrrigPU_Modern, IrrigPU_Other, IrrigPUWater_River, IrrigPUWater_Spring, IrrigPUWater_Dam, IrrigPUWater_Modern, IrrigPUWater_Other,
  
  PopRuralMz_perMzHa,  PrimaryMz_perMzHa,  AGWorkersMz_perMzHa,  TotalLaborMz_perMzHa,  LUTotalMz_perMzHa,
  ContractLaboTotMz_perMzHa,  ContractLaborFullMz_perMzHa,  ContractLaboPartMz_perMzHa,  FamLaborMz_perMzHa,
  MechanizEquipMz_perMzHa,  DraftAnimalsMz_perMzHa,  TractorsMz_perMzHa,
  
  AvgPctArea_Maize, AvgPctArea_Maize_Crops, AvgPctArea_Maize_Total, AvgPctMaizeArea_Irrig, AvgPctMaizeArea_Temp, AvgPctArea_Irrig, AvgPctArea_Temp,
  
  LU_Total_DensArable, AG_Workers_DensArable, MechanizEquip_DensArable, DraftAnimals_DensArable, PrimaryEmploy_DensArable, TotalLabor_DensArable, Pop_DensArable, PopRural_DensArable, PctMun_Settlement, AvgMunSettlementDens, PctMun_Arable
  )
```








# Construct RF Prediction Dataset

--Predictions also for polygon values

--Rasterize AG data (popdens, labor, etc)
--Arable Area == MASK
--AGType Raster
--Raster Variables used to dataframe

```{r}




Municipios2000s <- st_read(paste0(wd$data_p, "Municipios2000s_Data.gpkg")) %>% select(EstadoMunicipio, Estado, Municipio)

Pred_Poly_ModMun_Temp = st_drop_geometry(Pred_Poly_ModLU) %>% filter(AGType == "Temporal") 
Pred_Poly_ModMun_Temp = Municipios2000s %>% left_join(Pred_Poly_ModMun_Temp, by = c("EstadoMunicipio", "Estado", "Municipio"))

Pred_Poly_ModMun_Irrig = st_drop_geometry(Pred_Poly_ModLU) %>% filter(AGType == "Riego") 
Pred_Poly_ModMun_Irrig = Municipios2000s %>% left_join(Pred_Poly_ModMun_Irrig, by = c("EstadoMunicipio", "Estado", "Municipio"))

```
Riego
AvgPctArea_ofTotal
Axapusco == Otumba, Mexico == 0.006730203
Milpa Alta, Tlahuac, Xochimilco, Ixtapaluca == Chalco, Mexico == 0.012594759
Chalco, Mexico



yyy = st_drop_geometry(Data2000s_poly_rs) %>% filter(EstadoMunicipio %in% c("Chalco, Mexico", "Otumba, Mexico")) %>% select(EstadoMunicipio, AGType, AvgPctArea_ofTotal)



### Rasterize Agricultural Data



Fertilizer
AvgPctArea_ofTotal

Pop_DensArable
AG_Workers_DensArable

Census2000s <- read.csv(paste0(wd$data_p,"CensusData2000s.csv")) %>% select(-Estado_ID, -Municipio_ID, -X)


```{r}
ArableAreaMask <- rast(paste0(wd$data_p, "ArableArea_100m.tif"))
ArableAreaMask <- as.numeric(ArableAreaMask)
ArableAreaMask <- ifel(ArableAreaMask < 2, 0, 1)
temp <- st_read(paste0(wd$data_r, "LU2000e.gpkg"))
temp = vect(temp)
temp <- terra::rasterize(temp, ArableAreaMask, values = 1, background = 0)
ArableAreaMask = ArableAreaMask + temp
ArableAreaMask <- ifel(ArableAreaMask > 0, 1, NA)
rm(temp)

#AGType_Temp <- ifel(ArableAreaMask > 0, 1, NA)
AGType_Temp <- as.factor(ArableAreaMask)
levels(AGType_Temp) = levels(AGType_Temp)[[1]] %>% select(-ArableArea) %>%
  mutate(AGType_Temp = case_when(
    ID == 1 ~ "Temporal",
    ID == 2 ~ "Riego"))

################################
Fertilizer_Temp <- terra::rasterize(Pred_Poly_ModMun_Temp, Topo[[1]], 
                                    field = "Fertilizer", background = NA)
Fertilizer_Temp = mask(Fertilizer_Temp, ArableAreaMask)

AvgPctArea_ofTotal_Temp <- terra::rasterize(Pred_Poly_ModMun_Temp, Topo[[1]], 
                                            field = "AvgPctArea_ofTotal", background = NA)
AvgPctArea_ofTotal_Temp = mask(AvgPctArea_ofTotal_Temp, ArableAreaMask)

TotalLabor_DensArable_Temp <- terra::rasterize(Pred_Poly_ModMun_Temp, Topo[[1]], 
                                               field = "TotalLabor_DensArable", background = NA)
TotalLabor_DensArable_Temp = mask(TotalLabor_DensArable_Temp, ArableAreaMask)

AG_Workers_DensArable_Temp <- terra::rasterize(Pred_Poly_ModMun_Temp, Topo[[1]], 
                                               field = "AG_Workers_DensArable", background = NA)
AG_Workers_DensArable_Temp = mask(AG_Workers_DensArable_Temp, ArableAreaMask)

Pop_DensArable_Temp <- terra::rasterize(Pred_Poly_ModMun_Temp, Topo[[1]], field = "Pop_DensArable", background = NA)
Pop_DensArable_Temp = mask(Pop_DensArable_Temp, ArableAreaMask)

AGRastsRF_Temp = c(AGType_Temp, Fertilizer_Temp, AvgPctArea_ofTotal_Temp, TotalLabor_DensArable_Temp, AG_Workers_DensArable_Temp, Pop_DensArable_Temp)
names(AGRastsRF_Temp) = c("AGType", "Fertilizer", "AvgPctArea_ofTotal", "TotalLabor_DensArable", "AG_Workers_DensArable", "Pop_DensArable")

rm(AGType_Temp, Fertilizer_Temp, AvgPctArea_ofTotal_Temp, TotalLabor_DensArable_Temp, AG_Workers_DensArable_Temp, Pop_DensArable_Temp)


################################

AGType_Irrig <- ifel(ArableAreaMask > 0, 2, NA)
AGType_Irrig <- as.factor(AGType_Irrig)
levels(AGType_Irrig) = levels(AGType_Irrig)[[1]] %>% rename(AGType = ArableArea) %>%
  mutate(AGType = case_when(
    ID == 1 ~ "Temporal",
    ID == 2 ~ "Riego"))


################################
Fertilizer_Irrig <- terra::rasterize(Pred_Poly_ModMun_Irrig, Topo[[1]], 
                                    field = "Fertilizer", background = NA)
Fertilizer_Irrig = mask(Fertilizer_Irrig, ArableAreaMask)


AvgPctArea_ofTotal_Irrig <- terra::rasterize(Pred_Poly_ModMun_Irrig, Topo[[1]], 
                                            field = "AvgPctArea_ofTotal", background = NA)
AvgPctArea_ofTotal_Irrig = mask(AvgPctArea_ofTotal_Irrig, ArableAreaMask)

TotalLabor_DensArable_Irrig <- terra::rasterize(Pred_Poly_ModMun_Irrig, Topo[[1]], 
                                               field = "TotalLabor_DensArable", background = NA)
TotalLabor_DensArable_Irrig = mask(TotalLabor_DensArable_Irrig, ArableAreaMask)

AG_Workers_DensArable_Irrig <- terra::rasterize(Pred_Poly_ModMun_Irrig, Topo[[1]], 
                                               field = "AG_Workers_DensArable", background = NA)
AG_Workers_DensArable_Irrig = mask(AG_Workers_DensArable_Irrig, ArableAreaMask)

Pop_DensArable_Irrig <- terra::rasterize(Pred_Poly_ModMun_Irrig, Topo[[1]], field = "Pop_DensArable", background = NA)
Pop_DensArable_Irrig = mask(Pop_DensArable_Irrig, ArableAreaMask)

AGRastsRF_Irrig = c(AGType_Irrig, Fertilizer_Irrig, AvgPctArea_ofTotal_Irrig, TotalLabor_DensArable_Irrig, AG_Workers_DensArable_Irrig, Pop_DensArable_Irrig)
names(AGRastsRF_Irrig) = c("AGType", "Fertilizer", "AvgPctArea_ofTotal", "TotalLabor_DensArable", "AG_Workers_DensArable", "Pop_DensArable")
################################

rm(AGType_Irrig, Fertilizer_Irrig, AvgPctArea_ofTotal_Irrig, TotalLabor_DensArable_Irrig, AG_Workers_DensArable_Irrig, Pop_DensArable_Irrig)
```


### Convert Data from Raster Stack to Dataframe 

```{r, label='Convert Data from Raster Stack to Dataframe ', message=FALSE,warning=FALSE}

Env_sub <- mask(Env_sub, ArableAreaMask)

Env_df <- as.data.frame(Env_sub[[1]])
names(Env_df) <- names(Env_sub[[1]])
Env_df <- rownames_to_column(Env_df, var = "Cells")

for (i in 2:nlyr(Env_sub)) {
  
  t = as.data.frame(Env_sub[[i]])
  t <- rownames_to_column(t, var = "Cells")
  names(t) <- c("Cells", names(Env_sub[[i]]))
  Env_df <- Env_df %>% left_join(t, by="Cells")

}

AGRastTemp_df <- as.data.frame(AGRastsRF_Temp[[1]])
names(AGRastTemp_df) <- names(AGRastsRF_Temp[[1]])
AGRastTemp_df <- rownames_to_column(AGRastTemp_df, var = "Cells")

for (i in 2:nlyr(AGRastsRF_Temp)) {
  
  t = as.data.frame(AGRastsRF_Temp[[i]])
  t <- rownames_to_column(t, var = "Cells")
  names(t) <- c("Cells", names(AGRastsRF_Temp[[i]]))
  AGRastTemp_df <- AGRastTemp_df %>% left_join(t, by="Cells")

}

AGRastIrrig_df <- as.data.frame(AGRastsRF_Irrig[[1]])
names(AGRastIrrig_df) <- names(AGRastsRF_Irrig[[1]])
AGRastIrrig_df <- rownames_to_column(AGRastIrrig_df, var = "Cells")

for (i in 2:nlyr(AGRastsRF_Irrig)) {
  
  t = as.data.frame(AGRastsRF_Irrig[[i]])
  t <- rownames_to_column(t, var = "Cells")
  names(t) <- c("Cells", names(AGRastsRF_Irrig[[i]]))
  AGRastIrrig_df <- AGRastIrrig_df %>% left_join(t, by="Cells")

}

writeRaster(AGRastsRF_Temp, filename = paste0(wd$data_p, "AGRastsRF_Temp.tif"), overwrite=TRUE)
writeRaster(AGRastsRF_Irrig, filename = paste0(wd$data_p, "AGRastsRF_Irrig.tif"), overwrite=TRUE)
rm(AGRastsRF_Temp, AGRastsRF_Irrig)

RF_df_Temp = AGRastTemp_df %>% left_join(Env_df, by = "Cells") %>% mutate(AGType = factor(AGType, levels = c("Temporal", "Irrigation")))
RF_df_Irrig = AGRastIrrig_df %>% left_join(Env_df, by = "Cells") %>% mutate(AGType = factor(AGType, levels = c("Temporal", "Irrigation")))

write_csv(RF_df_Temp, paste0(wd$data_p,"YieldRFRast_df_Temp.csv.gz"))
write_csv(RF_df_Irrig, paste0(wd$data_p,"YieldRFRast_df_Irrig.csv.gz"))

#x_df = x_df %>% select(-Streams, -Streams2)
#d = x_df[complete.cases(x_df), ]
#d <- x_df[complete.cases(x_df[, -which(names(x_df) == "AGType")]), ]
rm(Env_df, Municipios2000s, t)

```
RF_df_Temp
RF_df_Irrig
AGType_RF_df <- x_df %>% 
  mutate(AGType = factor(AGType, levels = c("Temporal", "Irrigation")),
         #LandUseArchy = factor(LandUseArchy, levels = c("Unknown", "Wetland", "Settlement", "Water", "Glacial")),
         Geomorphons = factor(Geomorphons, levels = c("Flat", "Summit", "Ridge", "Shoulder", "Spur", "Slope", "Hollow", "Footslope", "Valley", "Depression")),
         WRB = factor(WRB, levels = c("NoData", "Andosols", "Arenosols", "Calcisols", "Cambisols", "Durisols", "Fluvisols", "Gleysols", "Leptosols", "Luvisols", "Phaeozems", "Regosols", "Solonchaks", "Solonetz", "Umbrisols", "Vertisols")))

rm(x_df)

AGType_RF_df %>%
  mutate(part = case_when(
    row_number() <= ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data1",
    row_number() <= 2 * ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data2",
    row_number() <= 3 * ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data3",
    row_number() <= 4 * ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data4",
    TRUE ~ "AGType_RFModel_Data5"
  )) %>%
  group_split(part) %>%
  purrr::walk2(
    .,
    c("AGType_RFModel_Data1", "AGType_RFModel_Data2", "AGType_RFModel_Data3", "AGType_RFModel_Data4", "AGType_RFModel_Data5"),
    ~ write_csv(.x, file = paste0(wd$data_p, .y, ".csv.gz"))
  )

x <- rast(paste0(wd$data_p,"AGType_Raster_Data.tif"))
names(x) = c("AGType", "Geomorphons", "DEM", "Slope", "Accum_fd8", "TRI", "TWI", "STI", "SPI", "curv_min", "curv_max", "curv_mean", "Streams", "Streams2", "DistStreams", "DistStreams2", "ElevAboveStreams", "ElevAboveStreams2", "Valleys", "elev_watershed", "FloodOrder_Rel", "FloodOrder", "FlowDirect_d8_30m", "FlowDirect_inf_30m", "BDRICM", "BDRLOG", "BDTICM", "BD", "S", "Z", "C", "SOC", "CEC", "OCD", "N", "SOCS", "WRB")

l = 1:5
file_paths <- paste0(wd$data_p, "AGType_RFModel_Data", l, ".csv.gz")
AGType_RF_df <- file_paths %>%
  map_dfr(~ read_csv(.x))


### Shortcut Import


```{r, label='Shortcut Import', message=FALSE,warning=FALSE}

RF_df_Temp <- read_csv(paste0(wd$data_p,"YieldRFRast_df_Temp.csv.gz")) %>% 
  mutate(AGType = factor(AGType, levels = c("Temporal", "Irrigation")))

RF_df_Irrig <- read_csv(paste0(wd$data_p,"YieldRFRast_df_Irrig.csv.gz")) %>% 
  mutate(AGType = factor(AGType, levels = c("Temporal", "Irrigation")))

AGRastsRF_Temp <- rast(paste0(wd$data_p, "AGRastsRF_Temp.tif"))

AGRastsRF_Irrig <- rast(paste0(wd$data_p, "AGRastsRF_Irrig.tif"))

```






# Random Forest Models

## Average Yield

### Boruta Variable Selection

Train_df_Temp_AvgYield
Train_df_Irrig_AvgYield
Train_df_Both_AvgYield
Train_df_Temp_cvYield
Train_df_Irrig_cvYield
Train_df_Both_cvYield

```{r, label='Avg Yield Variable Selection', message=FALSE,warning=FALSE}
Train_df_Both_AvgYield = Train_df_Both_AvgYield %>% select(-mean.ElevAboveStreams2)
#par(mar = c(11, 4, 4, 2))

#boruta = readRDS(paste0(wd$data_p,"AGType_RFModel_boruta.rda"))
boruta_Bavg <- Boruta(AvgYield ~ ., data = Train_df_Both_AvgYield[,c(4:ncol(Train_df_Both_AvgYield))], maxRuns = 500)#, doTrace = 2
plot(boruta_Bavg, las = 2, cex.axis = 0.7)
Bavg_atts <- attStats(boruta_Bavg)
Bavg_form = getConfirmedFormula(boruta_Bavg)

#boruta_Tavg <- Boruta(AvgYield ~ ., data = Train_df_Temp_AvgYield[,c(4:ncol(Train_df_Temp_AvgYield))], maxRuns = 500)
#Tavg_atts <- attStats(boruta_Tavg)

#boruta_Iavg <- Boruta(AvgYield ~ ., data = Train_df_Irrig_AvgYield[,c(4:ncol(Train_df_Irrig_AvgYield))], maxRuns = 500)
#Iavg_atts <- attStats(boruta_Iavg)


#print(boruta)
#boruta[["finalDecision"]]
#plot(boruta, las = 2, cex.axis = 0.7)
#bor <- TentativeRoughFix(boruta)
#bor[["finalDecision"]]
#attStats(boruta)
#form=getConfirmedFormula(boruta)

# saving the model
saveRDS(boruta_Bavg, file = paste0(wd$data_p,"AvgYield_RFModel_boruta.rda"))
#rm(boruta)
#loading the model
#boruta = readRDS(paste0(wd$data_p,"AGType_RFModel_boruta.rda"))
rm(Bavg_atts, boruta_Bavg)
#-AvgArea_Maize,-mean.ElevAboveStreams2, -Pop_Rural,-PopDens, -Pct_Herbicides_ha, -PopRuralMz_perMzHa,  -PrimaryMz_perMzHa,  -AGWorkersMz_perMzHa,  -TotalLaborMz_perMzHa,  -LUTotalMz_perMzHa,-AvgPctMaizeArea_Irrig,-PopDensRural,  -Pop_Urban,  -UrbRatio,-PctMun_Arable,-AvgPctArea_Irrig,
Train_df_Both_AvgYield = Train_df_Both_AvgYield %>% select(-AvgPctArea_ofArable,   -LU_Total_DensArable, -PrimaryEmploy_DensArable, -mean.DistStreams2,  -PopRural_DensArable,   -TotalLabor_DensArable, -mean.BDTICM, -mean.curv_min, -mean.FloodOrder_Rel, -mean.elev_watershed, -mean.STI, -mean.pet_summer, -mean.BD, -mean.curv_mean, -mean.rsds_summer, -mean.pet_fall, -mean.Z, -mean.pet_spring, -mean.CF, -mean.SPI)
```
5.1 4.1 4.1 2.1




### (Hyper)Parameter Tuning, Training and Feature Selection

```{r}
lgr::get_logger("mlr3")$set_threshold("warn")

names(Train_df_Both_AvgYield) = sub("^mean\\.", "", names(Train_df_Both_AvgYield))

# Dataset ("Task")
Both_AvgYield = as_task_regr(x = Train_df_Both_AvgYield[,c(4:ncol(Train_df_Both_AvgYield))], target="AvgYield", id = "Both_AvgYield")

# Partition the data with the default 2/3 split (== 2/3 data for training, 1/3 for testing)
splits = partition(Both_AvgYield, ratio=0.67)
Both_AvgYield_train = Both_AvgYield$filter(splits$train)
Both_AvgYield_test = Both_AvgYield$filter(splits$train)
Both_AvgYield = as_task_regr(x = Train_df_Both_AvgYield[,c(4:ncol(Train_df_Both_AvgYield))], target="AvgYield", id = "BoAvY")
#### Initial Random Forest Model Parameter Tuning

# Setup Ranger Random Forest Regression Model (= "Learner") for tuning the hyperparameters
RegRF = lrn("regr.ranger", splitrule = "extratrees", importance = "permutation",
            num.trees  = to_tune(c(100,300,500)), mtry = to_tune(c(6,8,10)), min.node.size = 4,#to_tune(c(4,6,8)),
            #regularization.usedepth = T, regularization.factor = to_tune(c(0.25,0.5,0.75)),#to_tune(seq(0.1,1,0.1))
            max.depth = to_tune(c(5,10,15)))

# Setup Tuning using grid search (hyperparameter space specified in the RF model above)

termz = trm("combo", list(trm("run_time", secs = 12000), trm("evals", n_evals = 300)), any = T)
tuner_grid = tnr("grid_search", resolution = 1, batch_size = 1)

rsmp_holdout = rsmp("holdout")

# Find optimal parameter values

#progressr::with_progress()
BoAvY_instance = tune(
  tuner = tuner_grid,
  task = Both_AvgYield_train,
  learner = RegRF,
  resampling = rsmp_holdout,
  measures =  msr("regr.mae"),
  terminator = termz
)

# Results of Tuning via grid search:
BoAvY_instance$result$learner_param_vals

insample = BoAvY_instance$result_y

# Save tuning grid search results as table for inspection
#z = as.data.table(BoAvY_instance$archive)

#autoplot(BoAvY_instance)

BoAvY_at = auto_tuner(
  tuner = tuner_grid,
  learner = RegRF,
  resampling = rsmp_holdout,
  measure = msr("regr.mae"),
  terminator = termz
)
rsmp_cv5 = rsmp("cv", folds = 5)

outsample = resample(Both_AvgYield_train, BoAvY_at, rsmp_cv5)$aggregate(msr("regr.mae"))

# setup another Ranger Random Forest Regression Model
RegRF_tuned = lrn("regr.ranger")

# Set the tuned parameter values
RegRF_tuned$param_set$values = BoAvY_instance$result_learner_param_vals

generalization = RegRF_tuned$train(Both_AvgYield_train)$
  predict(Both_AvgYield_test)$score(msr("regr.mae"))

rbind(generalization,insample,outsample)

###### Benchmarking

tasks = list(Both_AvgYield)
learners = list(RegRF_tuned, lrn("regr.rpart"), lrn("regr.ranger"))
resamplings = list(rsmp("cv", folds = 5))

grid = benchmark_grid(tasks, learners, resamplings)
head(grid)
bmr = benchmark(grid)
bmr
bmr$aggregate(msrs(c("regr.mse", "regr.mae", "regr.rsq")))[, .(task_id, learner_id, regr.mse, regr.mae, regr.rsq)]

autoplot(bmr, measure = msr("regr.mae"))


####################

# Train model on full data for predictions

RegRF_trained <- RegRF_tuned$train(Both_AvgYield)
```

RF_df_Temp
RF_df_Irrig

# Predict Polygons

```{r}

#u = Pred_Poly_ModLU
#new_geometry <- st_geometry(u)
#u = st_drop_geometry(Pred_Poly_ModLU) %>% select(intersect(names(.), c(names(Train_df_Both_AvgYield), "geom"))) 

u = Pred_Poly_ModLU %>% select(intersect(names(.), c(names(Train_df_Both_AvgYield), "geom"))) 
y = env_vals %>% select(-Estado, -Municipio, -mean.AWCtS, -EstadoMunicipio, -AGType)
u = cbind(u, y)
u = u %>% mutate(AGType = factor(AGType, levels = c("Temporal", "Riego"))) %>% 
  filter(complete.cases(across(AvgYield:mean.rsds_fall))) #%>% mutate(AvgPctArea_ofTotal = 0.8)
names(u) = sub("^mean\\.", "", names(u))
#st_set_geometry(u, new_geometry)
u2 <- st_drop_geometry(u)
utask = as_task_regr(x = u2[,c(1, 5:ncol(u2))], target="AvgYield", id = "Pred_Poly_ModLU")



RegRF_pred = RegRF_trained$predict(task = utask)
pred = as.data.frame(as.data.table(RegRF_pred))
pred$resid = pred$response - pred$truth
hist(pred$resid)
qqnorm(pred$resid, pch = 1, frame = FALSE)
qqline(pred$resid, col = "steelblue", lwd = 2)
pred = pred %>% select(-row_ids, -truth)
names(pred) <- c("AvgYieldRF_Predict", "AvgYieldRF_Resid")
u <- cbind(u, pred)
zzz <- u %>% select(EstadoMunicipio, Estado, Municipio, AvgYield, AGType, AvgYieldRF_Predict, AvgYieldRF_Resid)

plot(zzz["AvgYieldRF_Resid"])
plot(zzz["AvgYieldRF_Predict"])


st_write(zzz, paste0(wd$data_p, "zzz.gpkg"), driver = "GPKG", overwrite=T, append=FALSE)

zzz <- Pred_Poly_ModLU %>% select(intersect(names(.), names(Train_df_Both_AvgYield))) %>% mutate(AGType = factor(AGType, levels = c("Temporal", "Riego"))) 
zzz <- cbind(zzz, y)
zzz <- zzz %>% filter(complete.cases(across(AvgYield:AvgPctArea_ofTotal)))










#####################################################################
#####################################################################\




```

# Predict Raster

```{r}
y = RF_df_Temp %>% select(-ElevAboveStreams2) %>% filter(complete.cases(.))

RegRF_pred = predict(RegRF_trained, newdata = y[,c(2:ncol(y))])

AvgYield_PredictRast <- ArableAreaMask
values(AvgYield_PredictRast) <- -9999
names(AvgYield_PredictRast) <- "AvgYield_Predict"
AvgYield_PredictRast[y$Cells] <- as.numeric(RegRF_pred)
AvgYield_PredictRast <- ifel(AvgYield_PredictRast == -9999, NA, AvgYield_PredictRast)

writeRaster(AvgYield_PredictRast, filename = paste0(wd$data_p, "AvgYield_PredictRast2.tif"), overwrite=TRUE)



RegRF_pred = RegRF_trained$predict(task = utask)







```




The mtry parameter controls the number of randomly selected features to consider at each split
The mtry parameter controls the number of predictor variables randomly sampled at each split in a Random Forest model.
It determines the subset of variables that are considered for splitting at each node of the decision trees.
A larger value of mtry allows for more diverse splits, potentially capturing a wider range of predictive patterns.
However, ***a very large value of mtry may lead to overfitting***, while a very small value may limit the model's ability to capture important relationships.

The num.trees parameter controls the number of decision trees that are included in the Random Forest ensemble.
Increasing the value of num.trees will result in a larger ensemble of trees, while decreasing the value will result in a smaller ensemble. Increasing the number of trees generally improves the performance of a Random Forest model, as it allows for more robust and accurate predictions. However, there is a point of diminishing returns, where adding more trees does not significantly improve the model's performance. The optimal number of trees depends on the dataset, the complexity of the problem, and the trade-off between model accuracy and computational resources.
Setting the num.trees parameter in Random Forest models determines the number of individual decision trees to grow. While there is no one-size-fits-all rule for choosing the optimal value of num.trees, here are some general guidelines and rule-of-thumb approaches:


The min.node.size parameter specifies the minimum number of observations required to create a terminal node in a decision tree.
It determines the minimum size of the terminal nodes, ensuring that each node contains a minimum number of data points.
A larger value of min.node.size results in fewer and larger terminal nodes, which can lead to more generalization and less complexity.
However, setting min.node.size too large may cause the model to underfit the data by producing overly simplistic trees.

The Extra Trees algorithm, also known as extremely randomized trees, is another option for the splitrule.
Extra Trees randomly selects multiple potential split points and chooses the best one based on certain criteria.
This approach can lead to increased randomness and diversity in the tree construction process.
"extratrees" can be useful when dealing with noisy or high-dimensional data or when there are weak or non-linear relationships between predictors and the target variable.

he variance split rule is specific to regression problems, where the goal is to minimize the variance within each child node.
It is suitable when the objective is to predict continuous numeric values rather than class labels.
The variance split rule aims to find splits that minimize the variation or spread of the response variable within each node.
It is particularly useful when the target variable exhibits heteroscedasticity or when there are non-linear relationships.

One common rule of thumb is to set mtry to the square root of the total number of predictors.
For example, if you have 16 predictors, you can set mtry to approximately sqrt(16) = 4.
This rule balances the inclusion of a sufficient number of predictors for each split while maintaining diversity and avoiding overfitting.Another rule of thumb is to set mtry to the logarithm (base 2) of the total number of predictors.
For instance, if you have 16 predictors, you can set mtry to approximately log2(16) = 4.

Use "permutation" when you want to evaluate the importance of variables by measuring the decrease in model performance when the variable's values are randomly permuted.
This measure is applicable for both classification and regression problems.
It provides an indication of the variable's contribution to the model's predictive power and is robust against variable correlation.


**Regularized Random Forest**

  method = 'RRF'
Type: Regression, Classification

Tuning parameters:

mtry (#Randomly Selected Predictors)
coefReg (Regularization Value)
coefImp (Importance Coefficient)
Required packages: randomForest, RRF

A model-specific variable importance metric is available.

Regularized Random Forest

  method = 'RRFglobal'
Type: Regression, Classification

Tuning parameters:

mtry (#Randomly Selected Predictors)
coefReg (Regularization Value)
Required packages: RRF

A model-specific variable importance metric is available.

**Ranger Random Forest**

  method = 'ranger'
Type: Classification, Regression

Tuning parameters:

mtry (#Randomly Selected Predictors)
splitrule (Splitting Rule)
min.node.size (Minimal Node Size)
Required packages: e1071, ranger, dplyr

A model-specific variable importance metric is available.


**Conditional Inference Random Forest**

  method = 'cforest'
Type: Classification, Regression

Tuning parameters:

mtry (#Randomly Selected Predictors)
Required packages: party

A model-specific variable importance metric is available.


```{r}
Both_AvgYield = as_task_regr(x = Train_df_Both_AvgYield[,c(4:ncol(Train_df_Both_AvgYield))], target="AvgYield", id = "BoAvY")
RegRF = lrn("regr.ranger", splitrule = "extratrees", importance = "permutation",
            num.trees  = to_tune(seq(100, 600, 100)), mtry = to_tune(seq(4, 10, 2)), min.node.size = to_tune(seq(4, 10, 2)),
            regularization.usedepth = T, regularization.factor = to_tune(seq(0.1,1,0.1)),#alpha = to_tune(0, 5), 
            max.depth = to_tune(seq(5, 15, 2)))

BoAvY_instance = ti(task = Both_AvgYield, learner = RegRF, resampling = rsmp("cv", folds = 2), 
                    measures = msr("regr.rsq"), terminator = trm("none"))
tuner = tnr("grid_search", resolution = 1, batch_size = 1)

progressr::with_progress(tuner$optimize(BoAvY_instance))

BoAvY_instance$result$learner_param_vals

z = as.data.table(BoAvY_instance$archive)#[1:3, .(mtry, num.trees, regr.rsq)]

as.data.table(instance$archive)[1:3,
  .(timestamp, runtime_learners, errors, warnings)]

RegRF_tuned = lrn("regr.ranger")
lrn_svm_tuned$param_set$values = instance$result_learner_param_vals



at = auto_tuner(
  tuner = tnr_grid_search,
  learner = lrn_svm,
  resampling = rsmp_cv3,
  measure = msr_ce
)


as.data.table(msr())
	
as.data.table(lrn("regr.ranger")$param_set)[,
  .(id, class, lower, upper, nlevels)]

RegRF$par.vals
RegRF$par.set

getHyperPars(RegRF, "train")
LearnerProperties
(RegRF)
(RegRF)

p = listLearners()




##############################################################


lrn_svm_tuned = lrn("classif.svm")
lrn_svm_tuned$param_set$values = instance$result_learner_param_vals

lrn_svm_tuned$train(tsk_sonar)$model



# load and partition our task
tsk_mtcars = tsk("mtcars")
splits = partition(tsk_mtcars)
# load featureless learner
lrn_featureless = lrn("regr.featureless")
# load decision tree with different hyperparameters
lrn_rpart = lrn("regr.rpart", cp = 0.2, maxdepth = 5)
# load MSE and MAE measures
measures = msrs(c("regr.mse", "regr.mae"))
# train learners
lrn_featureless$train(tsk_mtcars, splits$train)
lrn_rpart$train(tsk_mtcars, splits$train)
# make and score predictions
lrn_featureless$predict(tsk_mtcars, splits$test)$score(measures)

lrn_rpart$predict(tsk_mtcars, splits$test)$score(measures)


predict(object, task, newdata, subset = NULL, ...)




```


```{r, label='Avg Yield RF Model Training', message=FALSE,warning=FALSE}

#AGType_RF_model = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger.rda"))
#AGType_RF_model_prob = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger_Prob.rda"))
tgrid <- expand.grid(
  .mtry = 4:10,
  .splitrule = c("extratrees", "variance"),
  .min.node.size = 4:12,
  .max.depth = 5:15
)
 
model_caret <- train(Bavg_form, data = Train_df_Both_AvgYield[,c(4:ncol(Train_df_Both_AvgYield))],
                     method = "ranger",
                     trControl = trainControl(method="cv", number = 5, verboseIter = T),
                     tuneGrid = tgrid,
                     num.trees = 300,
                     importance = "permutation")

RF_model <- ranger(formula = Bavg_form, data = Train_df_Both_AvgYield[,c(4:ncol(Train_df_Both_AvgYield))], num.trees = 300,  mtry = 8, splitrule = "extratrees", importance = "permutation",min.node.size = 4, regularization.factor = 0.5)

tgrid <- expand.grid(
  .mtry = 4:10,
  .coefReg = seq(0, 1, by = 0.1)
)

model_caret <- train(Bavg_form, data = Train_df_Both_AvgYield[,c(4:ncol(Train_df_Both_AvgYield))],
                     method = "RRFglobal",
                     trControl = trainControl(method="cv", number = 3, verboseIter = T),
                     tuneGrid = tgrid,
                     ntree = 300,
                     nodesize = 4,
                     importance=T)

mtry 
coefReg (Regularization Value)
coefImp (Importance Coefficient)







tree <- treeInfo(RF_model, tree = 1)
tree <- as.party(tree)
rpart.plot(tree)
# Define the tuning grid
grid <- expand.grid(mtry = seq(1, sqrt(ncol(Train_df_Both_AvgYield)), by = 2),  # Range of mtry values
                    num.trees = c(100, 200, 300))  # Range of num.trees values

# Perform the tuning
model <- train(y ~ ., data = your_data, method = "ranger",
               trControl = ctrl, tuneGrid = grid)

RF_model <- ranger(formula = Bavg_form, data = Train_df_Both_AvgYield)

print(RF_model)

RFModel_predict <- predict(RF_model, data=Train_df_Both_AvgYield)
pred_df <- pred_df %>% select(Cells)
pred_df$Predictions <- RFModel_predict$predictions



# saving the model
saveRDS(AGType_RF_model, file = paste0(wd$data_p,"AGType_RFModel_Ranger.rda"))

### probability forest classification as in Malley et al. (2012)
###https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3250568/
### Malley JD, Kruppa J, Dasgupta A, Malley KG, Ziegler A. Probability machines: consistent probability estimation using nonparametric learning machines. Methods Inf Med. 2012;51(1):74-81. doi: 10.3414/ME00-01-0052. Epub 2011 Sep 14. PMID: 21915433; PMCID: PMC3250568.

AGType_RF_model_prob <- ranger(formula = form, data = AGType_RF_Train_df, probability = T)

print(AGType_RF_model_prob)

# saving the model
saveRDS(AGType_RF_model_prob, file = paste0(wd$data_p,"AGType_RFModel_Ranger_Prob.rda"))


#loading the model
#AGType_RF_model = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger.rda"))
#AGType_RF_model_prob = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger_Prob.rda"))

```

## C.V. Average Yield

### Variable Selection

```{r, label='C.V. Avg Yield RF Model Variable Selection', message=FALSE,warning=FALSE}
#boruta = readRDS(paste0(wd$data_p,"AGType_RFModel_boruta.rda"))

boruta_Bcv <- Boruta(cvYield ~ ., data = Train_df_Both_cvYield[,c(4:ncol(Train_df_Both_cvYield))], maxRuns = 500)
Bcv_atts <- attStats(boruta_Bcv)
plot(boruta_Bcv, las = 2, cex.axis = 0.7)
Bcv_atts <- attStats(boruta_Bcv)
Bcv_form = getConfirmedFormula(boruta_Bcv)

#boruta_Tcv <- Boruta(cvYield ~ ., data = Train_df_Temp_cvYield[,c(4:ncol(Train_df_Temp_cvYield))], maxRuns = 500)
#Tcv_atts <- attStats(boruta_Tcv)

#boruta_Icv <- Boruta(cvYield ~ ., data = Train_df_Irrig_cvYield[,c(4:ncol(Train_df_Irrig_cvYield))], maxRuns = 500)
#Icv_atts <- attStats(boruta_Icv)


boruta <- Boruta(AGType ~ ., data = AGType_RF_Train_df[,c(2:27)], maxRuns = 100)#, doTrace = 2
print(boruta)
boruta[["finalDecision"]]
plot(boruta, las = 2, cex.axis = 0.7)
#bor <- TentativeRoughFix(boruta)
#bor[["finalDecision"]]
attStats(boruta)
form=getConfirmedFormula(boruta)

# saving the model
saveRDS(boruta, file = paste0(wd$data_p,"AGType_RFModel_boruta.rda"))
#rm(boruta)
#loading the model
#boruta = readRDS(paste0(wd$data_p,"AGType_RFModel_boruta.rda"))
```



### Train the Model

```{r, label='C.V. Avg Yield RF Model Training', message=FALSE,warning=FALSE}

#AGType_RF_model = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger.rda"))
#AGType_RF_model_prob = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger_Prob.rda"))

AGType_RF_model <- ranger(formula = form, data = AGType_RF_Train_df)

print(AGType_RF_model)

# saving the model
saveRDS(AGType_RF_model, file = paste0(wd$data_p,"AGType_RFModel_Ranger.rda"))

### probability forest classification as in Malley et al. (2012)
###https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3250568/
### Malley JD, Kruppa J, Dasgupta A, Malley KG, Ziegler A. Probability machines: consistent probability estimation using nonparametric learning machines. Methods Inf Med. 2012;51(1):74-81. doi: 10.3414/ME00-01-0052. Epub 2011 Sep 14. PMID: 21915433; PMCID: PMC3250568.

AGType_RF_model_prob <- ranger(formula = form, data = AGType_RF_Train_df, probability = T)

print(AGType_RF_model_prob)

# saving the model
saveRDS(AGType_RF_model_prob, file = paste0(wd$data_p,"AGType_RFModel_Ranger_Prob.rda"))


#loading the model
#AGType_RF_model = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger.rda"))
#AGType_RF_model_prob = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger_Prob.rda"))

```


# Model Predictions

## Avg Yield

```{r, label='Avg Yield RF Model Predictions', message=FALSE,warning=FALSE}
parts = c("AGType_RFModel_Data1", "AGType_RFModel_Data2", "AGType_RFModel_Data3", "AGType_RFModel_Data4", "AGType_RFModel_Data5")

pred_list = list()

i=1
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Predictions <- RFModel_predict$predictions
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=2
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Predictions <- RFModel_predict$predictions
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=3
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Predictions <- RFModel_predict$predictions
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=4
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Predictions <- RFModel_predict$predictions
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=5
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Predictions <- RFModel_predict$predictions
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)


pred_df <- do.call(rbind, pred_list)

rm(pred_list)

AGType_RF_df = AGType_RF_df %>% left_join(pred_df, by = "Cells")
zzz = zzz %>% left_join(pred_df, by = "Cells")

rm(pred_df)

```



## C.V. Average Yield

```{r, label='C.V. Yield RF Model Predictions', message=FALSE,warning=FALSE}
parts = c("AGType_RFModel_Data1", "AGType_RFModel_Data2", "AGType_RFModel_Data3", "AGType_RFModel_Data4", "AGType_RFModel_Data5")

pred_list = list()

i=1
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model_prob, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Prob_Temporal <- as.data.frame(RFModel_predict[["predictions"]])$Temporal
pred_df$Prob_Irrigation <- as.data.frame(RFModel_predict[["predictions"]])$Irrigation
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=2
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model_prob, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Prob_Temporal <- as.data.frame(RFModel_predict[["predictions"]])$Temporal
pred_df$Prob_Irrigation <- as.data.frame(RFModel_predict[["predictions"]])$Irrigation
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=3
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model_prob, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Prob_Temporal <- as.data.frame(RFModel_predict[["predictions"]])$Temporal
pred_df$Prob_Irrigation <- as.data.frame(RFModel_predict[["predictions"]])$Irrigation
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=4
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model_prob, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Prob_Temporal <- as.data.frame(RFModel_predict[["predictions"]])$Temporal
pred_df$Prob_Irrigation <- as.data.frame(RFModel_predict[["predictions"]])$Irrigation
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=5
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model_prob, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Prob_Temporal <- as.data.frame(RFModel_predict[["predictions"]])$Temporal
pred_df$Prob_Irrigation <- as.data.frame(RFModel_predict[["predictions"]])$Irrigation
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)


pred_df <- do.call(rbind, pred_list)

rm(pred_list)

AGType_RF_df = AGType_RF_df %>% left_join(pred_df, by = "Cells")
zzz = zzz %>% left_join(pred_df, by = "Cells")

rm(pred_df)

```



## Export Outputs


```{r, label='Merge and Export Outputs', message=FALSE,warning=FALSE}

AGType_RF_df$Cells <- as.numeric(AGType_RF_df$Cells)





#AGType <- x[[1]]
values(AGType) <- NA
AGType[AGType_RF_df$Cells] <- AGType_RF_df$Predictions
AGType = as.factor(AGType)
levels(AGType) = levels(AGType)[[1]] %>% 
  mutate(AGType = case_when(
    ID == 1 ~ "Temporal",
    ID == 2 ~ "Irrigated"))
names(AGType) <- "AGType"

AGType_Prob_Temp <- as.numeric(AGType)
names(AGType_Prob_Temp) <- "AGType_Prob_Temp"
AGType_Prob_Irrig <- as.numeric(AGType)
names(AGType_Prob_Irrig) <- "AGType_Prob_Irrig"

values(AGType_Prob_Temp) <- NA
AGType_Prob_Temp[AGType_RF_df$Cells] <- AGType_RF_df$Prob_Temporal
values(AGType_Prob_Irrig) <- NA
AGType_Prob_Irrig[AGType_RF_df$Cells] <- AGType_RF_df$Prob_Irrigation

writeRaster(AGType, filename = paste0(wd$data_p, "AGType_Predict.tif"), overwrite=TRUE)
rm(AGType)
AGType <- rast(paste0(wd$data_p,"AGType_Predict.tif"))

writeRaster(AGType_Prob_Temp, filename = paste0(wd$data_p, "AGType_Prob_Temp.tif"), overwrite=TRUE)
rm(AGType_Prob_Temp)
AGType_Prob_Temp <- rast(paste0(wd$data_p,"AGType_Prob_Temp.tif"))

writeRaster(AGType_Prob_Irrig, filename = paste0(wd$data_p, "AGType_Prob_Irrig.tif"), overwrite=TRUE)
rm(AGType_Prob_Irrig)
AGType_Prob_Irrig <- rast(paste0(wd$data_p,"AGType_Prob_Irrig.tif"))


AGType_RF_df %>%
  mutate(part = case_when(
    row_number() <= ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data1",
    row_number() <= 2 * ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data2",
    row_number() <= 3 * ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data3",
    row_number() <= 4 * ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data4",
    TRUE ~ "AGType_RFModel_Data5"
  )) %>%
  group_split(part) %>%
  purrr::walk2(
    .,
    c("AGType_RFModel_Data1", "AGType_RFModel_Data2", "AGType_RFModel_Data3", "AGType_RFModel_Data4", "AGType_RFModel_Data5"),
    ~ write_csv(.x, file = paste0(wd$data_p, .y, ".csv.gz"))
  )

rm(AGType_RF_Train_df, AGType_RF_df, AGType_RF_model, x, form, i, l, parts, zzz, SIAP_LU_Fields_AGType, AGType_RF_model_prob, boruta, DEM, ArableAreaMask)


DEM_100m <- rast(paste0(wd$data_p,"DEM_100m.tif"))
AGType_Predict_100m <- resample(AGType, DEM_100m, method = "near")
writeRaster(AGType_Predict_100m, filename = paste0(wd$data_p, "AGType_Predict_100m.tif"), overwrite=TRUE)
AGType_Prob_Temp_100m <- resample(AGType_Prob_Temp, DEM_100m, method = "bilinear")
writeRaster(AGType_Prob_Temp_100m, filename = paste0(wd$data_p, "AGType_Prob_Temp_100m.tif"), overwrite=TRUE)
AGType_Prob_Irrig_100m <- resample(AGType_Prob_Irrig, DEM_100m, method = "bilinear")
writeRaster(AGType_Prob_Irrig_100m, filename = paste0(wd$data_p, "AGType_Prob_Irrig_100m.tif"), overwrite=TRUE)

#rm(DEM_100m,AGType_Predict_100m,AGType_Prob_Temp_100m,AGType_Prob_Irrig_100m)


#rm(Arable_RF_Train_df, Arable_RF_df, RF_pred, Arable_RF_Predict_df, RF_model, boruta, Cultiv)


```




























# UNUSED


### Calculate/Modify AG Variables

```{r, label='Calculate/Modify Agricultural Variables', message=FALSE,warning=FALSE}

# Chang outliers from Intensive labor and laboresque capital input metrics using Arable Area as denominator

Data2000s_poly_rs <- Data2000s_poly_rs %>% mutate(
  LU_Total_DensArable = ifelse(LU_Total_DensArable > 3.5, 3.5, LU_Total_DensArable),
  AG_Workers_DensArable = ifelse(AG_Workers_DensArable > 1, 1, AG_Workers_DensArable),
  #MechanizEquip_DensArable = MechanizEquip / Arable_ha,
  #DraftAnimals_DensArable = DraftAnimals_Total / Arable_ha,
  PrimaryEmploy_DensArable = ifelse(PrimaryEmploy_DensArable > 1.3, 1.3, PrimaryEmploy_DensArable),
  TotalLabor_DensArable = ifelse(TotalLabor_DensArable > 2.5, 2.5, TotalLabor_DensArable),
  Pop_DensArable = ifelse(Pop_DensArable > 100, 100, Pop_DensArable),
  PopRural_DensArable = ifelse(PopRural_DensArable > 7, 7, PopRural_DensArable))

#########################################################################


# Labor and laboresque capital input metrics modified by percent total area planted in maize by AGType &
# Intensive labor and laboresque capital input metrics using SIAP Maize planted area by AGType as denominator

Data2000s_poly_rs <- Data2000s_poly_rs %>% rowwise() %>% mutate(

  # Modify labor and laboresque capital input metrics by the percentage of average total cultivated area planted in maize
  # This is done by agriculture type, so that the value for each row reflects its average % of cultivated area (either irrigated or temporal), rather than the municipal total
  # This assumes that the percent of total labor devoted to maize cultivation is directly proportional to its fraction of total cultivation (i.e. that average labor allocation to a crop is proportional to its proportion of the average cultivated area)
  AvgPctArea_ofTotal = AvgArea_Maize / AvgArea_Total,
  AvgPctArea_ofArable = AvgArea_Maize / Arable_ha,
  AvgPctArea_ofTotal = case_when(
    EstadoMunicipio == "High Elevation" ~ 0.4700912,
    .default = AvgPctArea_ofTotal),
  AvgPctArea_ofArable = case_when(
    EstadoMunicipio == "High Elevation" ~ 0.2847692,
    .default = AvgPctArea_ofArable),
  PopRuralMz = Pop_Rural * AvgPctArea_ofTotal,
  PrimaryMz = Primary * AvgPctArea_ofTotal,
  AGWorkersMz = AG_Workers * AvgPctArea_ofTotal,
  TotalLaborMz = TotalLabor * AvgPctArea_ofTotal,
  LUTotalMz = LU_Total * AvgPctArea_ofTotal, 
  ContractLaboTotMz = ContractLabor_Tot * AvgPctArea_ofTotal, 
  ContractLaborFullMz = ContractLabor_More6Mo * AvgPctArea_ofTotal, 
  ContractLaboPartMz = ContractLabor_Less6Mo * AvgPctArea_ofTotal, 
  FamLaborMz = FamLabor_Tot * AvgPctArea_ofTotal, 
  MechanizEquipMz = MechanizEquip * AvgPctArea_ofTotal, 
  DraftAnimalsMz = DraftAnimals_Total * AvgPctArea_ofTotal, 
  TractorsMz = Tractors * AvgPctArea_ofTotal,
  
  # Calculate the intensity of maize labor and laboresque capital input metrics per unit area (hectares)
  # This is done by agriculture type, so that the value for each row reflects its average % of cultivated area (either irrigated or temporal), rather than the municipal total
  # This assumes that the inter-annual average cultivated area for maize (by AGType) is representative
  
  PopRuralMz_perMzHa = PopRuralMz / AvgArea_Maize,
  #PopRuralMz_perMzHa = ifelse(PopRuralMz_perMzHa > 150, 150, PopRuralMz_perMzHa),
  PrimaryMz_perMzHa = PrimaryMz / AvgArea_Maize,
  AGWorkersMz_perMzHa = AGWorkersMz / AvgArea_Maize,
  TotalLaborMz_perMzHa = TotalLaborMz / AvgArea_Maize,
  LUTotalMz_perMzHa = LUTotalMz / AvgArea_Maize,
  ContractLaboTotMz_perMzHa = ContractLaboTotMz / AvgArea_Maize,
  ContractLaborFullMz_perMzHa = ContractLaborFullMz / AvgArea_Maize,
  ContractLaboPartMz_perMzHa = ContractLaboPartMz / AvgArea_Maize,
  FamLaborMz_perMzHa = FamLaborMz / AvgArea_Maize,
  MechanizEquipMz_perMzHa = MechanizEquipMz / AvgArea_Maize,
  DraftAnimalsMz_perMzHa = DraftAnimalsMz / AvgArea_Maize,
  TractorsMz_perMzHa = TractorsMz / AvgArea_Maize) %>% ungroup()

write.csv(st_drop_geometry(Data2000s_poly_rs), paste0(wd$data_r,"Data2000s_poly_rs.csv"))

#########################################################################

# Accessibility Metrics

#accessibility to urban pop
#accessibility to rural pop
#accessibility to arable area
#accessibility to pop density
#accessibility to % primary
#accessibility to % irrigated / irrigated_ha

```







## Subset Raster Data

```{r, label='Subset Environmental Data Rasters', message=FALSE,warning=FALSE}
Soil_r_sub <- subset(Soil_r, c("BD","S", "Z","C","SOC","CEC","OCD","N", "BDRICM", "BDTICM"))

TopoEnv_r_sub <- subset(TopoEnv_r, c("DEM", "Slope","Accum", "TRI", "TWI", "STI", "SPI"))

Clim_r_sub <- subset(Clim_r, c("prec_04", "prec_05", "prec_06", "prec_07", "prec_08", "prec_09", "prec_10", "prec_11",
                               "pr_04", "pr_05", "pr_06", "pr_07", "pr_08", "pr_09", "pr_10", "pr_11",
                               "tmean_04", "tmean_05", "tmean_06", "tmean_07", "tmean_08", "tmean_09", "tmean_10", "tmean_11", 
                               "tmin_04","tmin_05", "tmin_06", "tmin_07", "tmin_08", "tmin_09", "tmin_10","tmin_11",
                               "clt_04", "clt_05", "clt_06", "clt_07", "clt_08", "clt_09", "clt_10", "clt_11", 
                               "rsds_04", "rsds_05", "rsds_06", "rsds_07", "rsds_08", "rsds_09", "rsds_10", "rsds_11"
                               ))

```



## Extract Raster Values

```{r, label='Extract Raster Values', message=FALSE,warning=FALSE}

topo_vals <- exact_extract(x = TopoEnv_r_sub, y = Data2000s_poly, fun = "mean", 
                           max_cells_in_memory = 8e+08, stack_apply=T, 
                           append_cols = c("EstadoMunicipio","Estado", "Municipio", "AGType"))

soil_vals <- exact_extract(x = Soil_r_sub, y = Data2000s_poly, fun = "mean", 
                           max_cells_in_memory = 8e+08, stack_apply=T, 
                           append_cols = c("EstadoMunicipio","Estado", "Municipio", "AGType"))

clim_vals <- exact_extract(x = Clim_r_sub, y = Data2000s_poly, fun = "mean", 
                           max_cells_in_memory = 8e+08, stack_apply=T, 
                           append_cols = c("EstadoMunicipio","Estado", "Municipio", "AGType"))

env_vals <- topo_vals %>% left_join(soil_vals, by = c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>% 
                          left_join(clim_vals, by = c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>% 
                          mutate(AGType = as.factor(AGType))
  

#env_vals = merge(topo_vals, soil_vals, all = F, sort = F)

rm(topo_vals, soil_vals, clim_vals)

```

```{r}
#values2 <- exact_extract(x = Soil_r_sub, y = Data2000s_poly, fun = "count", max_cells_in_memory = 8e+08, stack_apply=T, append_cols = c("EstadoMunicipio","Estado", "Municipio", "AGType"))

#xx = cbind(st_drop_geometry(Data2000s_poly$EstadoMunicipio), values)

#values <- exact_extract(x = Soil_r_sub[[1:2]], y = Data2000s_poly, fun = mymean, summarize_df = TRUE, max_cells_in_memory = 8e+08, stack_apply=T)

all <- c(Clim_r_sub, Soil_r_sub, TopoEnv_r_sub)

Soil_df <- exact_extract(x = Soil_r_sub, y = Data2000s_poly, fun = mymean, max_cells_in_memory = 8e+10)
save(all_df, file = paste0(wd$data_r, "EnvRastPolyExtract_df.rData"))


st_extract(Clim_r[,,,5], x, fun = mean)

Clim_df <- data.frame()

for (i in 1:nlyr(Clim_r)) {
  out[, i] <- my_function(my_df[, i])
}

nlyr(Clim_r)
values <- exact_extract(x = Clim_r[[1:2]], y = x, fun = "mean", max_cells_in_memory = 8e+08)

c("prec_05", "prec_06", "prec_07", "prec_08", "prec_09", "prec_10", 
"pr_05", "pr_06", "pr_07", "pr_08", "pr_09", "pr_10", 
"tmean_05", "tmean_06", "tmean_07", "tmean_08", "tmean_09", "tmean_10", 
"tmin_05", "tmin_06", "tmin_07", "tmin_08", "tmin_09", "tmin_10")

clim <- stack(prec[[5:7]],prec[[5:7]],
prec[[8:10]],
tmin[[5:7]],
tmin[[8:10]],tmin[[8:10]])
geol <- stack(depth, cation, slope)

geol_vals <- extract(geol,points)
clim_vals <- extract(clim,points)
```




# Construct Training Dataset


Rescaling/Normalizing the data is unnecessary!! 
Random Forest algorithm is not a distance-based model - it is a tree-based model. Each node in a Random Forest is not comparing feature values, it is simply splitting a sorted list that requires absolute values for branching. The algorithm is based on partitioning the data to make predictions, therefore, it does not require normalization.

https://www.kdnuggets.com/2022/07/random-forest-algorithm-need-normalization.html#:~:text=Each%20node%20in%20a%20Random,it%20does%20not%20require%20normalization.



## Agricultural Data


```{r, label='Prepare Agricultural Data', message=FALSE,warning=FALSE}

x = st_drop_geometry(Data2000s_poly)# %>% filter(-1:3)
x = x %>% filter(!(EstadoMunicipio %in% c("Ixtapaluca, Mexico", "Valle de Chalco Solidaridad, Mexico", "Milpa Alta, Distrito Federal", "Tlahuac, Distrito Federal", "Xochimilco, Distrito Federal", "Axapusco, Mexico") & AGType %in% "Riego"))

#x = x[,-c(1:5)]
#x = as.data.frame(x)
Tot = x %>% select(-AvgYield_Total, -sdYield_Total, -cvYield_Total, 
                   -AvgYield_Irrig, -sdYield_Irrig, -cvYield_Irrig, -AvgYield_Temp, 
                   -sdYield_Temp, -cvYield_Temp, -ITr_AvgYield, -ITr_cvYield, 
                   -AvgYieldLoss_Total, -sdYieldLoss_Total, -cvYieldLoss_Total, 
                   -AvgYieldLoss_Irrig, -sdYieldLoss_Irrig, -cvYieldLoss_Irrig, 
                   -AvgYieldLoss_Temp, -sdYieldLoss_Temp, -cvYieldLoss_Temp, 
                   -ITr_AvgYieldLoss,  -ITr_cvYieldLoss, -minYieldLoss) %>% 
  filter(complete.cases(.))


# Find rows with NA, NaN, or Inf values
#rows_with_na <- apply(Tot, 1, function(row) any(is.na(row) | is.nan(row) | is.infinite(row)))

# Find columns with NA, NaN, or Inf values
#columns_with_na <- apply(Tot, 2, function(column) any(is.na(column) | is.nan(column) | is.infinite(column)))

# Print the rows and columns with NA, NaN, or Inf values
#cat("Rows with NA, NaN, or Inf values:\n")
#print(which(rows_with_na))
#cat("\n")
#cat("Columns with NA, NaN, or Inf values:\n")
#print(which(columns_with_na))

```

```{r, label='Prepare Agricultural Data', message=FALSE,warning=FALSE}

Data2000s_poly <- Data2000s_poly %>% mutate(
  AGType = as.factor(AGType),
  AvgYield = as.numeric(AvgYield),
  sdYield = as.numeric(sdYield),
  minYield = as.numeric(minYield),
  maxYield = as.numeric(maxYield),
  medYield = as.numeric(medYield),
  cvYield = as.numeric(cvYield),
  
  AvgYieldLoss = as.numeric(AvgYieldLoss),
  sdYieldLoss = as.numeric(sdYieldLoss),
  minYieldLoss = as.numeric(minYieldLoss),
  maxYieldLoss = as.numeric(maxYieldLoss),
  medYieldLoss = as.numeric(medYieldLoss),
  cvYieldLoss = as.numeric(cvYieldLoss),
  
  AvgPlanted = as.numeric(AvgPlanted),
  AvgHarvested = as.numeric(AvgHarvested),
  sdHarvested = as.numeric(sdHarvested),
  cvHarvested = as.numeric(cvHarvested),
  AvgLost = as.numeric(AvgLost),
  sdLost = as.numeric(sdLost),
  cvLost = as.numeric(cvLost),
  AvgProduct = as.numeric(AvgProduct),
  AvgValue = as.numeric(AvgValue),
  AvgPrice = as.numeric(AvgPrice),
  n = as.numeric(n),
  n_Total = as.numeric(n_Total),
  AvgYield_Total = as.numeric(AvgYield_Total),
  sdYield_Total = as.numeric(sdYield_Total),
  cvYield_Total = as.numeric(cvYield_Total),
  AvgYield_Irrig = as.numeric(AvgYield_Irrig),
  sdYield_Irrig = as.numeric(sdYield_Irrig),
  cvYield_Irrig = as.numeric(cvYield_Irrig),
  AvgYield_Temp = as.numeric(AvgYield_Temp),
  sdYield_Temp = as.numeric(sdYield_Temp),
  cvYield_Temp = as.numeric(cvYield_Temp),
  ITr_AvgYield = as.numeric(ITr_AvgYield),
  ITr_cvYield = as.numeric(ITr_cvYield),
  
  AvgYieldLoss_Total = as.numeric(AvgYieldLoss_Total),
  sdYieldLoss_Total = as.numeric(sdYieldLoss_Total),
  cvYieldLoss_Total = as.numeric(cvYieldLoss_Total),
  AvgYieldLoss_Irrig = as.numeric(AvgYieldLoss_Irrig),
  sdYieldLoss_Irrig = as.numeric(sdYieldLoss_Irrig),
  cvYieldLoss_Irrig = as.numeric(cvYieldLoss_Irrig),
  AvgYieldLoss_Temp = as.numeric(AvgYieldLoss_Temp),
  sdYieldLoss_Temp = as.numeric(sdYieldLoss_Temp),
  cvYieldLoss_Temp = as.numeric(cvYieldLoss_Temp),
  ITr_AvgYieldLoss = as.numeric(ITr_AvgYieldLoss),
  ITr_cvYieldLoss = as.numeric(ITr_cvYieldLoss),
  
  Pct_Tract_Mechaniz_pu = as.numeric(Pct_Tract_Mechaniz_pu),
  Pct_Tract_Animal_pu = as.numeric(Pct_Tract_Animal_pu),
  Pct_Tract_Manual_pu = as.numeric(Pct_Tract_Manual_pu),
  Riego_PU = as.numeric(Riego_PU),
  Temporal_PU = as.numeric(Temporal_PU)
  )

```

--n = 1 case--
***- Riego
Malinalco, Mexico 
Chicoloapan, Mexico
Chimalhuacan, Mexico

sdYield     cvYield sdYieldLoss cvYieldLoss sdHarvested cvHarvested      sdLost      cvLost 


***- Riego
Ixtapaluca, Mexico 
Valle de Chalco Solidaridad, Mexico
Milpa Alta, Distrito Federal
Tlahuac, Distrito Federal
Xochimilco, Distrito Federal
Axapusco, Mexico




-AvgYieldLoss_Irrig, -sdYieldLoss_Irrig, -cvYieldLoss_Irrig, -AvgYieldLoss_Temp, -sdYieldLoss_Temp, -cvYieldLoss_Temp, -ITr_AvgYieldLoss,  -ITr_cvYieldLoss


AvgYield_Irrig	
         sdYield_Irrig	
         cvYield_Irrig	
         AvgYield_Temp	
         sdYield_Temp	
         cvYield_Temp	
         ITr_AvgYield	
         ITr_cvYield

         AvgYieldLoss_Irrig	
         sdYieldLoss_Irrig	
         cvYieldLoss_Irrig	
         AvgYieldLoss_Temp	
         sdYieldLoss_Temp	
         cvYieldLoss_Temp	
         ITr_AvgYieldLoss	
         ITr_cvYieldLoss






## Merge Raster Data with AG Data

```{r}

Train_Total = Tot %>% select(-Estado_ID, -Municipio_ID) %>% 
  left_join(env_vals, by=c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>%
  select(AGType, AvgYield, sdYield, cvYield, AvgYieldLoss, sdYieldLoss, cvYieldLoss, Pop_Total, Pop_Urban, UrbRatio, Pct_Primary, Pct_Rented_ha, Pct_Rest_ha, Pct_Fallow_ha, Pct_FertilChem_ha, Pct_FertilManure_ha, Pct_ImprovSeed_ha, Pct_Herbicides_ha, Pct_Insecticides_ha, Pct_ControlledBurn_ha, TotalLabor, TotalLabor_perHa, PctContractLabor, Pct_Pasture_ha, LU_Total, LU_Total_perHa, mean.DEM, mean.Slope, mean.Accum, mean.TRI, mean.TWI, mean.STI, mean.SPI, mean.BD, mean.S, mean.Z, mean.C, mean.SOC, mean.CEC, mean.OCD, mean.N, mean.BDRICM, mean.BDTICM, mean.prec_04, mean.prec_05, mean.prec_06, mean.prec_07, mean.prec_08, mean.prec_09, mean.prec_10, mean.prec_11, mean.pr_04, mean.pr_05, mean.pr_06, mean.pr_07, mean.pr_08, mean.pr_09, mean.pr_10, mean.pr_11, mean.tmean_04, mean.tmean_05, mean.tmean_06, mean.tmean_07, mean.tmean_08, mean.tmean_09, mean.tmean_10, mean.tmean_11, mean.tmin_04, mean.tmin_05, mean.tmin_06, mean.tmin_07, mean.tmin_08, mean.tmin_09, mean.tmin_10, mean.tmin_11, mean.clt_04, mean.clt_05, mean.clt_06, mean.clt_07, mean.clt_08, mean.clt_09, mean.clt_10, mean.clt_11, mean.rsds_04, mean.rsds_05, mean.rsds_06, mean.rsds_07, mean.rsds_08, mean.rsds_09, mean.rsds_10, mean.rsds_11) %>%
  mutate(AGType = as.factor(AGType))

Train_Temp = Train %>% filter(AGType == "Temporal") %>% select(-AGType)

Train_Irrig = Train %>% filter(AGType == "Riego") %>% select(-AGType)

Train_Env = Tot %>% select(-Estado_ID, -Municipio_ID) %>% 
  left_join(env_vals, by=c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>%
  select(AGType, mean.DEM, mean.Slope, mean.Accum, mean.TRI, mean.TWI, mean.STI, mean.SPI, mean.BD, mean.S, mean.Z, mean.C, mean.SOC, mean.CEC, mean.OCD, mean.N, mean.BDRICM, mean.BDTICM, mean.prec_04, mean.prec_05, mean.prec_06, mean.prec_07, mean.prec_08, mean.prec_09, mean.prec_10, mean.prec_11, mean.pr_04, mean.pr_05, mean.pr_06, mean.pr_07, mean.pr_08, mean.pr_09, mean.pr_10, mean.pr_11, mean.tmean_04, mean.tmean_05, mean.tmean_06, mean.tmean_07, mean.tmean_08, mean.tmean_09, mean.tmean_10, mean.tmean_11, mean.tmin_04, mean.tmin_05, mean.tmin_06, mean.tmin_07, mean.tmin_08, mean.tmin_09, mean.tmin_10, mean.tmin_11, mean.clt_04, mean.clt_05, mean.clt_06, mean.clt_07, mean.clt_08, mean.clt_09, mean.clt_10, mean.clt_11, mean.rsds_04, mean.rsds_05, mean.rsds_06, mean.rsds_07, mean.rsds_08, mean.rsds_09, mean.rsds_10, mean.rsds_11) %>%
  mutate(AGType = as.factor(AGType))


```





### PCA for Variable Selection

```{r, label='PCA for Agricultural Variable Selection', message=FALSE,warning=FALSE}

# sdYield, cvYield, sdHarvested, cvHarvested, sdLost                

pca_tot <- prcomp(Train[,-c(1:4)], center = TRUE, scale. = TRUE)
loadings_tot = as.data.frame(pca_tot$rotation, row.names = colnames(Train[,-c(1:4)]))

pca_temp <- prcomp(Temp[,-c(1:3)], center = TRUE, scale. = TRUE)
loadings_temp = as.data.frame(pca_temp$rotation, row.names = colnames(Temp[,-c(1:3)]))

pca_irrig <- prcomp(Irrig[,-c(1:3)], center = TRUE, scale. = TRUE)
loadings_irrig = as.data.frame(pca_irrig$rotation, row.names = colnames(Irrig[,-c(1:3)]))

#res <- cor(y)
#res = as.data.frame(round(res, 2))

```


```{r}
hist(Temp$AvgYield, breaks = seq(0, 5200, by = 200), xlim = c(0,5200))
hist(Irrig$AvgYield, breaks = seq(2000, 10250, by = 250), xlim = c(2000,10250))
#rescale to 1500-8000
hist(Tot$AvgYield, breaks = seq(0, 10250, by = 250), xlim = c(0,10250))
hist(log(Irrig$AvgYield))
hist(log(Tot$AvgYield))

plot(Tot$LU_Total_perHa, Tot$AvgYield)
plot(log(Tot$LU_Total_perHa), log(Tot$AvgYield))
plot(Irrig$LU_Total_perHa, Irrig$AvgYield)
plot(log(Irrig$LU_Total_perHa), (Irrig$AvgYield))
plot(Temp$LU_Total_perHa, Temp$AvgYield)
plot(log(Temp$LU_Total_perHa), log(Temp$AvgYield))
```





### Boruta for Variable Selection

Random Forest feature selection, why we need feature selection?

When we have too many features in the datasets and we want to develop a prediction model like a neural network will take a lot of time and reduces the accuracy of the prediction model.

We need to make use of the Boruta algorithm and is based on random forest.

How Boruta works?
Suppose if you have 100 variables in the dataset, each attributes creates shadow attributes, and in each shadow attribute, all the values are shuffled and creates randomness in the dataset.

Based on these datasets will create a classification model with shadow attributes and original attributes and then assess the importance of the attributes.
https://www.r-bloggers.com/2021/05/random-forest-feature-selection/
Boruta is an all relevant feature selection wrapper algorithm, capable of working with any classification method that output variable importance measure (VIM); by default, Boruta uses Random
Forest. The method performs a top-down search for relevant features by comparing original attributes’ importance with importance achievable at random, estimated using their permuted copies,
and progressively eliminating irrelevant features to stabilise that test.
https://cran.r-project.org/web/packages/Boruta/Boruta.pdf

```{r}
#Response = Train$AvgYield
#Predictors = Train %>% select(-EstadoMunicipio, -Estado, -Municipio, -AvgYield)
TrainB = Train %>% select(-EstadoMunicipio, -Estado, -Municipio)

TrainB2 = Tot %>% select(-Estado_ID, -Municipio_ID) %>% 
  left_join(env_vals, by=c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>%
  select(-EstadoMunicipio, -Estado, -Municipio) %>%
  select(AGType, AvgYield, cvYield, AvgYieldLoss, cvYieldLoss, Pop_Total, Pop_Rural, Pop_Urban, UrbRatio, Pop_Pct_Rural, Primary, Pct_Primary, AG_Workers, Pct_AG_Workers, Pct_Rented_ha, Pct_Rest_ha, Pct_Fallow_ha, Pct_FertilChem_ha, Pct_FertilManure_ha, Pct_ImprovSeed_ha, Pct_Herbicides_ha, Pct_Insecticides_ha, Pct_ControlledBurn_ha, TotalLabor, TotalLabor_perHa, PrimaryEmploy_perHa, AG_Workers_perHa, PctContractLabor, LU_Total, LU_Total_perHa, PopDensRural, PopDens, mean.DEM, mean.Slope, mean.Accum, mean.TRI, mean.TWI, mean.STI, mean.SPI, mean.BD, mean.S, mean.Z, mean.C, mean.SOC, mean.CEC, mean.OCD, mean.N, mean.BDRICM, mean.BDTICM, mean.prec_04, mean.prec_05, mean.prec_06, mean.prec_07, mean.prec_08, mean.prec_09, mean.prec_10, mean.prec_11, mean.pr_04, mean.pr_05, mean.pr_06, mean.pr_07, mean.pr_08, mean.pr_09, mean.pr_10, mean.pr_11, mean.tmean_04, mean.tmean_05, mean.tmean_06, mean.tmean_07, mean.tmean_08, mean.tmean_09, mean.tmean_10, mean.tmean_11, mean.tmin_04, mean.tmin_05, mean.tmin_06, mean.tmin_07, mean.tmin_08, mean.tmin_09, mean.tmin_10, mean.tmin_11, mean.clt_04, mean.clt_05, mean.clt_06, mean.clt_07, mean.clt_08, mean.clt_09, mean.clt_10, mean.clt_11, mean.rsds_04, mean.rsds_05, mean.rsds_06, mean.rsds_07, mean.rsds_08, mean.rsds_09, mean.rsds_10, mean.rsds_11) %>% 
  mutate(Fertilizer = Pct_FertilManure_ha + Pct_FertilChem_ha) %>% 
  mutate(AGType = as.factor(AGType))

boruta <- Boruta(AvgYield ~ ., data = TrainB, maxRuns = 1000)#, doTrace = 2
boruta2 <- Boruta(AvgYield ~ ., data = TrainB2, maxRuns = 1000)#, doTrace = 2
print(boruta)
boruta[["finalDecision"]]
plot(boruta, las = 2, cex.axis = 0.7)
plot(boruta2, las = 2, cex.axis = 0.7)

bor <- TentativeRoughFix(boruta)
bor[["finalDecision"]]
bor2 <- TentativeRoughFix(boruta2)
bor2[["finalDecision"]]

b=attStats(boruta)
b2=attStats(boruta2)

form=getConfirmedFormula(boruta)
```
Pop_Total   
Pop_Urban 
Primary                                
Primary                                Rejected
Pct_Primary                            Rejected
AG_Workers                             Rejected
Pct_AG_Workers                         Rejected
Pct_Rented_ha                          Rejected
Pct_Rest_ha                            Rejected
Pct_Fallow_ha                          Rejected
Pct_FertilManure_ha                    Rejected
Pct_ImprovSeed_ha                      Rejected
Pct_Insecticides_ha                    Rejected
Pct_ControlledBurn_ha                  Rejected
Pct_Tract_Mechaniz_pu                  Rejected
Pct_Tract_Manual_pu                    Rejected
Pct_Pasture_ha                         Rejected
LU_FamLabor                            Rejected
LU_MechanizEquip                       Rejected
LU_DraftAnimals                        Rejected
PopDensRural                           Rejected
Temporal_PU                            Rejected
PopDensRural 






### Subset Agricultural Variables

```{r, label='Subset Agricultural Variables', message=FALSE,warning=FALSE}

Train = Tot %>% select(-Estado_ID, -Municipio_ID) %>% 
  left_join(env_vals, by=c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>%
  select(AGType, Estado, Municipio, EstadoMunicipio, AvgYield, sdYield, cvYield, AvgYieldLoss, sdYieldLoss, cvYieldLoss, Pop_Total, Pop_Urban, UrbRatio, Pct_Primary, Pct_Rented_ha, Pct_Rest_ha, Pct_Fallow_ha, Pct_FertilChem_ha, Pct_FertilManure_ha, Pct_ImprovSeed_ha, Pct_Herbicides_ha, Pct_Insecticides_ha, Pct_ControlledBurn_ha, TotalLabor, TotalLabor_perHa, PctContractLabor, Pct_Pasture_ha, LU_Total, LU_Total_perHa, mean.Slope, mean.Accum, mean.TRI, mean.TWI, mean.STI, mean.SPI, mean.BD, mean.S, mean.Z, mean.C, mean.SOC, mean.CEC, mean.OCD, mean.N, mean.BDRICM, mean.BDTICM, mean.prec_04, mean.prec_05, mean.prec_06, mean.prec_07, mean.prec_08, mean.prec_09, mean.prec_10, mean.prec_11, mean.pr_04, mean.pr_05, mean.pr_06, mean.pr_07, mean.pr_08, mean.pr_09, mean.pr_10, mean.pr_11, mean.tmean_04, mean.tmean_05, mean.tmean_06, mean.tmean_07, mean.tmean_08, mean.tmean_09, mean.tmean_10, mean.tmean_11, mean.tmin_04, mean.tmin_05, mean.tmin_06, mean.tmin_07, mean.tmin_08, mean.tmin_09, mean.tmin_10, mean.tmin_11, mean.clt_04, mean.clt_05, mean.clt_06, mean.clt_07, mean.clt_08, mean.clt_09, mean.clt_10, mean.clt_11, mean.rsds_04, mean.rsds_05, mean.rsds_06, mean.rsds_07, mean.rsds_08, mean.rsds_09, mean.rsds_10, mean.rsds_11)%>%
  mutate(AGType = as.factor(AGType))

Temp = Train %>% filter(AGType == "Temporal") %>% select(-AGType)
Irrig = Train %>% filter(AGType == "Riego") %>% select(-AGType)

```






# Random Forest Model

When using a Random Forest model, there are several approaches you can employ to narrow down the variables used as input. These methods can help improve the model's performance, reduce overfitting, and enhance interpretability. Here are some commonly used approaches:

Feature Importance: Random Forest models provide a measure of feature importance, which indicates the relative contribution of each variable in predicting the target variable. You can use these importance scores to identify the most influential variables and select only the top-ranked ones for your model.

Recursive Feature Elimination (RFE): RFE is an iterative process that starts with all variables and progressively eliminates the least important ones. It trains the model on a subset of features, calculates their importance, and removes the least important feature. The process is repeated until a desired number of features is reached or a specified stopping criterion is met.

Selecting a Threshold: You can set a threshold for feature importance and select variables that exceed that threshold. This approach allows you to include only the most relevant variables in your model, discarding those with lower importance.

Correlation Analysis: Identify variables that have a high correlation with the target variable and retain those while eliminating highly correlated variables among themselves. This helps reduce redundancy and focuses on variables that have a stronger relationship with the target.

Domain Knowledge and Expert Opinion: Leverage your domain knowledge or consult subject matter experts to identify variables that are most likely to impact the target variable. This approach can help you narrow down the variables and focus on those that are known to be relevant in the specific context.

Stepwise Selection: Implement a stepwise selection algorithm, such as forward selection, backward elimination, or a combination of both. These methods iteratively add or remove variables based on statistical metrics like p-values, AIC, or BIC, to find the optimal subset of variables for your model.

L1 Regularization (LASSO): Apply L1 regularization, such as the LASSO (Least Absolute Shrinkage and Selection Operator), which can shrink the coefficients of irrelevant variables to zero, effectively excluding them from the model.

It is important to note that the selection of variables should be guided by the specific problem, the available data, and the goals of your analysis. Experimentation, validation, and careful consideration of the trade-offs between model complexity and performance are crucial in determining the final set of variables for your Random Forest model.
```{r}

train <- na.omit(train)


rf_yield <- ranger(formula=form, data = Train, num.trees = 1000, importance='impurity', write.forest = TRUE)

print(m.lzn.ra)

test_out <- predict(rf,test)
test$predicted <- test_out$predictions
test$error <- test$predicted - test$Maize

rsq <- 1 - (sd(test$error^2)/sd(test$Maize^2))
mse <- mean(test$error^2)
rmse <- sqrt(mse)
mae <- mean(abs(test$error))

{print(paste("Rsq:", rsq))
print(paste("RMSE:", rmse))
print(paste("MAE:", mae))}


null_irrigation <- all[["Slope"]]
null_irrigation[null_irrigation == null_irrigation] <- 0
null_fert <- null_irrigation
nulls <- stack(null_irrigation,null_fert)
names(nulls) <- c('Irr','Fert')


names(all) <- str_replace(names(all),"\\..*","")


n <- c(names(nulls),names(all))
n <- str_replace(names(n),"\\..*","")

predictors <- stack(nulls,all)

aoi <- extent(2710000,2950000,780000,950000)

predictors <- crop(predictors,aoi)
for (i in 1:nlayers(predictors)){
predictors[[i]] <- na.roughfix(predictors[[i]])
}

predictors <-approxNA(predictors)

output <- predict(rf,as.matrix(predictors),type="response")

new <- predictors[[1]]
new[1:length(new)] <- output$predictions


steep <- predictors[["Slope"]]
new[steep >= 7] <- 0
new[new > 2000] <- 2000

plot(new)

lake <- readOGR(dsn = "A:/Regional_Datasets/GIS/Lake_Texcoco",
layer = "Lake_Texcoco")
lake <- spTransform(lake,crs(new))
plot(lake,add=TRUE,col="cyan")

```





