---
title: "Aztec Agricultural Productivity Model"
subtitle: "Part 3: Random Forest Model"
author: "Rudolf Cesaretti"
date: "Last run on `r Sys.Date()`"
output:
  html_document:
    toc: true
    df_print: paged
    number_sections: true
bibliography: References.bib
csl: apa.csl
link-citations: yes
---

```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 300px;
}
```



```{r, setup, include=FALSE,echo=FALSE, message=FALSE,warning=FALSE}
require(knitr)
# Set so that long lines in R will be wrapped:
opts_chunk$set(tidy.opts=list(width.cutoff=75),tidy=TRUE)
#
rm(list = ls())
```

I do four things in this R markdown document: 
Topographic/environmental metrics

  1. Calculate catchment area variables, including
      + Topographic/environmental metrics
      + 
  4. Reorganize the data and export for Script #6
  
  
# Setup 

All of the data and scripts are downloadable from the [new ASU SettlementPersist2022 github repository](https://https://github.com/rcesaret/ASUSettlementPersist2022), which can be downloaded locally as a .zip folder or cloned to your own account.

Either way, once you have done so, you will need to modify the working directory (setwd("C:/...)") path and "dir" variables in the code chunk below to match the repository location on your computer.

```{r, label='Set Local Directory Location', message=FALSE,warning=FALSE}

wd <- list()

#SET YOUR LOCAL DIRECTORY LOCATION HERE:
wd$dir <- "D:/Dropbox (ASU)/AztecAgricultureModel/AztecAgriculture/"
#wd$dir <- "C:/Users/TJ McMote/Dropbox (ASU)/AztecAgricultureModel/AztecAgriculture/"

wd$analysis <- paste0(wd$dir,"analysis/")
wd$data_r <- paste0(wd$dir,"data-raw/")
wd$data_p <- paste0(wd$dir,"data-processed/")
wd$data_f <- paste0(wd$dir,"data-final-outputs/")
wd$figs <- paste0(wd$dir,"figures/")
wd$funcs <- paste0(wd$dir,"functions/")

```



## Load R Packages and Custom Functions



```{r, label='Load Libraries', message=FALSE,warning=FALSE}
# Package names
packages <- c("tidyverse", "rgdal", "rgeos", "sp", "sf", "GISTools", "raster", 
              "Matrix", "terra","gdistance", "lwgeom", "tidyr", "stars", 
              "dismo", "purrr", "spatialEco", "whitebox", "classInt",
              "ggnewscale", "lbmech", "data.table", "tidyterra","gridExtra", 
              "cowplot", "scam", "rmarkdown", "spatialreg","spdep", "ggridges", 
              "ggnewscale", "scales", "ggstatsplot", "stringi", "fuzzyjoin", 
              "mgcv", "randomForest", "ranger", "exactextractr", "kableExtra",
              "goft", "MASS", "NSM3", "ggsn", "rlang", "FSA", "philentropy", 
              "sfdep","spdep", "Boruta", "mlbench", "caret", "DataExplorer", "tableone")

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# load packages
invisible(lapply(packages, library, character.only = TRUE))

rm(packages,installed_packages)

#Read in custom R functions located in the wd$funcs directory folder
FUNCS <- list("RescaleSpatRast.R", "Terra_df.R", "RF_ImputeRast.R", "linear_rescale.R", "CMex_AG_Map.R")
invisible(lapply(FUNCS, function(x) source(paste0(wd$funcs,x))))
rm(FUNCS)

```


# Rescale Yields


## Create Data


```{r}

# Read-in the SIAP 2003-2021 Yield Data
SIAP <- read.csv(paste0(wd$data_r,"Cierre_agricola_mun_2003_2021.csv"))


SIAP_2 = SIAP %>% 
  # restrict dataset to the Mexican states located in the CMex focal region
  filter(Estado == "Ciudad de Mexico / DF" | 
         Estado == "Ciudad de Mexico" |
         Estado == "Mexico" |
         Estado == "Puebla" |
         Estado == "Morelos" |
         Estado == "Hidalgo" |
         Estado == "Tlaxcala") %>% 
  # Change some string names in the data to be congruent with the other agricultural data
  mutate_all(~ str_replace_all(., c("Ciudad de Mexico / DF" = "Distrito Federal", 
                                    "Ciudad de Mexico" = "Distrito Federal",
                                    "QUECHOLAC" = "Quecholac",
                                    "alvaro Obregon" = "Alvaro Obregon", 
                                    "General Felipe angeles" = "General Felipe Angeles",
                                    " De " = " de ", 
                                    " Del " = " del ", 
                                    " La " = " la ", 
                                    " Las " = " las ", 
                                    " Los " = " los ",
                                    " El " = " el ",
                                    "Ziltlaltepec" = "Zitlaltepec",
                                    "Atltzayanca" = "Altzayanca"))) %>%
  unite(col = EstadoMunicipio, Municipio, Estado, sep = ", ", remove = F) %>%
  # Change incorrectly-designated character variables to numeric
  mutate(Planted = as.numeric(Planted), Harvested = as.numeric(Harvested),
          Lost = as.numeric(Lost), Product = as.numeric(Product),
          Yield = as.numeric(Yield), Price = as.numeric(Price),
          Value = as.numeric(Value)) %>% 
  mutate(
    # reported yield in the data == Product (tons) / hectares harvested
    Yield_orig = Yield,
    # we want to change the reported yield to == Product (tons) / hectares planted
    # to account for yield loss over the course of the growing season
    Yield = Product / Planted) %>%
    # only consider Spring-Summer crop cycle yields (exclude Autumn-Winter yields)
  filter(Cycle %in% c("Primavera-Verano", "Perennes")) %>%
  mutate(CultigenGroup = case_when(
    Cultigen == "Maiz grano" ~ "Maize",
    Cultigen == "Avena forrajera seca" ~ "Fodder",
    Cultigen == "Pastos y praderas seco" ~ "Fodder",
    Cultigen == "Alfalfa verde" ~ "Fodder",
    Cultigen == "Pastos y praderas" ~ "Fodder",
    Cultigen == "Cebada forrajera en verde" ~ "Fodder",
    Cultigen == "Pastos y praderas achicalado" ~ "Fodder",
    .default = "OtherCrops")) %>%
  group_by(EstadoMunicipio, Year, AGType) %>%
    mutate(Area_AGType = sum(Planted, na.rm=T),
           Area_AGType_Maize = sum(Planted[CultigenGroup == "Maize"], na.rm=T),
           Area_AGType_Maize = ifelse(is.na(Area_AGType_Maize), 0, Area_AGType_Maize),
           Area_AGType_Fodder = sum(Planted[CultigenGroup == "Fodder"], na.rm=T),
           Area_AGType_Fodder = ifelse(is.na(Area_AGType_Fodder), 0, Area_AGType_Fodder),
           Area_AGType_OtherCrops = sum(Planted[CultigenGroup == "OtherCrops"], na.rm=T),
           Area_AGType_OtherCrops = ifelse(is.na(Area_AGType_OtherCrops), 0, Area_AGType_OtherCrops)) %>% ungroup() %>%
  group_by(EstadoMunicipio, Year) %>%
    mutate(Area_Total = sum(Planted, na.rm=T),
           Area_Total_Maize = sum(Planted[CultigenGroup == "Maize"], na.rm=T),
           Area_Total_Maize = ifelse(is.na(Area_Total_Maize), 0, Area_Total_Maize),
           Area_Total_Fodder = sum(Planted[CultigenGroup == "Fodder"], na.rm=T),
           Area_Total_Fodder = ifelse(is.na(Area_Total_Fodder), 0, Area_Total_Fodder),
           Area_Total_OtherCrops = sum(Planted[CultigenGroup == "OtherCrops"], na.rm=T),
           Area_Total_OtherCrops = ifelse(is.na(Area_Total_OtherCrops), 0, Area_Total_OtherCrops)) %>% ungroup() %>%
    mutate(PctArea_Maize_Crops_AGType = Area_AGType_Maize / (Area_AGType_Maize + Area_AGType_OtherCrops),
           PctArea_Maize_AGType = Area_AGType_Maize / (Area_AGType_Maize + Area_AGType_OtherCrops + Area_AGType_Fodder),
           PctArea_Maize_Crops_Total = Area_Total_Maize / (Area_Total_Maize + Area_Total_OtherCrops),
           PctArea_Maize_Total = Area_Total_Maize / (Area_Total_Maize + Area_Total_OtherCrops + Area_Total_Fodder)) %>%
    # filter the data to only include Maize from the spring-summer cycle
    filter(Cultigen == "Maiz grano", Cycle == "Primavera-Verano") %>%
    # convert units -- tons to kg -- for yield, yield loss and product
    mutate(Yield = Yield * 1000, Yield_orig = Yield_orig * 1000, Product = Product* 1000) %>%
    group_by(EstadoMunicipio, Year)

# read-in manually-edited SIAP 2003-2021 ID Data
SIAP_ID <- read.csv(paste0(wd$data_r,"SIAP_ID_EDITS.csv")) %>% 
  # Change some string names in the data to be congruent with the other agricultural data
  mutate_all(~ str_replace_all(., c("Ciudad de Mexico / DF" = "Distrito Federal", 
                                    "Ciudad de Mexico" = "Distrito Federal",
                                    "QUECHOLAC" = "Quecholac",
                                    "alvaro Obregon" = "Alvaro Obregon", 
                                    "General Felipe angeles" = "General Felipe Angeles",
                                    " De " = " de ", 
                                    " Del " = " del ", 
                                    " La " = " la ", 
                                    " Las " = " las ", 
                                    " Los " = " los ",
                                    " El " = " el ",
                                    "Ziltlaltepec" = "Zitlaltepec",
                                    "Atltzayanca" = "Altzayanca")))

rm(SIAP)

# left-join edited SIAP_ID dataframe with SIAP_2 yield data
SIAP_2 = SIAP_2 %>% left_join(SIAP_ID, by = c('Estado_ID', 'Estado', 'ddr_ID', 'ddr', 'Cader_ID', 'Cader', 'Municipio_ID', 'Municipio', 'EstadoMunicipio')) %>% 
  # filter the data to only include states and municipalities in the CMex focal region
  filter(INCLUDE == TRUE) %>%
  # remove a number of municipios that should not be in the CMex focal region dataset
  filter(!(EstadoMunicipio %in% c("Coatetelco, Morelos", "Almoloya de Alquisiras, Mexico", "Amanalco, Mexico", "Iztapalapa, Distrito Federal", "Texcaltitlan, Mexico","Polotitlan, Mexico", "Temascalcingo, Mexico","Villa de Allende, Mexico", "Acambay de Ruiz Castaneda, Mexico", "Aculco, Mexico"))) 


SIAP_3_rs <- SIAP_2 %>% mutate(
  Yield_SIAP = Yield,
  Yield = 10*Yield^0.65,
  Product = Yield * Planted,
  Yield_orig = Product / Harvested,
  YieldLoss = (Product / Harvested) - Yield,
  PctYieldLoss = (1 - (Yield / (Product / Harvested)))*100) %>% rowwise() %>% 
  mutate(YieldLoss = ifelse(YieldLoss < 0, 0, YieldLoss),
      PctYieldLoss = ifelse(PctYieldLoss < 0, 0, PctYieldLoss)) %>% ungroup() %>% 
  group_by(EstadoMunicipio, Year) %>%
    mutate(TotYield = (sum(Product, na.rm=T) / sum(Planted, na.rm=T)) + runif(1, min = 0.0001, max = 0.01),
           TotYield_orig = sum(Product, na.rm=T) / sum(Harvested, na.rm=T),
           TotYieldLoss = TotYield_orig - TotYield,
           TotPctYieldLoss = (1-(TotYield/TotYield_orig))*100) %>% ungroup()

rm(SIAP_2)

SIAP_4_rs = SIAP_3_rs %>% 
  # group the data by state-municipality and agriculture type
  group_by(EstadoMunicipio, AGType) %>% 
  # calculate variables for the maize yield (and yield loss) time-series: mean, standard deviation 
  # and coefficient of variation by state-municipality and agriculture type
  mutate(AvgYield = mean(Yield, na.rm=T), 
         sdYield = sd(Yield, na.rm=T), 
         cvYield = sdYield/AvgYield*100,
         AvgYieldLoss = mean(YieldLoss, na.rm=T), 
         sdYieldLoss = sd(YieldLoss, na.rm=T), 
         cvYieldLoss = sdYieldLoss/AvgYieldLoss*100,
         AvgPctYieldLoss = mean(PctYieldLoss, na.rm=T), 
         sdPctYieldLoss = sd(PctYieldLoss, na.rm=T), 
         cvPctYieldLoss = sdPctYieldLoss/AvgPctYieldLoss*100) %>% 
  # calculate variable for the number of time series cases by state-municipality and agriculture type
  add_tally() %>% 
  # ungroup the data
  ungroup() %>% 
  # calculate the maize yield Z-score by state-municipality and agriculture type
  # using the state-municipality / agriculture type mean and st.dev
  mutate(zYield = (Yield - AvgYield)/sdYield) %>% 
  # group by state-municipality
  group_by(EstadoMunicipio) %>% 
  # calculate variables for the Yield and Yield Loss  mean, standard deviation and 
  # coefficient of variation for each agriculture type by state-municipality
  mutate(AvgYield_Total = mean(unique(TotYield), na.rm=T), #sum(Product, na.rm=T) / sum(Planted, na.rm=T)
         sdYield_Total = sd(unique(TotYield), na.rm=T), 
         cvYield_Total = sdYield_Total/AvgYield_Total*100,
         AvgYield_Irrig = mean(Yield[AGType == "Riego"] , na.rm=T),
         sdYield_Irrig = sd(Yield[AGType == "Riego"] , na.rm=T),
         cvYield_Irrig = sdYield_Irrig/AvgYield_Irrig*100,
         AvgYield_Temp = mean(Yield[AGType == "Temporal"], na.rm=T),
         sdYield_Temp = sd(Yield[AGType == "Temporal"], na.rm=T),
         cvYield_Temp = sdYield_Temp/AvgYield_Temp*100,
         AvgYieldLoss_Total = mean(unique(TotYieldLoss), na.rm=T), 
         sdYieldLoss_Total = sd(unique(TotYieldLoss), na.rm=T), 
         cvYieldLoss_Total = sdYieldLoss_Total/AvgYieldLoss_Total*100,
         AvgYieldLoss_Irrig = mean(YieldLoss[AGType == "Riego"] , na.rm=T),
         sdYieldLoss_Irrig = sd(YieldLoss[AGType == "Riego"] , na.rm=T),
         cvYieldLoss_Irrig = sdYieldLoss_Irrig/AvgYieldLoss_Irrig*100,
         AvgYieldLoss_Temp = mean(YieldLoss[AGType == "Temporal"], na.rm=T),
         sdYieldLoss_Temp = sd(YieldLoss[AGType == "Temporal"], na.rm=T),
         cvYieldLoss_Temp = sdYieldLoss_Temp/AvgYieldLoss_Temp*100,
         AvgPctYieldLoss_Total = mean(unique(TotPctYieldLoss), na.rm=T), 
         sdPctYieldLoss_Total = sd(unique(TotPctYieldLoss), na.rm=T), 
         cvPctYieldLoss_Total = sdPctYieldLoss_Total/AvgPctYieldLoss_Total*100,
         AvgPctYieldLoss_Irrig = mean(PctYieldLoss[AGType == "Riego"] , na.rm=T),
         sdPctYieldLoss_Irrig = sd(PctYieldLoss[AGType == "Riego"] , na.rm=T),
         cvPctYieldLoss_Irrig = sdPctYieldLoss_Irrig/AvgPctYieldLoss_Irrig*100,
         AvgPctYieldLoss_Temp = mean(PctYieldLoss[AGType == "Temporal"], na.rm=T),
         sdPctYieldLoss_Temp = sd(PctYieldLoss[AGType == "Temporal"], na.rm=T),
         cvPctYieldLoss_Temp = sdPctYieldLoss_Temp/AvgPctYieldLoss_Temp*100) %>% 
  # calculate variable for the overall number of time series cases by state-municipality
  add_tally(name = "n_Total") %>% 
  mutate(AvgArea_Irrig = mean(Area_AGType[AGType == "Riego"], na.rm=T),
         sdArea_Irrig = sd(Area_AGType[AGType == "Riego"], na.rm=T),
         cvArea_Irrig = sdArea_Irrig/AvgArea_Irrig*100,
         AvgArea_Irrig_Maize = mean(Area_AGType_Maize[AGType == "Riego"], na.rm=T),
         sdArea_Irrig_Maize = sd(Area_AGType_Maize[AGType == "Riego"], na.rm=T),
         cvArea_Irrig_Maize = sdArea_Irrig_Maize/AvgArea_Irrig_Maize*100,
         AvgArea_Irrig_Fodder = mean(Area_AGType_Fodder[AGType == "Riego"], na.rm=T),
         AvgArea_Irrig_OtherCrops = mean(Area_AGType_OtherCrops[AGType == "Riego"], na.rm=T),
         AvgPctArea_Maize_Crops_Irrig = mean(PctArea_Maize_Crops_AGType[AGType == "Riego"], na.rm=T),
         sdPctArea_Maize_Crops_Irrig = sd(PctArea_Maize_Crops_AGType[AGType == "Riego"], na.rm=T),
         cvPctArea_Maize_Crops_Irrig = sdPctArea_Maize_Crops_Irrig/AvgPctArea_Maize_Crops_Irrig*100,
         AvgPctArea_Maize_Irrig = mean(PctArea_Maize_AGType[AGType == "Riego"], na.rm=T),
         sdPctArea_Maize_Irrig = sd(PctArea_Maize_AGType[AGType == "Riego"], na.rm=T),
         cvPctArea_Maize_Irrig = sdPctArea_Maize_Irrig/AvgPctArea_Maize_Irrig*100,
         AvgArea_Temp = mean(Area_AGType[AGType == "Temporal"], na.rm=T),
         sdArea_Temp = sd(Area_AGType[AGType == "Temporal"], na.rm=T),
         cvArea_Temp = sdArea_Temp/AvgArea_Temp*100,
         AvgArea_Temp_Maize = mean(Area_AGType_Maize[AGType == "Temporal"], na.rm=T),
         sdArea_Temp_Maize = sd(Area_AGType_Maize[AGType == "Temporal"], na.rm=T),
         cvArea_Temp_Maize = sdArea_Temp_Maize/AvgArea_Temp_Maize*100,
         AvgArea_Temp_Fodder = mean(Area_AGType_Fodder[AGType == "Temporal"], na.rm=T),
         AvgArea_Temp_OtherCrops = mean(Area_AGType_OtherCrops[AGType == "Temporal"], na.rm=T),
         AvgPctArea_Maize_Crops_Temp = mean(PctArea_Maize_Crops_AGType[AGType == "Temporal"], na.rm=T),
         sdPctArea_Maize_Crops_Temp = sd(PctArea_Maize_Crops_AGType[AGType == "Temporal"], na.rm=T),
         cvPctArea_Maize_Crops_Temp = sdPctArea_Maize_Crops_Temp/AvgPctArea_Maize_Crops_Temp*100,
         AvgPctArea_Maize_Temp = mean(PctArea_Maize_AGType[AGType == "Temporal"], na.rm=T),
         sdPctArea_Maize_Temp = sd(PctArea_Maize_AGType[AGType == "Temporal"], na.rm=T),
         cvPctArea_Maize_Temp = sdPctArea_Maize_Temp/AvgPctArea_Maize_Temp*100,
         
         AvgArea_Total = mean(Area_AGType, na.rm=T), # It is correct that the _Total = f(_AGType) 
         sdArea_Total = sd(Area_AGType, na.rm=T), # because _AGType has a single value for each row (year + EstadoMunicipio + AGType)
         cvArea_Total = sdArea_Total/AvgArea_Total*100, # while _Total is the average of them per year per EstadoMunicipio
         AvgArea_Total_Maize = mean(Area_AGType_Maize, na.rm=T),
         sdArea_Total_Maize = sd(Area_AGType_Maize, na.rm=T),
         cvArea_Total_Maize = sdArea_Total_Maize/AvgArea_Total_Maize*100,
         AvgArea_Total_Fodder = mean(Area_AGType_Fodder, na.rm=T),
         AvgArea_Total_OtherCrops = mean(Area_AGType_OtherCrops, na.rm=T),
         AvgPctArea_Maize_Crops_Total = mean(PctArea_Maize_Crops_AGType, na.rm=T),
         sdPctArea_Maize_Crops_Total = sd(PctArea_Maize_Crops_AGType, na.rm=T),
         cvPctArea_Maize_Crops_Total = sdPctArea_Maize_Crops_Total/AvgPctArea_Maize_Crops_Total*100,
         AvgPctArea_Maize_Total = mean(PctArea_Maize_AGType, na.rm=T),
         sdPctArea_Maize_Total = sd(PctArea_Maize_AGType, na.rm=T),
         cvPctArea_Maize_Total = sdPctArea_Maize_Total/AvgPctArea_Maize_Total*100) %>%
  # ungroup the data
  ungroup() %>% 
  # calculate additional variables of interest
  mutate(
    # calculate the maize yield and yield loss Z-score by state-municipality for all agriculture types
    zYield_Total = (Yield - AvgYield_Total)/sdYield_Total,
    zYieldLoss_Total = (YieldLoss - AvgYieldLoss_Total)/sdYieldLoss_Total,
    # TTr = "Temporal-to-Total Ratio" == the ratio of avg temporal variable values to the avg total value
    # ITr = "Irrigation-to-Total Ratio" == the ratio of avg irrigation variable values to the avg total value
    ITr_AvgYield = AvgYield_Irrig/AvgYield_Total,
    ITr_AvgYieldLoss = AvgYieldLoss_Irrig/AvgYieldLoss_Total,
    TTr_AvgYield = AvgYield_Temp/AvgYield_Total,
    TTr_AvgYieldLoss = AvgYieldLoss_Irrig/AvgYieldLoss_Total,
    ITr_cvYield = cvYield_Irrig/cvYield_Total,
    ITr_cvYieldLoss = cvYieldLoss_Irrig/cvYieldLoss_Total,
    TTr_cvYield = cvYield_Irrig/cvYield_Total,
    TTr_cvYieldLoss = cvYieldLoss_Irrig/cvYieldLoss_Total)

SIAP_5_rs = SIAP_4_rs %>% 
  # group by all of the ID variables (effectively at the resolution of each agriculture type and state-municipality)
  group_by(Estado_ID, Estado, ddr_ID, ddr, Cader_ID, Cader, Municipio_ID, Municipio, EstadoMunicipio, AGType) %>%
  # summarize the dataset by state-municipality and agriculture type
  summarize(AvgYield = mean(Yield, na.rm=T), # mean/average maize yield
            sdYield = sd(Yield, na.rm=T), # standard deviation of maize yield
            minYield = min(Yield, na.rm=T), # minimum maize yield
            maxYield = max(Yield, na.rm=T), # maximum maize yield
            medYield = median(Yield, na.rm=T), # median maize yield
            cvYield = sd(Yield, na.rm=T)/mean(Yield, na.rm=T)*100, # coefficient of variation of maize yield
            
            AvgYieldLoss = mean(YieldLoss, na.rm=T), # mean/average maize Yield Loss
            sdYieldLoss = sd(YieldLoss, na.rm=T), # standard deviation of maize Yield Loss
            minYieldLoss = min(YieldLoss, na.rm=T), # minimum maize Yield Loss
            maxYieldLoss = max(YieldLoss, na.rm=T), # maximum maize Yield Loss
            medYieldLoss = median(YieldLoss, na.rm=T), # median maize Yield Loss
            cvYieldLoss = sd(YieldLoss, na.rm=T)/mean(YieldLoss, na.rm=T)*100,# coefficient of variation of maize Yield Loss
            
            AvgPctYieldLoss = mean(PctYieldLoss, na.rm=T), # mean/average maize % Yield Loss
            sdPctYieldLoss = sd(PctYieldLoss, na.rm=T), # standard deviation of maize % Yield Loss
            minPctYieldLoss = min(PctYieldLoss, na.rm=T), # minimum maize % Yield Loss
            maxPctYieldLoss = max(PctYieldLoss, na.rm=T), # maximum maize % Yield Loss
            medPctYieldLoss = median(PctYieldLoss, na.rm=T), # median maize % Yield Loss
            cvPctYieldLoss = sd(PctYieldLoss, na.rm=T)/mean(PctYieldLoss, na.rm=T)*100,# coefficient of variation of maize % Yield Loss
            
            AvgPlanted = mean(Planted, na.rm=T), # average hectares planted in maize
            AvgHarvested = mean(Harvested, na.rm=T), # average hectares harvested in maize
            sdHarvested = sd(Harvested, na.rm=T), # standard deviation of hectares planted in maize
            cvHarvested = sdHarvested/AvgHarvested*100, # coefficient of variation of hectares planted in maize
            AvgLost = mean(Lost, na.rm=T), # average number of hectares of maize lost (i.e. planted but not harvested)
            sdLost = sd(Lost, na.rm=T), # standard deviation of hectares of maize lost (i.e. planted but not harvested)
            cvLost = sdLost/AvgLost*100, # coefficient of variation of hectares of maize lost (i.e. planted but not harvested)
            AvgProduct = mean(Product, na.rm=T), # average total kg of maize produced
            AvgValue = mean(Value, na.rm=T), # average total value in $MX of maize produced
            AvgPrice = mean(Price, na.rm=T), # average price per kg in $MX for maize
            n = mean(n, na.rm=T), # number of time series cases by state-municipality and agriculture type
            n_Total = mean(n_Total, na.rm=T), # overall number of time series cases by state-municipality
            
            AvgYield_Total = mean(AvgYield_Total, na.rm=T), # mean maize yield for all agriculture types
            sdYield_Total = mean(sdYield_Total, na.rm=T), # standard deviation of maize yield for all agriculture types
            cvYield_Total = mean(cvYield_Total, na.rm=T), # coefficient of variation of maize yield for all agriculture types
            AvgYield_Irrig = mean(AvgYield_Irrig, na.rm=T), # mean maize yield for irrigated agriculture
            sdYield_Irrig = mean(sdYield_Irrig, na.rm=T), # standard deviation of maize yield for irrigated agriculture
            cvYield_Irrig = mean(cvYield_Irrig, na.rm=T), # coefficient of variation of maize yield for irrigated agriculture
            AvgYield_Temp = mean(AvgYield_Temp, na.rm=T), # mean maize yield for temporal agriculture
            sdYield_Temp = mean(sdYield_Temp, na.rm=T), # standard deviation of maize yield for temporal agriculture
            cvYield_Temp = mean(cvYield_Temp, na.rm=T), # coefficient of variation of maize yield for temporal agriculture
            ITr_AvgYield = mean(ITr_AvgYield, na.rm=T), # irrigation-to-total ratio for mean maize yields
            ITr_cvYield = mean(ITr_cvYield, na.rm=T), # irrigation-to-total ratio for coefficient of variation of maize yields
            TTr_AvgYield = mean(TTr_AvgYield, na.rm=T), # temporal-to-total ratio for mean maize yields
            TTr_cvYield = mean(TTr_cvYield, na.rm=T), # temporal-to-total ratio for coefficient of variation of maize yields
            
            AvgYieldLoss_Total = mean(AvgYieldLoss_Total, na.rm=T), # mean maize yield loss for all agriculture types
            sdYieldLoss_Total = mean(sdYieldLoss_Total, na.rm=T), # standard deviation of maize yield loss for all agriculture types
            cvYieldLoss_Total = mean(cvYieldLoss_Total, na.rm=T), # coefficient of variation of maize yield loss for all agriculture types
            AvgYieldLoss_Irrig = mean(AvgYieldLoss_Irrig, na.rm=T), # mean maize yield loss for irrigated agriculture
            sdYieldLoss_Irrig = mean(sdYieldLoss_Irrig, na.rm=T), # standard deviation of maize yield loss for irrigated agriculture
            cvYieldLoss_Irrig = mean(cvYieldLoss_Irrig, na.rm=T), # coefficient of variation of maize yield loss for irrigated agriculture
            AvgYieldLoss_Temp = mean(AvgYieldLoss_Temp, na.rm=T), # mean maize yield loss for temporal agriculture
            sdYieldLoss_Temp = mean(sdYieldLoss_Temp, na.rm=T), # standard deviation of maize yield loss for temporal agriculture
            cvYieldLoss_Temp = mean(cvYieldLoss_Temp, na.rm=T), # coefficient of variation of maize yield loss for temporal agriculture
            AvgPctYieldLoss_Total = mean(AvgPctYieldLoss_Total, na.rm=T), # mean % maize yield loss for all agriculture types
            sdPctYieldLoss_Total = mean(sdPctYieldLoss_Total, na.rm=T), # standard deviation of % maize yield loss for all agriculture types
            cvPctYieldLoss_Total = mean(cvPctYieldLoss_Total, na.rm=T), # coefficient of variation of % maize yield loss for all agriculture types
            AvgPctYieldLoss_Irrig = mean(AvgPctYieldLoss_Irrig, na.rm=T), # mean % maize yield loss for irrigated agriculture
            sdPctYieldLoss_Irrig = mean(sdPctYieldLoss_Irrig, na.rm=T), # standard deviation of % maize yield loss for irrigated agriculture
            cvPctYieldLoss_Irrig = mean(cvPctYieldLoss_Irrig, na.rm=T), # coefficient of variation of % maize yield loss for irrigated agriculture
            AvgPctYieldLoss_Temp = mean(AvgPctYieldLoss_Temp, na.rm=T), # mean % maize yield loss for temporal agriculture
            sdPctYieldLoss_Temp = mean(sdPctYieldLoss_Temp, na.rm=T), # standard deviation of % maize yield loss for temporal agriculture
            cvPctYieldLoss_Temp = mean(cvPctYieldLoss_Temp, na.rm=T), # coefficient of variation of % maize yield loss for temporal agriculture
            ITr_AvgYieldLoss = mean(ITr_AvgYieldLoss, na.rm=T), # irrigation-to-total ratio for mean maize yield loss
            ITr_cvYieldLoss = mean(ITr_cvYieldLoss, na.rm=T),# irrigation-to-total ratio for coefficient of variation of maize yield loss
            TTr_AvgYieldLoss = mean(TTr_AvgYieldLoss, na.rm=T), # temporal-to-total ratio for mean maize yield loss
            TTr_cvYieldLoss = mean(TTr_cvYieldLoss, na.rm=T),# temporal-to-total ratio for coefficient of variation of maize yield loss
            
         AvgArea_Irrig = mean(Area_AGType[AGType == "Riego"], na.rm=T),
         sdArea_Irrig = sd(Area_AGType[AGType == "Riego"], na.rm=T),
         cvArea_Irrig = sdArea_Irrig/AvgArea_Irrig*100,
         AvgArea_Irrig_Maize = mean(Area_AGType_Maize[AGType == "Riego"], na.rm=T),
         sdArea_Irrig_Maize = sd(Area_AGType_Maize[AGType == "Riego"], na.rm=T),
         cvArea_Irrig_Maize = sdArea_Irrig_Maize/AvgArea_Irrig_Maize*100,
         AvgArea_Irrig_Fodder = mean(Area_AGType_Fodder[AGType == "Riego"], na.rm=T),
         AvgArea_Irrig_OtherCrops = mean(Area_AGType_OtherCrops[AGType == "Riego"], na.rm=T),
         AvgPctArea_Maize_Crops_Irrig = mean(PctArea_Maize_Crops_AGType[AGType == "Riego"], na.rm=T),
         sdPctArea_Maize_Crops_Irrig = sd(PctArea_Maize_Crops_AGType[AGType == "Riego"], na.rm=T),
         cvPctArea_Maize_Crops_Irrig = sdPctArea_Maize_Crops_Irrig/AvgPctArea_Maize_Crops_Irrig*100,
         AvgPctArea_Maize_Irrig = mean(PctArea_Maize_AGType[AGType == "Riego"], na.rm=T),
         sdPctArea_Maize_Irrig = sd(PctArea_Maize_AGType[AGType == "Riego"], na.rm=T),
         cvPctArea_Maize_Irrig = sdPctArea_Maize_Irrig/AvgPctArea_Maize_Irrig*100,
         AvgArea_Temp = mean(Area_AGType[AGType == "Temporal"], na.rm=T),
         sdArea_Temp = sd(Area_AGType[AGType == "Temporal"], na.rm=T),
         cvArea_Temp = sdArea_Temp/AvgArea_Temp*100,
         AvgArea_Temp_Maize = mean(Area_AGType_Maize[AGType == "Temporal"], na.rm=T),
         sdArea_Temp_Maize = sd(Area_AGType_Maize[AGType == "Temporal"], na.rm=T),
         cvArea_Temp_Maize = sdArea_Temp_Maize/AvgArea_Temp_Maize*100,
         AvgArea_Temp_Fodder = mean(Area_AGType_Fodder[AGType == "Temporal"], na.rm=T),
         AvgArea_Temp_OtherCrops = mean(Area_AGType_OtherCrops[AGType == "Temporal"], na.rm=T),
         AvgPctArea_Maize_Crops_Temp = mean(PctArea_Maize_Crops_AGType[AGType == "Temporal"], na.rm=T),
         sdPctArea_Maize_Crops_Temp = sd(PctArea_Maize_Crops_AGType[AGType == "Temporal"], na.rm=T),
         cvPctArea_Maize_Crops_Temp = sdPctArea_Maize_Crops_Temp/AvgPctArea_Maize_Crops_Temp*100,
         AvgPctArea_Maize_Temp = mean(PctArea_Maize_AGType[AGType == "Temporal"], na.rm=T),
         sdPctArea_Maize_Temp = sd(PctArea_Maize_AGType[AGType == "Temporal"], na.rm=T),
         cvPctArea_Maize_Temp = sdPctArea_Maize_Temp/AvgPctArea_Maize_Temp*100,
         
         AvgArea_Total = mean(Area_AGType, na.rm=T), # It is correct that the _Total = f(_AGType) 
         sdArea_Total = sd(Area_AGType, na.rm=T), # because _AGType has a single value for each row (year + EstadoMunicipio + AGType)
         cvArea_Total = sdArea_Total/AvgArea_Total*100, # while _Total is the average of them per year per EstadoMunicipio
         AvgArea_Total_Maize = mean(Area_AGType_Maize, na.rm=T),
         sdArea_Total_Maize = sd(Area_AGType_Maize, na.rm=T),
         cvArea_Total_Maize = sdArea_Total_Maize/AvgArea_Total_Maize*100,
         AvgArea_Total_Fodder = mean(Area_AGType_Fodder, na.rm=T),
         AvgArea_Total_OtherCrops = mean(Area_AGType_OtherCrops, na.rm=T),
         AvgPctArea_Maize_Crops_Total = mean(PctArea_Maize_Crops_AGType, na.rm=T),
         sdPctArea_Maize_Crops_Total = sd(PctArea_Maize_Crops_AGType, na.rm=T),
         cvPctArea_Maize_Crops_Total = sdPctArea_Maize_Crops_Total/AvgPctArea_Maize_Crops_Total*100,
         AvgPctArea_Maize_Total = mean(PctArea_Maize_AGType, na.rm=T),
         sdPctArea_Maize_Total = sd(PctArea_Maize_AGType, na.rm=T),
         cvPctArea_Maize_Total = sdPctArea_Maize_Total/AvgPctArea_Maize_Total*100) %>%
            # ungroup the data
  ungroup() %>% rowwise() %>%
  # Remove NaN values from affected variables
  mutate(cvYieldLoss = ifelse(is.nan(cvYieldLoss), 0, cvYieldLoss),
         cvLost = ifelse(is.nan(cvLost), 0, cvLost)) %>% 
  ungroup()

x = SIAP_4_rs %>% 
  #group_by(Estado_ID, Estado, ddr_ID, ddr, Cader_ID, Cader, Municipio_ID, Municipio, EstadoMunicipio, AGType) %>%
  # group by all of the ID variables (effectively at the resolution of each agriculture type and state-municipality)
  group_by(Estado_ID, Estado, ddr_ID, ddr, Cader_ID, Cader, Municipio_ID, Municipio, EstadoMunicipio, AGType) %>%
  # summarize the dataset by state-municipality and agriculture type
  summarize(AvgYield = mean(Yield, na.rm=T), # mean/average maize yield
            sdYield = sd(Yield, na.rm=T), # standard deviation of maize yield
            minYield = min(Yield, na.rm=T), # minimum maize yield
            maxYield = max(Yield, na.rm=T), # maximum maize yield
            medYield = median(Yield, na.rm=T), # median maize yield
            cvYield = sd(Yield, na.rm=T)/mean(Yield, na.rm=T)*100, # coefficient of variation of maize yield
            
            AvgYieldLoss = mean(YieldLoss, na.rm=T), # mean/average maize Yield Loss
            sdYieldLoss = sd(YieldLoss, na.rm=T), # standard deviation of maize Yield Loss
            minYieldLoss = min(YieldLoss, na.rm=T), # minimum maize Yield Loss
            maxYieldLoss = max(YieldLoss, na.rm=T), # maximum maize Yield Loss
            medYieldLoss = median(YieldLoss, na.rm=T), # median maize Yield Loss
            cvYieldLoss = sd(YieldLoss, na.rm=T)/mean(YieldLoss, na.rm=T)*100,# coefficient of variation of maize Yield Loss
            
            AvgPctYieldLoss = mean(PctYieldLoss, na.rm=T), # mean/average maize Yield Loss
            sdPctYieldLoss = sd(PctYieldLoss, na.rm=T), # standard deviation of maize Yield Loss
            minPctYieldLoss = min(PctYieldLoss, na.rm=T), # minimum maize Yield Loss
            maxPctYieldLoss = max(PctYieldLoss, na.rm=T), # maximum maize Yield Loss
            medPctYieldLoss = median(PctYieldLoss, na.rm=T), # median maize Yield Loss
            cvPctYieldLoss = sd(PctYieldLoss, na.rm=T)/mean(PctYieldLoss, na.rm=T)*100,# coefficient of variation of maize Yield Loss
            
            AvgPlanted = mean(Planted, na.rm=T), # average hectares planted in maize
            sdPlanted = sd(Planted, na.rm=T), # standard deviation of hectares planted in maize
            cvPlanted = sdPlanted/AvgPlanted*100, # coefficient of variation of hectares planted in maize
            AvgHarvested = mean(Harvested, na.rm=T), # average hectares harvested in maize
            sdHarvested = sd(Harvested, na.rm=T), # standard deviation of hectares harvested in maize
            cvHarvested = sdHarvested/AvgHarvested*100, # coefficient of variation of hectares harvested in maize
            AvgLost = mean(Lost, na.rm=T), # average number of hectares of maize lost (i.e. planted but not harvested)
            sdLost = sd(Lost, na.rm=T), # standard deviation of hectares of maize lost (i.e. planted but not harvested)
            cvLost = sdLost/AvgLost*100, # coefficient of variation of hectares of maize lost (i.e. planted but not harvested)
            AvgProduct = mean(Product, na.rm=T), # average total kg of maize produced
            sdProduct = sd(Product, na.rm=T), # standard deviation of total kg of maize produced
            cvProduct = sdProduct/AvgProduct*100, # coefficient of variation of total kg of maize produced
            AvgValue = mean(Value, na.rm=T), # average total value in $MX of maize produced
            sdValue = sd(Value, na.rm=T), # standard deviation of total value in $MX of maize produced
            cvValue = sdValue/AvgValue*100, # coefficient of variation of total value in $MX of maize produced
            AvgPrice = mean(Price, na.rm=T), # average price per kg in $MX for maize
            sdPrice = sd(Price, na.rm=T), # standard deviation of price per kg in $MX for maize
            cvPrice = sdPrice/AvgPrice*100, # coefficient of variation of price per kg in $MX for maize
            n = mean(n, na.rm=T),# number of time series cases by state-municipality and agriculture type
            AvgArea = mean(Area_AGType, na.rm=T), # It is correct that the _Total = f(_AGType) 
            sdArea = sd(Area_AGType, na.rm=T), # because _AGType has a single value for each row (year + EstadoMunicipio + AGType)
            cvArea = sdArea/AvgArea*100, # while _Total is the average of them per year per EstadoMunicipio
            AvgArea_Maize = mean(Area_AGType_Maize, na.rm=T),
            sdArea_Maize = sd(Area_AGType_Maize, na.rm=T),
            cvArea_Maize = sdArea_Maize/AvgArea_Maize*100,
            AvgArea_Fodder = mean(Area_AGType_Fodder, na.rm=T),
            AvgArea_OtherCrops = mean(Area_AGType_OtherCrops, na.rm=T),
            AvgPctArea_Maize_Crops = mean(PctArea_Maize_Crops_AGType, na.rm=T),
            sdPctArea_Maize_Crops = sd(PctArea_Maize_Crops_AGType, na.rm=T),
            cvPctArea_Maize_Crops = sdPctArea_Maize_Crops/AvgPctArea_Maize_Crops*100,
            AvgPctArea_Maize = mean(PctArea_Maize_AGType, na.rm=T),
            sdPctArea_Maize = sd(PctArea_Maize_AGType, na.rm=T),
            cvPctArea_Maize = sdPctArea_Maize/AvgPctArea_Maize*100)

SIAP_6_rs = SIAP_4_rs %>% 
  # group by all of the ID variables (effectively at the resolution of each agriculture type and state-municipality)
  group_by(Estado_ID, Estado, ddr_ID, ddr, Cader_ID, Cader, Municipio_ID, Municipio, EstadoMunicipio) %>%
  # summarize the dataset by state-municipality and agriculture type
  summarize(AGType = "Total",
            AvgYield = mean(Yield, na.rm=T), # mean/average maize yield
            sdYield = sd(Yield, na.rm=T), # standard deviation of maize yield
            minYield = min(Yield, na.rm=T), # minimum maize yield
            maxYield = max(Yield, na.rm=T), # maximum maize yield
            medYield = median(Yield, na.rm=T), # median maize yield
            cvYield = sd(Yield, na.rm=T)/mean(Yield, na.rm=T)*100, # coefficient of variation of maize yield
            
            AvgYieldLoss = mean(YieldLoss, na.rm=T), # mean/average maize Yield Loss
            sdYieldLoss = sd(YieldLoss, na.rm=T), # standard deviation of maize Yield Loss
            minYieldLoss = min(YieldLoss, na.rm=T), # minimum maize Yield Loss
            maxYieldLoss = max(YieldLoss, na.rm=T), # maximum maize Yield Loss
            medYieldLoss = median(YieldLoss, na.rm=T), # median maize Yield Loss
            cvYieldLoss = sd(YieldLoss, na.rm=T)/mean(YieldLoss, na.rm=T)*100,# coefficient of variation of maize Yield Loss
            
            AvgPctYieldLoss = mean(PctYieldLoss, na.rm=T), # mean/average maize Yield Loss
            sdPctYieldLoss = sd(PctYieldLoss, na.rm=T), # standard deviation of maize Yield Loss
            minPctYieldLoss = min(PctYieldLoss, na.rm=T), # minimum maize Yield Loss
            maxPctYieldLoss = max(PctYieldLoss, na.rm=T), # maximum maize Yield Loss
            medPctYieldLoss = median(PctYieldLoss, na.rm=T), # median maize Yield Loss
            cvPctYieldLoss = sd(PctYieldLoss, na.rm=T)/mean(PctYieldLoss, na.rm=T)*100,# coefficient of variation of maize Yield Loss
            
            AvgPlanted = mean(Planted, na.rm=T), # average hectares planted in maize
            sdPlanted = sd(Planted, na.rm=T), # standard deviation of hectares planted in maize
            cvPlanted = sdPlanted/AvgPlanted*100, # coefficient of variation of hectares planted in maize
            AvgHarvested = mean(Harvested, na.rm=T), # average hectares harvested in maize
            sdHarvested = sd(Harvested, na.rm=T), # standard deviation of hectares harvested in maize
            cvHarvested = sdHarvested/AvgHarvested*100, # coefficient of variation of hectares harvested in maize
            AvgLost = mean(Lost, na.rm=T), # average number of hectares of maize lost (i.e. planted but not harvested)
            sdLost = sd(Lost, na.rm=T), # standard deviation of hectares of maize lost (i.e. planted but not harvested)
            cvLost = sdLost/AvgLost*100, # coefficient of variation of hectares of maize lost (i.e. planted but not harvested)
            AvgProduct = mean(Product, na.rm=T), # average total kg of maize produced
            sdProduct = sd(Product, na.rm=T), # standard deviation of total kg of maize produced
            cvProduct = sdProduct/AvgProduct*100, # coefficient of variation of total kg of maize produced
            AvgValue = mean(Value, na.rm=T), # average total value in $MX of maize produced
            sdValue = sd(Value, na.rm=T), # standard deviation of total value in $MX of maize produced
            cvValue = sdValue/AvgValue*100, # coefficient of variation of total value in $MX of maize produced
            AvgPrice = mean(Price, na.rm=T), # average price per kg in $MX for maize
            sdPrice = sd(Price, na.rm=T), # standard deviation of price per kg in $MX for maize
            cvPrice = sdPrice/AvgPrice*100, # coefficient of variation of price per kg in $MX for maize
            n = n(),# number of time series cases by state-municipality and agriculture type
            AvgArea = mean(Area_AGType, na.rm=T), # It is correct that the _Total = f(_AGType) 
            sdArea = sd(Area_AGType, na.rm=T), # because _AGType has a single value for each row (year + EstadoMunicipio + AGType)
            cvArea = sdArea/AvgArea*100, # while _Total is the average of them per year per EstadoMunicipio
            AvgArea_Maize = mean(Area_AGType_Maize, na.rm=T),
            sdArea_Maize = sd(Area_AGType_Maize, na.rm=T),
            cvArea_Maize = sdArea_Maize/AvgArea_Maize*100,
            AvgArea_Fodder = mean(Area_AGType_Fodder, na.rm=T),
            AvgArea_OtherCrops = mean(Area_AGType_OtherCrops, na.rm=T),
            AvgPctArea_Maize_Crops = mean(PctArea_Maize_Crops_AGType, na.rm=T),
            sdPctArea_Maize_Crops = sd(PctArea_Maize_Crops_AGType, na.rm=T),
            cvPctArea_Maize_Crops = sdPctArea_Maize_Crops/AvgPctArea_Maize_Crops*100,
            AvgPctArea_Maize = mean(PctArea_Maize_AGType, na.rm=T),
            sdPctArea_Maize = sd(PctArea_Maize_AGType, na.rm=T),
            cvPctArea_Maize = sdPctArea_Maize/AvgPctArea_Maize*100) %>% 
  ungroup() %>% 
  bind_rows(x) %>% 
  pivot_longer(-c(Estado_ID, Estado, ddr_ID, ddr, Cader_ID, Cader, Municipio_ID, Municipio, EstadoMunicipio, AGType), names_to = "Variable", values_to = "Value") %>% 
  mutate(AGType = case_when(
    AGType == "Riego" ~ "Irrig",
    AGType == "Temporal" ~ "Temp",
    AGType == "Total" ~ "Total")) %>% 
  pivot_wider(names_from = c(Variable, AGType), names_glue = "{Variable}_{AGType}", values_from = Value, values_fill = NA) %>% 
  #rowwise() %>% 
  mutate(
    # Calculate the ratios of irrigated and temporal variables to their state-municipality averages
    ITr_AvgYield = ifelse((AvgYield_Irrig/AvgYield_Total) == 1, NA, AvgYield_Irrig/AvgYield_Total),
    ITr_sdYield = ifelse((sdYield_Irrig/sdYield_Total) == 1, NA, sdYield_Irrig/sdYield_Total),
    ITr_minYield = ifelse((minYield_Irrig/minYield_Total) == 1, NA, minYield_Irrig/minYield_Total),
    ITr_maxYield = ifelse((maxYield_Irrig/maxYield_Total) == 1, NA, maxYield_Irrig/maxYield_Total),
    ITr_medYield = ifelse((medYield_Irrig/medYield_Total) == 1, NA, medYield_Irrig/medYield_Total),
    ITr_cvYield = ifelse((cvYield_Irrig/cvYield_Total) == 1, NA, cvYield_Irrig/cvYield_Total),
    ITr_AvgYieldLoss = ifelse((AvgYieldLoss_Irrig/AvgYieldLoss_Total) == 1, NA, AvgYieldLoss_Irrig/AvgYieldLoss_Total),
    ITr_sdYieldLoss = ifelse((sdYieldLoss_Irrig/sdYieldLoss_Total) == 1, NA, sdYieldLoss_Irrig/sdYieldLoss_Total),
    ITr_minYieldLoss = ifelse((minYieldLoss_Irrig/minYieldLoss_Total) == 1, NA, minYieldLoss_Irrig/minYieldLoss_Total),
    ITr_maxYieldLoss = ifelse((maxYieldLoss_Irrig/maxYieldLoss_Total) == 1, NA, maxYieldLoss_Irrig/maxYieldLoss_Total),
    ITr_medYieldLoss = ifelse((medYieldLoss_Irrig/medYieldLoss_Total) == 1, NA, medYieldLoss_Irrig/medYieldLoss_Total),
    ITr_cvYieldLoss = ifelse((cvYieldLoss_Irrig/cvYieldLoss_Total) == 1, NA, cvYieldLoss_Irrig/cvYieldLoss_Total),
    ITr_AvgPlanted = ifelse((AvgPlanted_Irrig/AvgPlanted_Total) == 1, NA, AvgPlanted_Irrig/AvgPlanted_Total),
    ITr_AvgPctYieldLoss = ifelse((AvgPctYieldLoss_Irrig/AvgPctYieldLoss_Total) == 1, NA, AvgPctYieldLoss_Irrig/AvgPctYieldLoss_Total),
    ITr_sdPctYieldLoss = ifelse((sdPctYieldLoss_Irrig/sdPctYieldLoss_Total) == 1, NA, sdPctYieldLoss_Irrig/sdPctYieldLoss_Total),
    ITr_minPctYieldLoss = ifelse((minPctYieldLoss_Irrig/minPctYieldLoss_Total) == 1, NA, minPctYieldLoss_Irrig/minPctYieldLoss_Total),
    ITr_maxPctYieldLoss = ifelse((maxPctYieldLoss_Irrig/maxPctYieldLoss_Total) == 1, NA, maxPctYieldLoss_Irrig/maxPctYieldLoss_Total),
    ITr_medPctYieldLoss = ifelse((medPctYieldLoss_Irrig/medPctYieldLoss_Total) == 1, NA, medPctYieldLoss_Irrig/medPctYieldLoss_Total),
    ITr_cvPctYieldLoss = ifelse((cvPctYieldLoss_Irrig/cvPctYieldLoss_Total) == 1, NA, cvPctYieldLoss_Irrig/cvPctYieldLoss_Total),
    ITr_AvgPlanted = ifelse((AvgPlanted_Irrig/AvgPlanted_Total) == 1, NA, AvgPlanted_Irrig/AvgPlanted_Total),
    ITr_sdPlanted = ifelse((sdPlanted_Irrig/sdPlanted_Total) == 1, NA, sdPlanted_Irrig/sdPlanted_Total),
    ITr_cvPlanted = ifelse((cvPlanted_Irrig/cvPlanted_Total) == 1, NA, cvPlanted_Irrig/cvPlanted_Total),
    ITr_AvgHarvested = ifelse((AvgHarvested_Irrig/AvgHarvested_Total) == 1, NA, AvgHarvested_Irrig/AvgHarvested_Total),
    ITr_sdHarvested = ifelse((sdHarvested_Irrig/sdHarvested_Total) == 1, NA, sdHarvested_Irrig/sdHarvested_Total),
    ITr_cvHarvested = ifelse((cvHarvested_Irrig/cvHarvested_Total) == 1, NA, cvHarvested_Irrig/cvHarvested_Total),
    ITr_AvgLost = ifelse((AvgLost_Irrig/AvgLost_Total) == 1, NA, AvgLost_Irrig/AvgLost_Total),
    ITr_sdLost = ifelse((sdLost_Irrig/sdLost_Total) == 1, NA, sdLost_Irrig/sdLost_Total),
    ITr_cvLost = ifelse((cvLost_Irrig/cvLost_Total) == 1, NA, cvLost_Irrig/cvLost_Total),
    ITr_AvgProduct = ifelse((AvgProduct_Irrig/AvgProduct_Total) == 1, NA, AvgProduct_Irrig/AvgProduct_Total),
    ITr_sdProduct = ifelse((sdProduct_Irrig/sdProduct_Total) == 1, NA, sdProduct_Irrig/sdProduct_Total),
    ITr_cvProduct = ifelse((cvProduct_Irrig/cvProduct_Total) == 1, NA, cvProduct_Irrig/cvProduct_Total),
    # Calculate the ratio of temporal variables to the state-municipality average
    TTr_AvgYield = ifelse((AvgYield_Temp/AvgYield_Total) == 1, NA, AvgYield_Temp/AvgYield_Total),
    TTr_sdYield = ifelse((sdYield_Temp/sdYield_Total) == 1, NA, sdYield_Temp/sdYield_Total),
    TTr_minYield = ifelse((minYield_Temp/minYield_Total) == 1, NA, minYield_Temp/minYield_Total),
    TTr_maxYield = ifelse((maxYield_Temp/maxYield_Total) == 1, NA, maxYield_Temp/maxYield_Total),
    TTr_medYield = ifelse((medYield_Temp/medYield_Total) == 1, NA, medYield_Temp/medYield_Total),
    TTr_cvYield = ifelse((cvYield_Temp/cvYield_Total) == 1, NA, cvYield_Temp/cvYield_Total),
    TTr_AvgYieldLoss = ifelse((AvgYieldLoss_Temp/AvgYieldLoss_Total) == 1, NA, AvgYieldLoss_Temp/AvgYieldLoss_Total),
    TTr_sdYieldLoss = ifelse((sdYieldLoss_Temp/sdYieldLoss_Total) == 1, NA, sdYieldLoss_Temp/sdYieldLoss_Total),
    TTr_minYieldLoss = ifelse((minYieldLoss_Temp/minYieldLoss_Total) == 1, NA, minYieldLoss_Temp/minYieldLoss_Total),
    TTr_maxYieldLoss = ifelse((maxYieldLoss_Temp/maxYieldLoss_Total) == 1, NA, maxYieldLoss_Temp/maxYieldLoss_Total),
    TTr_medYieldLoss = ifelse((medYieldLoss_Temp/medYieldLoss_Total) == 1, NA, medYieldLoss_Temp/medYieldLoss_Total),
    TTr_cvYieldLoss = ifelse((cvYieldLoss_Temp/cvYieldLoss_Total) == 1, NA, cvYieldLoss_Temp/cvYieldLoss_Total),
    TTr_AvgPctYieldLoss = ifelse((AvgPctYieldLoss_Temp/AvgPctYieldLoss_Total) == 1, NA, AvgPctYieldLoss_Temp/AvgPctYieldLoss_Total),
    TTr_sdPctYieldLoss = ifelse((sdPctYieldLoss_Temp/sdPctYieldLoss_Total) == 1, NA, sdPctYieldLoss_Temp/sdPctYieldLoss_Total),
    TTr_minPctYieldLoss = ifelse((minPctYieldLoss_Temp/minPctYieldLoss_Total) == 1, NA, minPctYieldLoss_Temp/minPctYieldLoss_Total),
    TTr_maxPctYieldLoss = ifelse((maxPctYieldLoss_Temp/maxPctYieldLoss_Total) == 1, NA, maxPctYieldLoss_Temp/maxPctYieldLoss_Total),
    TTr_medPctYieldLoss = ifelse((medPctYieldLoss_Temp/medPctYieldLoss_Total) == 1, NA, medPctYieldLoss_Temp/medPctYieldLoss_Total),
    TTr_cvPctYieldLoss = ifelse((cvPctYieldLoss_Temp/cvPctYieldLoss_Total) == 1, NA, cvPctYieldLoss_Temp/cvPctYieldLoss_Total),
    TTr_AvgPlanted = ifelse((AvgPlanted_Temp/AvgPlanted_Total) == 1, NA, AvgPlanted_Temp/AvgPlanted_Total),
    TTr_sdPlanted = ifelse((sdPlanted_Temp/sdPlanted_Total) == 1, NA, sdPlanted_Temp/sdPlanted_Total),
    TTr_cvPlanted = ifelse((cvPlanted_Temp/cvPlanted_Total) == 1, NA, cvPlanted_Temp/cvPlanted_Total),
    TTr_AvgHarvested = ifelse((AvgHarvested_Temp/AvgHarvested_Total) == 1, NA, AvgHarvested_Temp/AvgHarvested_Total),
    TTr_sdHarvested = ifelse((sdHarvested_Temp/sdHarvested_Total) == 1, NA, sdHarvested_Temp/sdHarvested_Total),
    TTr_cvHarvested = ifelse((cvHarvested_Temp/cvHarvested_Total) == 1, NA, cvHarvested_Temp/cvHarvested_Total),
    TTr_AvgLost = ifelse((AvgLost_Temp/AvgLost_Total) == 1, NA, AvgLost_Temp/AvgLost_Total),
    TTr_sdLost = ifelse((sdLost_Temp/sdLost_Total) == 1, NA, sdLost_Temp/sdLost_Total),
    TTr_cvLost = ifelse((cvLost_Temp/cvLost_Total) == 1, NA, cvLost_Temp/cvLost_Total),
    TTr_AvgProduct = ifelse((AvgProduct_Temp/AvgProduct_Total) == 1, NA, AvgProduct_Temp/AvgProduct_Total),
    TTr_sdProduct = ifelse((sdProduct_Temp/sdProduct_Total) == 1, NA, sdProduct_Temp/sdProduct_Total),
    TTr_cvProduct = ifelse((cvProduct_Temp/cvProduct_Total) == 1, NA, cvProduct_Temp/cvProduct_Total)
    ) %>% ungroup()

rm(x)

write.csv(SIAP_3_rs, paste0(wd$data_r,"SIAP_3_rescale.csv"))

write.csv(SIAP_4_rs, paste0(wd$data_r,"SIAP_4_rescale.csv"))

write.csv(SIAP_5_rs, paste0(wd$data_r,"SIAP_5_rescale.csv"))

write.csv(SIAP_6_rs, paste0(wd$data_r,"SIAP_6_rescale.csv"))

SIAP_5_remove_cases_rs = SIAP_5_rs %>% 
# remove irrigation maize yield cases for some municipalities that lack irrigation agriculture in the land use data
  filter(!(EstadoMunicipio %in% c("Chigmecatitlan, Puebla", 
                                  "Huitzilac, Morelos", 
                                  "San Jose Teacalco, Tlaxcala", 
                                  "Tlalnepantla, Morelos", 
                                  "Totolapan, Morelos", 
                                  "Acajete, Puebla", 
                                  "Almoloya, Hidalgo", 
                                  "Apan, Hidalgo", 
                                  "Atlatlahucan, Morelos", 
                                  "Emiliano Zapata, Hidalgo", 
                                  "Mazatecochco de Jose Maria Morelos, Tlaxcala", 
                                  "San Francisco Tetlanohcan, Tlaxcala", 
                                  "San Pablo del Monte, Tlaxcala", 
                                  "Tolcayuca, Hidalgo", 
                                  "Tonanitla, Mexico", 
                                  "Amaxac de Guerrero, Tlaxcala", 
                                  "Jaltenco, Mexico") & AGType %in% "Riego"))

LU2000e <- st_read(paste0(wd$data_r, "LU2000e.gpkg")) 

SIAP_LU_poly = LU2000e %>% left_join(SIAP_5_remove_cases_rs, by = c("EstadoMunicipio", "AGType")) %>% select(-ddr_ID, -ddr, -Cader_ID, -Cader, -Municipio_ID.y, -Municipio.y, -Estado_ID.y, -Estado.y, -Area_m2) %>% rename( Municipio = Municipio.x, Estado = Estado.x, Estado_ID = Estado_ID.x, Municipio_ID = Municipio_ID.x, AGType_Area_ha = Area_ha)

Census2000s <- read.csv(paste0(wd$data_p,"CensusData2000s.csv")) %>% select(-Estado_ID, -Municipio_ID, -X)
#Census2000s_poly <- st_read(paste0(wd$data_p, "Census2000s_poly.gpkg")) 

Data2000s_poly_rs = SIAP_LU_poly %>% left_join(Census2000s, by = c("EstadoMunicipio", "Estado", "Municipio"))

st_write(Data2000s_poly_rs, paste0(wd$data_p, "Data2000s_poly_rescale.gpkg"), driver = "GPKG", overwrite=TRUE, append=FALSE)

rm(SIAP_5_remove_cases_rs, Census2000s, LU2000e, SIAP_LU_poly)

x = SIAP_4_rs %>% 
  select(Municipio, Estado, EstadoMunicipio, Year, AGType, Harvested, Product) %>%
  group_by(Municipio, Estado, EstadoMunicipio, Year) %>% 
  summarize(AGType = "Total",
    Yield = sum(Product, na.rm=T) / sum(Harvested, na.rm=T))

SIAP_annual_rs = SIAP_4_rs %>% 
  select(Municipio, Estado, EstadoMunicipio, Year, AGType, Yield) %>%
  mutate(AGType = case_when(
    AGType == "Riego" ~ "Irrig",
    AGType == "Temporal" ~ "Temp")) %>% 
  bind_rows(x) %>% 
  pivot_wider(
    names_from = c(Year, AGType),
    names_glue = "Y_{Year}_{AGType}",
    values_from = Yield)

rm(x)

SIAP_averages_rs = SIAP_6_rs %>% select(-Estado_ID, -ddr, -ddr_ID, -Cader, -Cader_ID, -Municipio_ID)

z = SIAP_4_rs %>% 
  select(Municipio, Estado, EstadoMunicipio, Year, AGType, Harvested, Product) %>%
  group_by(Municipio, Estado, EstadoMunicipio, Year) %>% 
  summarize(AGType = "Total",
    Yield = sum(Product, na.rm=T) / sum(Harvested, na.rm=T)) %>% 
  ungroup() %>% 
  group_by(EstadoMunicipio) %>%
  mutate(avg = mean(Yield, na.rm=T),
         sd = sd(Yield, na.rm=T)) %>% ungroup() %>% 
  mutate(Zfluct_Yield = (Yield - avg) / sd) %>%
  ungroup() %>% 
  select(-Yield,-avg,-sd)
  
SIAP_ZFluct_long_rs = SIAP_4_rs %>% 
  select(Municipio, Estado, EstadoMunicipio, Year, AGType, Yield) %>%
  group_by(EstadoMunicipio, AGType) %>%
  mutate(Zfluct_Yield = (Yield - mean(Yield, na.rm=T)) / sd(Yield, na.rm=T)) %>%
  ungroup() %>% 
  select(-Yield) %>% 
  bind_rows(z)

rm(z)

SIAP_ZFluct_rs = SIAP_ZFluct_long_rs %>% 
  mutate(AGType = case_when(
    AGType == "Riego" ~ "Irrig",
    AGType == "Temporal" ~ "Temp",
    AGType == "Total" ~ "Total")) %>% 
  pivot_wider(
    names_from = c(Year, AGType),
    names_glue = "YZf_{Year}_{AGType}",
    values_from = Zfluct_Yield)

rm(SIAP_ZFluct_long_rs)

SIAP_yields_rs = SIAP_annual_rs %>% left_join(SIAP_averages_rs, by = c("Municipio", "Estado", "EstadoMunicipio")) 

rm(SIAP_annual_rs, SIAP_averages_rs)

AGC1960 <- read.csv(paste0(wd$data_p,"AGC1960.csv"))
AGC1970 <- read.csv(paste0(wd$data_p,"AGC1970.csv"))
AGC1991 <- read.csv(paste0(wd$data_p,"AGC1991.csv"))
AGC2007 <- read.csv(paste0(wd$data_p,"AGC2007.csv"))
Municipios2000s <- st_read(paste0(wd$data_p, "Municipios2000s_Data.gpkg"))

scale2 <- function(x) (x - mean(x, na.rm = T)) / sd(x, na.rm = T)
  
MunicipioYields_rs <- Municipios2000s %>% 
  left_join(AGC1960, by = c("Municipio", "Estado", "EstadoMunicipio")) %>%
  left_join(AGC1970, by = c("Municipio", "Estado", "EstadoMunicipio")) %>%
  left_join(AGC1991, by = c("Municipio", "Estado", "EstadoMunicipio")) %>%
  left_join(AGC2007, by = c("Municipio", "Estado", "EstadoMunicipio")) %>%
  left_join(SIAP_yields_rs, by = c("Municipio", "Estado", "EstadoMunicipio")) %>%
  select(-Area_m2)#-AGType.x, -AGType.y, 

MunicipioYields_Z_rs <- MunicipioYields_rs %>% 
  mutate(across(where(is.numeric), scale2)) %>%
  left_join(SIAP_ZFluct_rs, by = c("Municipio", "Estado", "EstadoMunicipio")) %>%
  mutate(CoT_1960_SIAP_dif = AvgYield_Total - Y_1960_Total,
         CoT_1960_SIAP_rat = AvgYield_Total / Y_1960_Total)


MunicipioYields_rs <- MunicipioYields_rs %>% 
  left_join(SIAP_ZFluct_rs, by = c("Municipio", "Estado", "EstadoMunicipio")) %>%
  mutate(CoT_1960_SIAP_dif = AvgYield_Total - Y_1960_Total,
         CoT_1960_SIAP_rat = AvgYield_Total / Y_1960_Total)

st_write(MunicipioYields_rs, paste0(wd$data_p, "MunicipioYields_rs.gpkg"), driver = "GPKG", overwrite=T, append=FALSE)
st_write(MunicipioYields_Z_rs, paste0(wd$data_p, "MunicipioYields_Z_rs.gpkg"), driver = "GPKG", overwrite=T, append=FALSE)

rm(SIAP_ZFluct_rs, AGC1960, AGC1970, AGC1991, AGC2007, Municipios2000s, SIAP_yields_rs, SIAP_ID, rEM, rM)

rm(MunicipioYields_rs, MunicipioYields_Z_rs, SIAP_3_rs, SIAP_4_rs, SIAP_5_rs, SIAP_6_rs, Data2000s_poly_rs)



```
## Load Data


```{r}
SIAP_4_rs <- read.csv(paste0(wd$data_r,"SIAP_4_rescale.csv"))
SIAP_5_rs <- read.csv(paste0(wd$data_r,"SIAP_5_rescale.csv"))
#SIAP_6_rs <- read.csv(paste0(wd$data_r,"SIAP_6_rescale.csv"))
#MunicipioYields_rs <- st_read(paste0(wd$data_p, "MunicipioYields_rs.gpkg"))
MunicipioYields_Z_rs <- st_read(paste0(wd$data_p, "MunicipioYields_Z_rs.gpkg"))
Data2000s_poly_rs <- st_read(paste0(wd$data_p, "Data2000s_poly_rescale.gpkg"))

```


## Histograms


#### Average Yield Histograms

```{r, label='SIAP Yield Histograms', message=FALSE,warning=FALSE}

h1 = ggplot(SIAP_4,aes(x = Yield)) +
  geom_histogram(aes(group = AGType, fill = AGType),alpha = 0.5, position = "identity", binwidth = 300, color = "black") +
  scale_fill_manual(name = "Agriculture Type", values = c("cyan1", "indianred1"), breaks = c("Riego", "Temporal"), labels = c("Irrigation", "Temporal"))+
  geom_density(aes(group = AGType, color = AGType, y=360 * ..count..), adjust = 2, size=1, alpha=0.5)+
  scale_color_manual(name = "Agriculture Type",values = c("cyan2", "firebrick1"), breaks = c("Riego", "Temporal"), labels = c("Irrigation", "Temporal"))+
  labs(x ="Maize Yield (kg / ha)", y = "Count")+
    theme_bw()+
    scale_x_continuous(limits= c(0,12000), breaks=seq(0,12000,2000)) +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="black", size=11), 
          axis.text.y = element_text(color="black", size=11), 
          axis.title.x = element_text(color="black", size=14, face="bold"),
          axis.title.y = element_text(color="black", size=14, face="bold"),
          legend.justification=c(0,1), legend.position=c(0.5,0.85), 
          legend.title=element_blank(),
          legend.box.background = element_rect(colour = "black"),
          legend.text = element_text(colour="black", size = 12),
          legend.background = element_rect(fill="white",size=0.5, linetype="solid", color ="black"))

df = SIAP_4 %>% group_by(EstadoMunicipio, Year) %>% summarize(Yield = sum(Product, na.rm=T) / sum(Planted, na.rm=T))
df$Series <- "Municipal Average"
df2 = SIAP_4 %>% select(EstadoMunicipio, Year, Yield) %>% mutate(Series = "Both Irrigation and Temporal")
df = rbind(df,df2)

h2 = ggplot(df,aes(x = Yield)) +
  geom_histogram(aes(group = Series, fill = Series),alpha = 0.5, position = "identity", binwidth = 300, color = "black") +
  scale_fill_manual(name = "Agriculture Type", values = c("grey75", "greenyellow"), breaks = c("Municipal Average", "Both Irrigation and Temporal"), labels = c("Total", "All"))+
  geom_density(aes(group = Series, color = Series, y=360 * ..count..), adjust = 2, size=1, alpha=0.5)+
  scale_color_manual(name = "Agriculture Type",values = c("black", "green"), breaks = c("Municipal Average", "Both Irrigation and Temporal"), labels = c("Total", "All"))+
  labs(x ="Maize Yield (kg / ha)", y = "Count")+
    theme_bw()+
    scale_x_continuous(limits= c(0,12000), breaks=seq(0,12000,2000)) +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="black", size=11), 
          axis.text.y = element_text(color="black", size=11), 
          axis.title.x = element_text(color="black", size=14, face="bold"),
          axis.title.y = element_text(color="black", size=14, face="bold"),
          legend.justification=c(0,1), legend.position=c(0.5,0.85), 
          legend.title=element_blank(),
          legend.box.background = element_rect(colour = "black"),
          legend.text = element_text(colour="black", size = 12),
          legend.background = element_rect(fill="white",size=0.5, linetype="solid", color ="black"))

ggp2 = plot_grid(h1, h2, labels = c('A', 'B'), label_size = 24)


#save figure
ggsave("Hists_SIAP_AGType_AvgYield.png", plot = ggp2, device = "png", path = wd$figs, scale = 1, width = 8, height = 4.5,   units = "in",  dpi = 1500)

YieldIrrig = SIAP_4 %>% filter(AGType == "Riego") %>% pull(Yield) %>% na.omit
YieldTemp = SIAP_4 %>% filter(AGType == "Temporal") %>% pull(Yield) %>% na.omit
YieldTotal = df %>% filter(Series == "Municipal Average") %>% pull(Yield) %>% na.omit
YieldAll = df %>% filter(Series == "Both Irrigation and Temporal") %>% pull(Yield) %>% na.omit

gamma_test(YieldIrrig[YieldIrrig > 0])
gamma_test(YieldTemp[YieldTemp > 0])
gamma_test(YieldTotal[YieldTotal > 0])
gamma_test(YieldAll[YieldAll > 0])

rm(ggp2, h1, h2, df, df2, YieldIrrig, YieldTemp, YieldTotal, YieldAll)

# import figure for display
knitr::include_graphics(paste0(wd$figs,"Hists_SIAP_AGType_AvgYield.png"), FALSE)
```





#### C.V. Yield Histograms

```{r, label='SIAP CV Yield Histograms', message=FALSE,warning=FALSE}

h1 = ggplot(SIAP_5,aes(x = cvYield)) +
  geom_histogram(aes(group = AGType, fill = AGType),alpha = 0.5, position = "identity", binwidth = 5, color = "black") +
  scale_fill_manual(name = "Agriculture Type", values = c("cyan1", "indianred1"), breaks = c("Riego", "Temporal"), labels = c("Irrigation", "Temporal"))+
  geom_density(aes(group = AGType, color = AGType, y=6.75 * ..count..), adjust = 2, size=1, alpha=0.5)+
  scale_color_manual(name = "Agriculture Type",values = c("cyan2", "firebrick1"), breaks = c("Riego", "Temporal"), labels = c("Irrigation", "Temporal"))+
  labs(x ="C.V. Maize Yield", y = "Count")+
    theme_bw()+
    scale_x_continuous(limits= c(0,160), breaks=seq(0,160,10)) +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="black", size=11), 
          axis.text.y = element_text(color="black", size=11), 
          axis.title.x = element_text(color="black", size=14, face="bold"),
          axis.title.y = element_text(color="black", size=14, face="bold"),
          legend.justification=c(0,1), legend.position=c(0.5,0.85), 
          legend.title=element_blank(),
          legend.box.background = element_rect(colour = "black"),
          legend.text = element_text(colour="black", size = 12),
          legend.background = element_rect(fill="white",size=0.5, linetype="solid", color ="black"))

df = SIAP_6 %>% select(EstadoMunicipio, cvYield_Total) %>% rename(cvYield = cvYield_Total) %>% mutate(Series = "Municipal Average")
df2 = SIAP_5 %>% select(EstadoMunicipio, cvYield) %>% mutate(Series = "Both Irrigation and Temporal")
df = rbind(df,df2)

h2 = ggplot(df,aes(x = cvYield)) +
  geom_histogram(aes(group = Series, fill = Series),alpha = 0.5, position = "identity", binwidth = 5, color = "black") +
  scale_fill_manual(name = "Agriculture Type", values = c("grey75", "greenyellow"), breaks = c("Municipal Average", "Both Irrigation and Temporal"), labels = c("Total", "All"))+
  geom_density(aes(group = Series, color = Series, y=6.75 * ..count..), adjust = 2, size=1, alpha=0.5)+
  scale_color_manual(name = "Agriculture Type",values = c("black", "green"), breaks = c("Municipal Average", "Both Irrigation and Temporal"), labels = c("Total", "All"))+
  labs(x ="C.V. Maize Yield", y = "Count")+
    theme_bw()+
    scale_x_continuous(limits= c(0,160), breaks=seq(0,160,10)) +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="black", size=11), 
          axis.text.y = element_text(color="black", size=11), 
          axis.title.x = element_text(color="black", size=14, face="bold"),
          axis.title.y = element_text(color="black", size=14, face="bold"),
          legend.justification=c(0,1), legend.position=c(0.5,0.85), 
          legend.title=element_blank(),
          legend.box.background = element_rect(colour = "black"),
          legend.text = element_text(colour="black", size = 12),
          legend.background = element_rect(fill="white",size=0.5, linetype="solid", color ="black"))

ggp2 = plot_grid(h1, h2, labels = c('A', 'B'), label_size = 24)


#save figure
ggsave("Hists_SIAP_AGType_cvYield.png", plot = ggp2, device = "png", path = wd$figs, scale = 1, width = 8, height = 4.5,   units = "in",  dpi = 1500)

cvIrrig = SIAP_5 %>% filter(AGType == "Riego") %>% pull(cvYield)
cvTemp = SIAP_5 %>% filter(AGType == "Temporal") %>% pull(cvYield)
cvTotal = df %>% filter(Series == "Municipal Average") %>% pull(cvYield)
cvAll = df %>% filter(Series == "Both Irrigation and Temporal") %>% pull(cvYield)

gamma_test(cvIrrig)
gamma_test(cvTemp)
gamma_test(cvTotal)
gamma_test(cvAll)

rm(ggp2, h1, h2, df, df2, cvIrrig, cvTemp, cvTotal, cvAll)

# import figure for display
knitr::include_graphics(paste0(wd$figs,"Hists_SIAP_AGType_cvYield.png"), FALSE)
```


## Tables

descriptive stats for SIAP 4, 5 rescale vs actual data

```{r}

write.csv(SIAP_2, paste0(wd$data_r,"SIAP_2_RescaleTests.csv"))

Y = SIAP_2$Yield
Y_t = SIAP_2 %>% filter(AGType == "Temporal") %>% pull(Yield)
Y_i = SIAP_2 %>% filter(AGType == "Riego") %>% pull(Yield)

tab = CreateTableOne(vars="Yield", strata="AGType", data=SIAP_2)



fy <- function(x, l, l2 = 0){((x + l2)^l - 1)/l}



hist(Y, breaks=20)
hist((Y^0.89), breaks=25)
hist(log(Y), breaks=20)
hist(1/(Y^0.05), breaks=20)
hist(Y_i, breaks=20)
hist(Y_i^0.95, breaks=20)
#You must compute a linear model with the lm function and pass it to the boxcox function as shown below in order to determine the appropriate “lambda”

```

## Maps

--Rescaled Avg Yield
--Rescaled CV Avg Yield

var = c("sdYield_Total", "minYield_Total", "maxYield_Total", "medYield_Total", "cvYield_Total", "sdYield_Temp", "minYield_Temp", "maxYield_Temp", "medYield_Temp", "cvYield_Temp", "sdYield_Irrig", "minYield_Irrig", "maxYield_Irrig", "medYield_Irrig", "cvYield_Irrig")
tit = "Central Mexico Study Region - SIAP 2003-2021"

subtit = c("Z-Score St.Dev. Total Maize Yield", "Z-Score Minimum Total Maize Yield", "Z-Score Maximum Total Maize Yield", "Z-Score Median Total Maize Yield", "Z-Score C.V. Total Maize Yield", "Z-Score St.Dev. Temporal Maize Yield", "Z-Score Minimum Temporal Maize Yield", "Z-Score Maximum Temporal Maize Yield", "Z-Score Median Temporal Maize Yield", "Z-Score C.V. Temporal Maize Yield", "Z-Score St.Dev. Irrigation Maize Yield", "Z-Score Minimum Irrigation Maize Yield", "Z-Score Maximum Irrigation Maize Yield", "Z-Score Median Irrigation Maize Yield", "Z-Score C.V. Irrigation Maize Yield")
```{r, label='Basemaps', message=FALSE,warning=FALSE}
#geo <- st_geometry(MunicipioYields_Z)
#nb <- st_contiguity(geo)
MunicipioYields_Z_rs <- MunicipioYields_Z_rs %>% 
  mutate(nb = sfdep::st_contiguity(geom),
         wt = sfdep::st_weights(nb, allow_zero = TRUE))

nb <- MunicipioYields_Z_rs$nb
wt <- MunicipioYields_Z_rs$wt

Hillshade <- read_stars(paste0(wd$data_r, "HillshadeCMex.tif"))
Estados <- st_read(paste0(wd$data_r, "StatesPoly.gpkg"))
Estados2 = Estados %>% mutate(my_nudge_x = case_when(
    NOM_ENT == "Mexico" ~ 4000,
    NOM_ENT == "DF" ~ 0,
    NOM_ENT == "Hidalgo" ~ -7000,
    NOM_ENT == "Morelos" ~ 0,
    NOM_ENT == "Puebla" ~ -50000,
    NOM_ENT == "Tlaxcala" ~ 0,
    NOM_ENT == "" ~ 0),
    my_nudge_y = case_when(
    NOM_ENT == "Mexico" ~ 1500,
    NOM_ENT == "DF" ~ 0,
    NOM_ENT == "Hidalgo" ~ 0,
    NOM_ENT == "Morelos" ~ 0,
    NOM_ENT == "Puebla" ~ -65000,
    NOM_ENT == "Tlaxcala" ~ 0,
    NOM_ENT == "" ~ 0))



myPalette <- colorRampPalette(c("red4", "red4", "red4", "red4", "red", "orange", "yellow", "greenyellow", "green", "green4", "green4","green4", "green4"))
#myPalette <- c("red4", "red4", "red", "orange", "yellow", "greenyellow", "green", "green4", "green4")
myBreaks = c(-6, -4, -2, -1,  0, 1, 2, 4, 6)
myLimits = c(-6, 6)
myLegendTitle = "Z-Score\nMaize\nYield" #"Maize\nYield\n(kg/ha)"

```


```{r, label='Average Yields Over Time Maps', message=FALSE, warning=FALSE}

map_list = list()

var = c("Y_1960_Total", "Y_1960_E", "Y_1960_L", "Y_1960_S", "Y_1960_Max","Y_1970_Total", "Y_1970_E", "Y_1970_L", "Y_1970_S", "Y_1970_Max", "Y_1991_Total", "Y_AGC2007_Total", "AvgYield_Total", "AvgYield_Irrig", "AvgYield_Temp")
tit = c("Central Mexico Study Region - 1960 Agricultural Census", "Central Mexico Study Region - 1960 Agricultural Census", "Central Mexico Study Region - 1960 Agricultural Census", "Central Mexico Study Region - 1960 Agricultural Census", "Central Mexico Study Region - 1960 Agricultural Census", "Central Mexico Study Region - 1970 Agricultural Census", "Central Mexico Study Region - 1970 Agricultural Census", "Central Mexico Study Region - 1970 Agricultural Census", "Central Mexico Study Region - 1970 Agricultural Census", "Central Mexico Study Region - 1970 Agricultural Census", "Central Mexico Study Region - 1991 Agricultural Census", "Central Mexico Study Region - 2007 Agricultural Census", "Central Mexico Study Region - SIAP 2003-2021", "Central Mexico Study Region - SIAP 2003-2021", "Central Mexico Study Region - SIAP 2003-2021")
subtit = c("Z-Score Average Overall Maize Yield", "Z-Score Average Ejido Maize Yield", "Z-Score Average Large Farm Maize Yield", "Z-Score Average Small Farm Maize Yield", "Z-Score Max Average Maize Yield","Z-Score Average Overall Maize Yield", "Z-Score Average Ejido Maize Yield", "Z-Score Average Large Farm Maize Yield", "Z-Score Average Small Farm Maize Yield", "Z-Score Max Average Maize Yield", "Z-Score Average Overall Maize Yield", "Z-Score Average Overall Maize Yield", "Z-Score Average Overall Maize Yield", "Z-Score Average Irrigation Maize Yield", "Z-Score Average Temporal Maize Yield")
name=c("Y_1960_Total", "Y_1960_E", "Y_1960_L", "Y_1960_S", "Y_1960_Max", "Y_1970_Total", "Y_1970_E", "Y_1970_L", "Y_1970_S", "Y_1970_Max","Y_1991_Total", "Y_AGC2007_Total", "SIAP_AvgYield_Total", "SIAP_AvgYield_Irrig", "SIAP_AvgYield_Temp")


for (i in 1:length(var)) {
  v = paste0(var[i])
  t = paste0(tit[i])
  s = paste0(subtit[i])
  val = MunicipioYields_Z[[var[i]]]
  map_list[[i]] <- CMex_AG_Map(stars_hillshade = Hillshade, sf1 = MunicipioYields_Z, sf1_aes_string = T, sf1_geom = "geom",
                             sf1_fill = v, sf1_fill_palette = myPalette, sf1_fill_palette_n = 11,
                             sf1_fill_legend_title = myLegendTitle, sf1_fill_legend_limits = myLimits,
                             sf1_fill_legend_breaks = myBreaks, sf2 = Estados, sf2_geom = geom,
                             sf2_label_column = NOM_ENT, sf2_label_nudge_x = Estados2$my_nudge_x, 
                             sf2_label_nudge_y = Estados2$my_nudge_y, mytitle = t, mysubtitle = s, global_moran = T,
                             moran_nb = nb, moran_wt = wt, moran_val = val, moran_box = c(572000, 626450, 2195909, 2252689))
} 
  
names(map_list) <- name

for (i in 1:length(name)) {
  n = paste0(name,".png")[i]
  ggsave(n, plot = map_list[[i]], device = "png", path = wd$figs, scale = 1, width = 6.85, height = 5.257, units = "in",  dpi = 1500)
}

paths <- paste0(wd$figs,paste0("Maps/", name, ".png"))

knitr::include_graphics(paths, FALSE)

rm(nb, wt, paths, names, n, map_list, v, t, s, val, var, tit, subtit, name, myLegendTitle, myPalette, myBreaks, myLimits, Estados2, Estados, Hillshade, MunicipioYields_Z_rs)
```


# Construct RF Training Dataset


## Environmental Raster Data


### Load Environmental Predictor Data from Previous Scripts

```{r, label='Import Data', message=FALSE,warning=FALSE}

#Data2000s_poly <- st_read(paste0(wd$data_p, "Data2000s_poly.gpkg"))
#Data2000s_poly_rs <- st_read(paste0(wd$data_p, "Data2000s_poly_rescale.gpkg"))

Topo <- rast(paste0(wd$data_p, "Topo_r_resampled.tif"))

Soil <- rast(paste0(wd$data_p, "Soil_r_resampled.tif"))

Clim <- rast(paste0(wd$data_p, "Clim_r_resampled.tif"))
#writeRaster(pdsi_ts, filename = paste0(wd$data_p, "pdsi_ts_100m.tif"), overwrite=TRUE)
#writeRaster(pdsi_ts, filename = paste0(wd$data_p, "pdsi_ts_latlon.tif"), overwrite=TRUE)
```


### Subset Raster Data

```{r, label='Subset Environmental Data Rasters', message=FALSE,warning=FALSE}

Soil_sub <- subset(Soil, c("BDRICM", "BDRLOG", "BDTICM", "AWCtS", "AWCtS_2m", "BD", 
                               "S", "Z", "C", "CF", "SOC", "CEC","OCD", "N", "SOCS"))

Topo_sub <- subset(Topo, c("DEM", "Slope","Accum", "TRI", "TWI", "STI", "SPI", 
                                     "curv_min", "curv_max", "curv_mean", "DistStreams", 
                                     "DistStreams2", "ElevAboveStreams", "ElevAboveStreams2",
                                     "elev_watershed", "FloodOrder_Rel"))

pr_spring = app(subset(Clim, c("pr_04", "pr_05")), sum)
pr_summer = app(subset(Clim, c("pr_06", "pr_07","pr_08")), sum)
pr_fall = app(subset(Clim, c("pr_09", "pr_10")), sum)

tas_spring = app(subset(Clim, c("tas_04", "tas_05")), mean)
tas_summer = app(subset(Clim, c("tas_06", "tas_07","tas_08")), mean)
tas_fall = app(subset(Clim, c("tas_09", "tas_10")), mean)

tasmin_spring = app(subset(Clim, c("tasmin_04", "tasmin_05")), mean)
tasmin_summer = app(subset(Clim, c("tasmin_06", "tasmin_07","tasmin_08")), mean)
tasmin_fall = app(subset(Clim, c("tasmin_09", "tasmin_10")), mean)

tasmax_spring = app(subset(Clim, c("tasmax_04", "tasmax_05")), mean)
tasmax_summer = app(subset(Clim, c("tasmax_06", "tasmax_07","tasmax_08")), mean)
tasmax_fall = app(subset(Clim, c("tasmax_09", "tasmax_10")), mean)

pet_spring = app(subset(Clim, c("pet_04", "pet_05")), mean)
pet_summer = app(subset(Clim, c("pet_06", "pet_07","pet_08")), mean)
pet_fall = app(subset(Clim, c("pet_09", "pet_10")), mean)

cmi_spring = app(subset(Clim, c("cmi_04", "cmi_05")), mean)
cmi_summer = app(subset(Clim, c("cmi_06", "cmi_07","cmi_08")), mean)
cmi_fall = app(subset(Clim, c("cmi_09", "cmi_10")), mean)

clt_spring = app(subset(Clim, c("clt_04", "clt_05")), mean)
clt_summer = app(subset(Clim, c("clt_06", "clt_07","clt_08")), mean)
clt_fall = app(subset(Clim, c("clt_09", "clt_10")), mean)

rsds_spring = app(subset(Clim, c("rsds_04", "rsds_05")), mean)
rsds_summer = app(subset(Clim, c("rsds_06", "rsds_07","rsds_08")), mean)
rsds_fall = app(subset(Clim, c("rsds_09", "rsds_10")), mean)

Clim_sub <- subset(Clim, c("npp", "swb", "gdd10"))

Clim_sub <- c(Clim_sub, pr_spring, pr_summer, pr_fall, tas_spring, tas_summer, tas_fall, tasmin_spring, tasmin_summer, tasmin_fall, tasmax_spring, tasmax_summer, tasmax_fall, pet_spring, pet_summer, pet_fall, cmi_spring, cmi_summer, cmi_fall, clt_spring, clt_summer, clt_fall, rsds_spring, rsds_summer, rsds_fall)

names(Clim_sub) <- c("npp", "swb", "gdd10", "pr_spring", "pr_summer", "pr_fall", "tas_spring", "tas_summer", "tas_fall", "tasmin_spring", "tasmin_summer", "tasmin_fall", "tasmax_spring", "tasmax_summer", "tasmax_fall", "pet_spring", "pet_summer", "pet_fall", "cmi_spring", "cmi_summer", "cmi_fall", "clt_spring", "clt_summer", "clt_fall", "rsds_spring", "rsds_summer", "rsds_fall")

writeRaster(Clim_sub, filename = paste0(wd$data_p, "Clim_sub_RF.tif"), overwrite=TRUE)

rm(Clim_sub, pr_spring, pr_summer, pr_fall, tas_spring, tas_summer, tas_fall, tasmin_spring, tasmin_summer, tasmin_fall, tasmax_spring, tasmax_summer, tasmax_fall, pet_spring, pet_summer, pet_fall, cmi_spring, cmi_summer, cmi_fall, clt_spring, clt_summer, clt_fall, rsds_spring, rsds_summer, rsds_fall)

Clim_sub <- rast(paste0(wd$data_p, "Clim_sub_RF.tif"))
```



### Extract Raster Values

```{r, label='Extract Raster Values', message=FALSE,warning=FALSE}

topo_vals <- exact_extract(x = Topo_sub, y = Data2000s_poly_rs, fun = "mean", 
                           max_cells_in_memory = 8e+08, stack_apply=T, 
                           append_cols = c("EstadoMunicipio","Estado", "Municipio", "AGType"))

soil_vals <- exact_extract(x = Soil_sub, y = Data2000s_poly_rs, fun = "mean", 
                           max_cells_in_memory = 8e+08, stack_apply=T, 
                           append_cols = c("EstadoMunicipio","Estado", "Municipio", "AGType"))

clim_vals <- exact_extract(x = Clim_sub, y = Data2000s_poly_rs, fun = "mean", 
                           max_cells_in_memory = 8e+08, stack_apply=T, 
                           append_cols = c("EstadoMunicipio","Estado", "Municipio", "AGType"))

env_vals <- topo_vals %>% left_join(soil_vals, by = c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>% 
                          left_join(clim_vals, by = c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>% 
                          mutate(AGType = as.factor(AGType))
  

#env_vals = merge(topo_vals, soil_vals, all = F, sort = F)

rm(topo_vals, soil_vals, clim_vals)

```



## Agricultural Data

### Select Variables

```{r, label='Prepare Agricultural Data', message=FALSE,warning=FALSE}


```

### Calculate Additional Variables

```{r}
Municipios2000s <- st_read(paste0(wd$data_p, "Municipios2000s_Data.gpkg"))

ArableArea_100m <- rast(paste0(wd$data_p, "ArableArea_100m.tif"))
ArableArea_100m <- as.numeric(ArableArea_100m)
ArableArea_100m <- ifel(ArableArea_100m < 2, 0, 1)

temp = vect(Data2000s_poly_rs)
temp <- terra::rasterize(temp, ArableArea_100m, values = 1, background = 0)

ArableArea_100m = ArableArea_100m + temp
ArableArea_100m <- ifel(ArableArea_100m > 0, 1, 0)

Arable <- exact_extract(x = ArableArea_100m, y = Municipios2000s, fun = "sum", 
                           max_cells_in_memory = 8e+08, stack_apply=T, 
                           append_cols = c("EstadoMunicipio","Estado", "Municipio"))

Arable$Arable_ha <- Arable$sum*98.33216*101.2707/10000
Arable = Arable %>% select(-sum)


x = st_drop_geometry(Data2000s_poly_RS)# %>% filter(-1:3)
x = x %>% filter(!(EstadoMunicipio %in% c("Ixtapaluca, Mexico", "Valle de Chalco Solidaridad, Mexico", "Milpa Alta, Distrito Federal", "Tlahuac, Distrito Federal", "Xochimilco, Distrito Federal", "Axapusco, Mexico") & AGType %in% "Riego"))

#x = x[,-c(1:5)]
#x = as.data.frame(x)
Tot = x %>% select(-AvgYield_Total, -sdYield_Total, -cvYield_Total, 
                   -AvgYield_Irrig, -sdYield_Irrig, -cvYield_Irrig, -AvgYield_Temp, 
                   -sdYield_Temp, -cvYield_Temp, -ITr_AvgYield, -ITr_cvYield, 
                   -AvgYieldLoss_Total, -sdYieldLoss_Total, -cvYieldLoss_Total, 
                   -AvgYieldLoss_Irrig, -sdYieldLoss_Irrig, -cvYieldLoss_Irrig, 
                   -AvgYieldLoss_Temp, -sdYieldLoss_Temp, -cvYieldLoss_Temp, 
                   -ITr_AvgYieldLoss,  -ITr_cvYieldLoss, -minYieldLoss) %>% 
  filter(complete.cases(.))

Accessability to urban pop
Accessability to rural pop
Accessability to arable area
Accessability to pop density
Accessability to % primary
Overall size of arable area and labor force?
% of cultivation irrigated
Accessability to % irrigated / irrigated_ha
Arable Area as denomenator for intensive labor input Metrics

Modifiers for numerator for labor and capital input metrics:
AvgPctArea_Maize_Total
AvgPctArea_Maize_Crops_Total

AvgPctArea_Maize_Temp
AvgPctArea_Maize_Crops_Temp
AvgArea_Irrig
AvgArea_Irrig_Maize
AvgPctArea_Maize_Crops_Irrig
AvgPctArea_Maize_Irrig
AvgPctArea_Maize_Crops_Temp
AvgPctArea_Maize_Temp
AvgArea_Total
AvgArea_Total_Maize
AvgArea_Temp_Maize
AvgArea_Temp
Reigo_ha
Temporal_ha
Area_ha
Techniques
Fertilizer
LU_Total
LU_Total_perHa
PopDens
Pop_Urban
Pop_Rural
Pop_Pct_Rural
Primary
AG_Workers
AGType_Area_ha

AGType (MAKE SURE ITS A FACTOR)

DEPENDENT VARS = 
  AvgYield
  cvYield
# Find rows with NA, NaN, or Inf values
#rows_with_na <- apply(Tot, 1, function(row) any(is.na(row) | is.nan(row) | is.infinite(row)))
  
# Find columns with NA, NaN, or Inf values
#columns_with_na <- apply(Tot, 2, function(column) any(is.na(column) | is.nan(column) | is.infinite(column)))

# Print the rows and columns with NA, NaN, or Inf values
#cat("Rows with NA, NaN, or Inf values:\n")
#print(which(rows_with_na))
#cat("\n")
#cat("Columns with NA, NaN, or Inf values:\n")
#print(which(columns_with_na))
```

### Remove Cases
Teotihuacan, Mexico
Otumba, Mexico
Tezoyuca, Mexico
San Martin de las Piramides, Mexico
Acolman, Mexico
```{r}


#Remove Irrigation
E_TLAXCALA = c("Emiliano Zapata, Tlaxcala", "Lazaro Cardenas, Tlaxcala", "Terrenate, Tlaxcala", "Xaloztoc, Tlaxcala", "Tzompantepec, Tlaxcala", "Tocatlan, Tlaxcala", "Huamantla, Tlaxcala", "Altzayanca, Tlaxcala", "Cuapiaxtla, Tlaxcala", "El Carmen Tequexquitla, Tlaxcala", "Zitlaltepec de Trinidad Sanchez Santos, Tlaxcala", "Ixtenco, Tlaxcala", "Nopalucan, Puebla", "Rafael Lara Grajales, Puebla", "Soltepec, Puebla", "Mazapiltepec de Juarez, Puebla","San Jose Chiapa, Puebla")

Remove_Irrigation = c("Chicoloapan, Mexico", "Chimalhuacan, Mexico", "Atenco, Mexico", "Chiconcuac, Mexico", "Ecatepec de Morelos, Mexico", "Coacalco de Berriozabal, Mexico", "Papalotla, Mexico")

#RESCALE Irrigation
S_HIDALGO = c("Mixquiahuala de Juarez, Hidalgo", "Tezontepec de Aldama, Hidalgo", "Tepetitlan, Hidalgo", "Tula de Allende, Hidalgo", "Tepeji del Rio de Ocampo, Hidalgo", "Tlaxcoapan, Hidalgo", "Tlahuelilpan, Hidalgo", "Atitalaquia, Hidalgo", "Atotonilco de Tula, Hidalgo", "Francisco I. Madero, Hidalgo", "Tetepango, Hidalgo", "Ajacuba, Hidalgo", "Tetepango, Hidalgo")

Remove_Temporal = c("Milpa Alta, Distrito Federal", "Tlalpan, Distrito Federal", "Xochimilco, Distrito Federal", "Tlahuac, Distrito Federal", "La Magdalena Contreras, Distrito Federal", "Alvaro Obregon, Distrito Federal", "Cuajimalpa de Morelos, Distrito Federal", "Jilotzingo, Mexico", "Naucalpan de Juarez, Mexico", "Atizapan de Zaragoza, Mexico", "Tlalnepantla de Baz, Mexico", "Coacalco de Berriozabal, Mexico", "Jaltenco, Mexico", "Coyotepec, Mexico", "La Paz, Mexico", "Chimalhuacan, Mexico", "Domingo Arenas, Puebla", "San Felipe Teotlalcingo, Puebla", "Puebla, Puebla") #"Chicoloapan, Mexico", "Ixtapaluca, Mexico"
y = env_vals %>% select(-Estado, -Municipio)

x = st_drop_geometry(Data2000s_poly_rs) %>% select(EstadoMunicipio, Estado, Municipio, AvgYield, cvYield, AGType, LU_Total_perHa, AvgPctArea_Maize_Total, AvgPctArea_Maize_Crops_Total, PopDens, Pop_Urban, TotalLaborDens, PopDensRural, Pop_Rural, UrbRatio, Pct_Primary, Pct_AG_Workers, Techniques, Fertilizer, AG_Workers_perHa, LU_Total) %>% left_join(Arable, by = c("EstadoMunicipio","Estado", "Municipio")) %>% filter(!(EstadoMunicipio %in% c("Ixtapaluca, Mexico", "Valle de Chalco Solidaridad, Mexico", "Milpa Alta, Distrito Federal", "Tlahuac, Distrito Federal", "Xochimilco, Distrito Federal", "Axapusco, Mexico") & AGType %in% "Riego")) %>% filter(!(EstadoMunicipio %in% E_TLAXCALA & AGType %in% "Riego")) %>% filter(!(EstadoMunicipio %in% Remove_Irrigation & AGType %in% "Riego")) %>% filter(!(EstadoMunicipio %in% Remove_Temporal & AGType %in% "Temporal"))  %>% left_join(y, by = c("EstadoMunicipio", "AGType")) %>% mutate(AGType = factor(AGType, levels = c("Temporal", "Riego")))

zzz = x %>% select(-EstadoMunicipio, -Estado, -Municipio)

zzz = zzz[complete.cases(zzz), ]

xxx = x[complete.cases(x), ]
```


### High Elevations


```{r, label='High Elevations', message=FALSE,warning=FALSE}

DEM <- raster(paste0(wd$data_r,"DEM_r.tif"))

#high_elev <- rast(high_elev)

high_elev[high_elev < 3100] <- NA

high_elev[high_elev >= 3100] <- 1

#### EDIT FROM HERE ####


high_elev <- rasterToPoints(high_elev,spatial=TRUE)

rand <- sample(nrow(high_elev), nrow(points)/4, replace=FALSE)

high_elev <- high_elev[rand,]
high_elev$Irr <- sample(0:1,nrow(high_elev),replace=TRUE)
set.seed(54865132)
high_elev$Fert <- sample(0:1,nrow(high_elev),replace=TRUE)
high_elev$MUNICIPIO <- "HIGH"
high_elev$X <- high_elev@coords[,'x']
high_elev$Y <- high_elev@coords[,'y']
high_elev$Suit <- 0
high_elev$Maize <- 0
high_elev <- high_elev[,which(names(high_elev) != "DEM")]
```




## Merge Training Dataset

```{r}

Train_Total = Tot %>% select(-Estado_ID, -Municipio_ID) %>% 
  left_join(env_vals, by=c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>%
  select(AGType, AvgYield, sdYield, cvYield, AvgYieldLoss, sdYieldLoss, cvYieldLoss, Pop_Total, Pop_Urban, UrbRatio, Pct_Primary, Pct_Rented_ha, Pct_Rest_ha, Pct_Fallow_ha, Pct_FertilChem_ha, Pct_FertilManure_ha, Pct_ImprovSeed_ha, Pct_Herbicides_ha, Pct_Insecticides_ha, Pct_ControlledBurn_ha, TotalLabor, TotalLabor_perHa, PctContractLabor, Pct_Pasture_ha, LU_Total, LU_Total_perHa, mean.DEM, mean.Slope, mean.Accum, mean.TRI, mean.TWI, mean.STI, mean.SPI, mean.BD, mean.S, mean.Z, mean.C, mean.SOC, mean.CEC, mean.OCD, mean.N, mean.BDRICM, mean.BDTICM, mean.prec_04, mean.prec_05, mean.prec_06, mean.prec_07, mean.prec_08, mean.prec_09, mean.prec_10, mean.prec_11, mean.pr_04, mean.pr_05, mean.pr_06, mean.pr_07, mean.pr_08, mean.pr_09, mean.pr_10, mean.pr_11, mean.tmean_04, mean.tmean_05, mean.tmean_06, mean.tmean_07, mean.tmean_08, mean.tmean_09, mean.tmean_10, mean.tmean_11, mean.tmin_04, mean.tmin_05, mean.tmin_06, mean.tmin_07, mean.tmin_08, mean.tmin_09, mean.tmin_10, mean.tmin_11, mean.clt_04, mean.clt_05, mean.clt_06, mean.clt_07, mean.clt_08, mean.clt_09, mean.clt_10, mean.clt_11, mean.rsds_04, mean.rsds_05, mean.rsds_06, mean.rsds_07, mean.rsds_08, mean.rsds_09, mean.rsds_10, mean.rsds_11) %>%
  mutate(AGType = as.factor(AGType))

Train_Temp = Train %>% filter(AGType == "Temporal") %>% select(-AGType)

Train_Irrig = Train %>% filter(AGType == "Riego") %>% select(-AGType)

Train_Env = Tot %>% select(-Estado_ID, -Municipio_ID) %>% 
  left_join(env_vals, by=c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>%
  select(AGType, mean.DEM, mean.Slope, mean.Accum, mean.TRI, mean.TWI, mean.STI, mean.SPI, mean.BD, mean.S, mean.Z, mean.C, mean.SOC, mean.CEC, mean.OCD, mean.N, mean.BDRICM, mean.BDTICM, mean.prec_04, mean.prec_05, mean.prec_06, mean.prec_07, mean.prec_08, mean.prec_09, mean.prec_10, mean.prec_11, mean.pr_04, mean.pr_05, mean.pr_06, mean.pr_07, mean.pr_08, mean.pr_09, mean.pr_10, mean.pr_11, mean.tmean_04, mean.tmean_05, mean.tmean_06, mean.tmean_07, mean.tmean_08, mean.tmean_09, mean.tmean_10, mean.tmean_11, mean.tmin_04, mean.tmin_05, mean.tmin_06, mean.tmin_07, mean.tmin_08, mean.tmin_09, mean.tmin_10, mean.tmin_11, mean.clt_04, mean.clt_05, mean.clt_06, mean.clt_07, mean.clt_08, mean.clt_09, mean.clt_10, mean.clt_11, mean.rsds_04, mean.rsds_05, mean.rsds_06, mean.rsds_07, mean.rsds_08, mean.rsds_09, mean.rsds_10, mean.rsds_11) %>%
  mutate(AGType = as.factor(AGType))


```


# Random Forest Models

## Average Yield

### Variable Selection

```{r, label='Avg Yield Variable Selection', message=FALSE,warning=FALSE}
#boruta = readRDS(paste0(wd$data_p,"AGType_RFModel_boruta.rda"))

boruta <- Boruta(AvgYield ~ ., data = xxx[,c(4,6:80)], maxRuns = 100)#, doTrace = 2
print(boruta)
boruta[["finalDecision"]]
plot(boruta, las = 2, cex.axis = 0.7)
#bor <- TentativeRoughFix(boruta)
#bor[["finalDecision"]]
attStats(boruta)
form=getConfirmedFormula(boruta)

# saving the model
saveRDS(boruta, file = paste0(wd$data_p,"AGType_RFModel_boruta.rda"))
#rm(boruta)
#loading the model
#boruta = readRDS(paste0(wd$data_p,"AGType_RFModel_boruta.rda"))
```


### Train the Model

```{r, label='Avg Yield RF Model Training', message=FALSE,warning=FALSE}

#AGType_RF_model = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger.rda"))
#AGType_RF_model_prob = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger_Prob.rda"))

AGType_RF_model <- ranger(formula = form, data = AGType_RF_Train_df)

print(AGType_RF_model)

# saving the model
saveRDS(AGType_RF_model, file = paste0(wd$data_p,"AGType_RFModel_Ranger.rda"))

### probability forest classification as in Malley et al. (2012)
###https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3250568/
### Malley JD, Kruppa J, Dasgupta A, Malley KG, Ziegler A. Probability machines: consistent probability estimation using nonparametric learning machines. Methods Inf Med. 2012;51(1):74-81. doi: 10.3414/ME00-01-0052. Epub 2011 Sep 14. PMID: 21915433; PMCID: PMC3250568.

AGType_RF_model_prob <- ranger(formula = form, data = AGType_RF_Train_df, probability = T)

print(AGType_RF_model_prob)

# saving the model
saveRDS(AGType_RF_model_prob, file = paste0(wd$data_p,"AGType_RFModel_Ranger_Prob.rda"))


#loading the model
#AGType_RF_model = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger.rda"))
#AGType_RF_model_prob = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger_Prob.rda"))

```

## C.V. Average Yield

### Variable Selection

```{r, label='C.V. Avg Yield RF Model Variable Selection', message=FALSE,warning=FALSE}
#boruta = readRDS(paste0(wd$data_p,"AGType_RFModel_boruta.rda"))

boruta <- Boruta(AGType ~ ., data = AGType_RF_Train_df[,c(2:27)], maxRuns = 100)#, doTrace = 2
print(boruta)
boruta[["finalDecision"]]
plot(boruta, las = 2, cex.axis = 0.7)
#bor <- TentativeRoughFix(boruta)
#bor[["finalDecision"]]
attStats(boruta)
form=getConfirmedFormula(boruta)

# saving the model
saveRDS(boruta, file = paste0(wd$data_p,"AGType_RFModel_boruta.rda"))
#rm(boruta)
#loading the model
#boruta = readRDS(paste0(wd$data_p,"AGType_RFModel_boruta.rda"))
```



### Train the Model

```{r, label='C.V. Avg Yield RF Model Training', message=FALSE,warning=FALSE}

#AGType_RF_model = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger.rda"))
#AGType_RF_model_prob = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger_Prob.rda"))

AGType_RF_model <- ranger(formula = form, data = AGType_RF_Train_df)

print(AGType_RF_model)

# saving the model
saveRDS(AGType_RF_model, file = paste0(wd$data_p,"AGType_RFModel_Ranger.rda"))

### probability forest classification as in Malley et al. (2012)
###https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3250568/
### Malley JD, Kruppa J, Dasgupta A, Malley KG, Ziegler A. Probability machines: consistent probability estimation using nonparametric learning machines. Methods Inf Med. 2012;51(1):74-81. doi: 10.3414/ME00-01-0052. Epub 2011 Sep 14. PMID: 21915433; PMCID: PMC3250568.

AGType_RF_model_prob <- ranger(formula = form, data = AGType_RF_Train_df, probability = T)

print(AGType_RF_model_prob)

# saving the model
saveRDS(AGType_RF_model_prob, file = paste0(wd$data_p,"AGType_RFModel_Ranger_Prob.rda"))


#loading the model
#AGType_RF_model = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger.rda"))
#AGType_RF_model_prob = readRDS(paste0(wd$data_p,"AGType_RFModel_Ranger_Prob.rda"))

```

# Construct RF Prediction Dataset

--Predictions also for polygon values

--Rasterize AG data (popdens, labor, etc)
--Arable Area == MASK
--AGType Raster
--Raster Variables used to dataframe


## Rasterize Agricultural Data

```{r}

```


## Convert Data from Raster Stack to Dataframe 

```{r, label='Convert Data from Raster Stack to Dataframe ', message=FALSE,warning=FALSE}

x_df <- as.data.frame(x[[1]])
names(x_df) <- "AGType"
x_df <- rownames_to_column(x_df, var = "Cells")

for (i in 2:nlyr(x)) {
  
  t = as.data.frame(x[[i]])
  t <- rownames_to_column(t, var = "Cells")
  names(t) <- c("Cells", names(x[[i]]))
  x_df <- x_df %>% left_join(t, by="Cells")

}
#x_df = x_df %>% select(-Streams, -Streams2)
#d = x_df[complete.cases(x_df), ]
#d <- x_df[complete.cases(x_df[, -which(names(x_df) == "AGType")]), ]

AGType_RF_df <- x_df %>% 
  mutate(AGType = factor(AGType, levels = c("Temporal", "Irrigation")),
         #LandUseArchy = factor(LandUseArchy, levels = c("Unknown", "Wetland", "Settlement", "Water", "Glacial")),
         Geomorphons = factor(Geomorphons, levels = c("Flat", "Summit", "Ridge", "Shoulder", "Spur", "Slope", "Hollow", "Footslope", "Valley", "Depression")),
         WRB = factor(WRB, levels = c("NoData", "Andosols", "Arenosols", "Calcisols", "Cambisols", "Durisols", "Fluvisols", "Gleysols", "Leptosols", "Luvisols", "Phaeozems", "Regosols", "Solonchaks", "Solonetz", "Umbrisols", "Vertisols")))

rm(x_df)

AGType_RF_df %>%
  mutate(part = case_when(
    row_number() <= ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data1",
    row_number() <= 2 * ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data2",
    row_number() <= 3 * ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data3",
    row_number() <= 4 * ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data4",
    TRUE ~ "AGType_RFModel_Data5"
  )) %>%
  group_split(part) %>%
  purrr::walk2(
    .,
    c("AGType_RFModel_Data1", "AGType_RFModel_Data2", "AGType_RFModel_Data3", "AGType_RFModel_Data4", "AGType_RFModel_Data5"),
    ~ write_csv(.x, file = paste0(wd$data_p, .y, ".csv.gz"))
  )

```

## Shortcut Import


```{r, label='Shortcut Import', message=FALSE,warning=FALSE}

x <- rast(paste0(wd$data_p,"AGType_Raster_Data.tif"))
names(x) = c("AGType", "Geomorphons", "DEM", "Slope", "Accum_fd8", "TRI", "TWI", "STI", "SPI", "curv_min", "curv_max", "curv_mean", "Streams", "Streams2", "DistStreams", "DistStreams2", "ElevAboveStreams", "ElevAboveStreams2", "Valleys", "elev_watershed", "FloodOrder_Rel", "FloodOrder", "FlowDirect_d8_30m", "FlowDirect_inf_30m", "BDRICM", "BDRLOG", "BDTICM", "BD", "S", "Z", "C", "SOC", "CEC", "OCD", "N", "SOCS", "WRB")

AGType <- x[[1]]
#CONABIO_2015_LandUse_30m <- x[[2]]
Geomorphons <- x[[3]]

l = 1:5
file_paths <- paste0(wd$data_p, "AGType_RFModel_Data", l, ".csv.gz")
AGType_RF_df <- file_paths %>%
  map_dfr(~ read_csv(.x))

AGType_RF_df <- AGType_RF_df %>% 
  mutate(AGType = factor(AGType, levels = c("Temporal", "Irrigation")),
         #LandUseArchy = factor(LandUseArchy, levels = c("Unknown", "Wetland", "Settlement", "Water", "Glacial")),
         Geomorphons = factor(Geomorphons, levels = c("Flat", "Summit", "Ridge", "Shoulder", "Spur", "Slope", "Hollow", "Footslope", "Valley", "Depression")),
         WRB = factor(WRB, levels = c("NoData", "Andosols", "Arenosols", "Calcisols", "Cambisols", "Durisols", "Fluvisols", "Gleysols", "Leptosols", "Luvisols", "Phaeozems", "Regosols", "Solonchaks", "Solonetz", "Umbrisols", "Vertisols")))

```




# Model Predictions

## Avg Yield

```{r, label='Avg Yield RF Model Predictions', message=FALSE,warning=FALSE}
parts = c("AGType_RFModel_Data1", "AGType_RFModel_Data2", "AGType_RFModel_Data3", "AGType_RFModel_Data4", "AGType_RFModel_Data5")

pred_list = list()

i=1
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Predictions <- RFModel_predict$predictions
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=2
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Predictions <- RFModel_predict$predictions
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=3
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Predictions <- RFModel_predict$predictions
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=4
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Predictions <- RFModel_predict$predictions
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=5
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Predictions <- RFModel_predict$predictions
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)


pred_df <- do.call(rbind, pred_list)

rm(pred_list)

AGType_RF_df = AGType_RF_df %>% left_join(pred_df, by = "Cells")
zzz = zzz %>% left_join(pred_df, by = "Cells")

rm(pred_df)

```



## C.V. Average Yield

```{r, label='C.V. Yield RF Model Predictions', message=FALSE,warning=FALSE}
parts = c("AGType_RFModel_Data1", "AGType_RFModel_Data2", "AGType_RFModel_Data3", "AGType_RFModel_Data4", "AGType_RFModel_Data5")

pred_list = list()

i=1
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model_prob, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Prob_Temporal <- as.data.frame(RFModel_predict[["predictions"]])$Temporal
pred_df$Prob_Irrigation <- as.data.frame(RFModel_predict[["predictions"]])$Irrigation
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=2
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model_prob, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Prob_Temporal <- as.data.frame(RFModel_predict[["predictions"]])$Temporal
pred_df$Prob_Irrigation <- as.data.frame(RFModel_predict[["predictions"]])$Irrigation
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=3
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model_prob, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Prob_Temporal <- as.data.frame(RFModel_predict[["predictions"]])$Temporal
pred_df$Prob_Irrigation <- as.data.frame(RFModel_predict[["predictions"]])$Irrigation
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=4
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model_prob, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Prob_Temporal <- as.data.frame(RFModel_predict[["predictions"]])$Temporal
pred_df$Prob_Irrigation <- as.data.frame(RFModel_predict[["predictions"]])$Irrigation
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)

i=5
pred_df = zzz %>% filter(part == parts[i])
RFModel_predict <- predict(AGType_RF_model_prob, data=pred_df)
pred_df <- pred_df %>% select(Cells)
pred_df$Prob_Temporal <- as.data.frame(RFModel_predict[["predictions"]])$Temporal
pred_df$Prob_Irrigation <- as.data.frame(RFModel_predict[["predictions"]])$Irrigation
pred_list[[i]] <- pred_df
rm(pred_df, RFModel_predict)


pred_df <- do.call(rbind, pred_list)

rm(pred_list)

AGType_RF_df = AGType_RF_df %>% left_join(pred_df, by = "Cells")
zzz = zzz %>% left_join(pred_df, by = "Cells")

rm(pred_df)

```



## Export Outputs


```{r, label='Merge and Export Outputs', message=FALSE,warning=FALSE}

AGType_RF_df$Cells <- as.numeric(AGType_RF_df$Cells)





#AGType <- x[[1]]
values(AGType) <- NA
AGType[AGType_RF_df$Cells] <- AGType_RF_df$Predictions
AGType = as.factor(AGType)
levels(AGType) = levels(AGType)[[1]] %>% 
  mutate(AGType = case_when(
    ID == 1 ~ "Temporal",
    ID == 2 ~ "Irrigated"))
names(AGType) <- "AGType"

AGType_Prob_Temp <- as.numeric(AGType)
names(AGType_Prob_Temp) <- "AGType_Prob_Temp"
AGType_Prob_Irrig <- as.numeric(AGType)
names(AGType_Prob_Irrig) <- "AGType_Prob_Irrig"

values(AGType_Prob_Temp) <- NA
AGType_Prob_Temp[AGType_RF_df$Cells] <- AGType_RF_df$Prob_Temporal
values(AGType_Prob_Irrig) <- NA
AGType_Prob_Irrig[AGType_RF_df$Cells] <- AGType_RF_df$Prob_Irrigation

writeRaster(AGType, filename = paste0(wd$data_p, "AGType_Predict.tif"), overwrite=TRUE)
rm(AGType)
AGType <- rast(paste0(wd$data_p,"AGType_Predict.tif"))

writeRaster(AGType_Prob_Temp, filename = paste0(wd$data_p, "AGType_Prob_Temp.tif"), overwrite=TRUE)
rm(AGType_Prob_Temp)
AGType_Prob_Temp <- rast(paste0(wd$data_p,"AGType_Prob_Temp.tif"))

writeRaster(AGType_Prob_Irrig, filename = paste0(wd$data_p, "AGType_Prob_Irrig.tif"), overwrite=TRUE)
rm(AGType_Prob_Irrig)
AGType_Prob_Irrig <- rast(paste0(wd$data_p,"AGType_Prob_Irrig.tif"))


AGType_RF_df %>%
  mutate(part = case_when(
    row_number() <= ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data1",
    row_number() <= 2 * ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data2",
    row_number() <= 3 * ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data3",
    row_number() <= 4 * ceiling(nrow(.) / 5) ~ "AGType_RFModel_Data4",
    TRUE ~ "AGType_RFModel_Data5"
  )) %>%
  group_split(part) %>%
  purrr::walk2(
    .,
    c("AGType_RFModel_Data1", "AGType_RFModel_Data2", "AGType_RFModel_Data3", "AGType_RFModel_Data4", "AGType_RFModel_Data5"),
    ~ write_csv(.x, file = paste0(wd$data_p, .y, ".csv.gz"))
  )

rm(AGType_RF_Train_df, AGType_RF_df, AGType_RF_model, x, form, i, l, parts, zzz, SIAP_LU_Fields_AGType, AGType_RF_model_prob, boruta, DEM, ArableAreaMask)


DEM_100m <- rast(paste0(wd$data_p,"DEM_100m.tif"))
AGType_Predict_100m <- resample(AGType, DEM_100m, method = "near")
writeRaster(AGType_Predict_100m, filename = paste0(wd$data_p, "AGType_Predict_100m.tif"), overwrite=TRUE)
AGType_Prob_Temp_100m <- resample(AGType_Prob_Temp, DEM_100m, method = "bilinear")
writeRaster(AGType_Prob_Temp_100m, filename = paste0(wd$data_p, "AGType_Prob_Temp_100m.tif"), overwrite=TRUE)
AGType_Prob_Irrig_100m <- resample(AGType_Prob_Irrig, DEM_100m, method = "bilinear")
writeRaster(AGType_Prob_Irrig_100m, filename = paste0(wd$data_p, "AGType_Prob_Irrig_100m.tif"), overwrite=TRUE)

#rm(DEM_100m,AGType_Predict_100m,AGType_Prob_Temp_100m,AGType_Prob_Irrig_100m)


#rm(Arable_RF_Train_df, Arable_RF_df, RF_pred, Arable_RF_Predict_df, RF_model, boruta, Cultiv)


```




























# UNUSED

## Subset Raster Data

```{r, label='Subset Environmental Data Rasters', message=FALSE,warning=FALSE}
Soil_r_sub <- subset(Soil_r, c("BD","S", "Z","C","SOC","CEC","OCD","N", "BDRICM", "BDTICM"))

TopoEnv_r_sub <- subset(TopoEnv_r, c("DEM", "Slope","Accum", "TRI", "TWI", "STI", "SPI"))

Clim_r_sub <- subset(Clim_r, c("prec_04", "prec_05", "prec_06", "prec_07", "prec_08", "prec_09", "prec_10", "prec_11",
                               "pr_04", "pr_05", "pr_06", "pr_07", "pr_08", "pr_09", "pr_10", "pr_11",
                               "tmean_04", "tmean_05", "tmean_06", "tmean_07", "tmean_08", "tmean_09", "tmean_10", "tmean_11", 
                               "tmin_04","tmin_05", "tmin_06", "tmin_07", "tmin_08", "tmin_09", "tmin_10","tmin_11",
                               "clt_04", "clt_05", "clt_06", "clt_07", "clt_08", "clt_09", "clt_10", "clt_11", 
                               "rsds_04", "rsds_05", "rsds_06", "rsds_07", "rsds_08", "rsds_09", "rsds_10", "rsds_11"
                               ))

```



## Extract Raster Values

```{r, label='Extract Raster Values', message=FALSE,warning=FALSE}

topo_vals <- exact_extract(x = TopoEnv_r_sub, y = Data2000s_poly, fun = "mean", 
                           max_cells_in_memory = 8e+08, stack_apply=T, 
                           append_cols = c("EstadoMunicipio","Estado", "Municipio", "AGType"))

soil_vals <- exact_extract(x = Soil_r_sub, y = Data2000s_poly, fun = "mean", 
                           max_cells_in_memory = 8e+08, stack_apply=T, 
                           append_cols = c("EstadoMunicipio","Estado", "Municipio", "AGType"))

clim_vals <- exact_extract(x = Clim_r_sub, y = Data2000s_poly, fun = "mean", 
                           max_cells_in_memory = 8e+08, stack_apply=T, 
                           append_cols = c("EstadoMunicipio","Estado", "Municipio", "AGType"))

env_vals <- topo_vals %>% left_join(soil_vals, by = c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>% 
                          left_join(clim_vals, by = c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>% 
                          mutate(AGType = as.factor(AGType))
  

#env_vals = merge(topo_vals, soil_vals, all = F, sort = F)

rm(topo_vals, soil_vals, clim_vals)

```

```{r}
#values2 <- exact_extract(x = Soil_r_sub, y = Data2000s_poly, fun = "count", max_cells_in_memory = 8e+08, stack_apply=T, append_cols = c("EstadoMunicipio","Estado", "Municipio", "AGType"))

#xx = cbind(st_drop_geometry(Data2000s_poly$EstadoMunicipio), values)

#values <- exact_extract(x = Soil_r_sub[[1:2]], y = Data2000s_poly, fun = mymean, summarize_df = TRUE, max_cells_in_memory = 8e+08, stack_apply=T)

all <- c(Clim_r_sub, Soil_r_sub, TopoEnv_r_sub)

Soil_df <- exact_extract(x = Soil_r_sub, y = Data2000s_poly, fun = mymean, max_cells_in_memory = 8e+10)
save(all_df, file = paste0(wd$data_r, "EnvRastPolyExtract_df.rData"))


st_extract(Clim_r[,,,5], x, fun = mean)

Clim_df <- data.frame()

for (i in 1:nlyr(Clim_r)) {
  out[, i] <- my_function(my_df[, i])
}

nlyr(Clim_r)
values <- exact_extract(x = Clim_r[[1:2]], y = x, fun = "mean", max_cells_in_memory = 8e+08)

c("prec_05", "prec_06", "prec_07", "prec_08", "prec_09", "prec_10", 
"pr_05", "pr_06", "pr_07", "pr_08", "pr_09", "pr_10", 
"tmean_05", "tmean_06", "tmean_07", "tmean_08", "tmean_09", "tmean_10", 
"tmin_05", "tmin_06", "tmin_07", "tmin_08", "tmin_09", "tmin_10")

clim <- stack(prec[[5:7]],prec[[5:7]],
prec[[8:10]],
tmin[[5:7]],
tmin[[8:10]],tmin[[8:10]])
geol <- stack(depth, cation, slope)

geol_vals <- extract(geol,points)
clim_vals <- extract(clim,points)
```




# Construct Training Dataset


Rescaling/Normalizing the data is unnecessary!! 
Random Forest algorithm is not a distance-based model - it is a tree-based model. Each node in a Random Forest is not comparing feature values, it is simply splitting a sorted list that requires absolute values for branching. The algorithm is based on partitioning the data to make predictions, therefore, it does not require normalization.

https://www.kdnuggets.com/2022/07/random-forest-algorithm-need-normalization.html#:~:text=Each%20node%20in%20a%20Random,it%20does%20not%20require%20normalization.



## Agricultural Data


```{r, label='Prepare Agricultural Data', message=FALSE,warning=FALSE}

x = st_drop_geometry(Data2000s_poly)# %>% filter(-1:3)
x = x %>% filter(!(EstadoMunicipio %in% c("Ixtapaluca, Mexico", "Valle de Chalco Solidaridad, Mexico", "Milpa Alta, Distrito Federal", "Tlahuac, Distrito Federal", "Xochimilco, Distrito Federal", "Axapusco, Mexico") & AGType %in% "Riego"))

#x = x[,-c(1:5)]
#x = as.data.frame(x)
Tot = x %>% select(-AvgYield_Total, -sdYield_Total, -cvYield_Total, 
                   -AvgYield_Irrig, -sdYield_Irrig, -cvYield_Irrig, -AvgYield_Temp, 
                   -sdYield_Temp, -cvYield_Temp, -ITr_AvgYield, -ITr_cvYield, 
                   -AvgYieldLoss_Total, -sdYieldLoss_Total, -cvYieldLoss_Total, 
                   -AvgYieldLoss_Irrig, -sdYieldLoss_Irrig, -cvYieldLoss_Irrig, 
                   -AvgYieldLoss_Temp, -sdYieldLoss_Temp, -cvYieldLoss_Temp, 
                   -ITr_AvgYieldLoss,  -ITr_cvYieldLoss, -minYieldLoss) %>% 
  filter(complete.cases(.))


# Find rows with NA, NaN, or Inf values
#rows_with_na <- apply(Tot, 1, function(row) any(is.na(row) | is.nan(row) | is.infinite(row)))

# Find columns with NA, NaN, or Inf values
#columns_with_na <- apply(Tot, 2, function(column) any(is.na(column) | is.nan(column) | is.infinite(column)))

# Print the rows and columns with NA, NaN, or Inf values
#cat("Rows with NA, NaN, or Inf values:\n")
#print(which(rows_with_na))
#cat("\n")
#cat("Columns with NA, NaN, or Inf values:\n")
#print(which(columns_with_na))

```

```{r, label='Prepare Agricultural Data', message=FALSE,warning=FALSE}

Data2000s_poly <- Data2000s_poly %>% mutate(
  AGType = as.factor(AGType),
  AvgYield = as.numeric(AvgYield),
  sdYield = as.numeric(sdYield),
  minYield = as.numeric(minYield),
  maxYield = as.numeric(maxYield),
  medYield = as.numeric(medYield),
  cvYield = as.numeric(cvYield),
  
  AvgYieldLoss = as.numeric(AvgYieldLoss),
  sdYieldLoss = as.numeric(sdYieldLoss),
  minYieldLoss = as.numeric(minYieldLoss),
  maxYieldLoss = as.numeric(maxYieldLoss),
  medYieldLoss = as.numeric(medYieldLoss),
  cvYieldLoss = as.numeric(cvYieldLoss),
  
  AvgPlanted = as.numeric(AvgPlanted),
  AvgHarvested = as.numeric(AvgHarvested),
  sdHarvested = as.numeric(sdHarvested),
  cvHarvested = as.numeric(cvHarvested),
  AvgLost = as.numeric(AvgLost),
  sdLost = as.numeric(sdLost),
  cvLost = as.numeric(cvLost),
  AvgProduct = as.numeric(AvgProduct),
  AvgValue = as.numeric(AvgValue),
  AvgPrice = as.numeric(AvgPrice),
  n = as.numeric(n),
  n_Total = as.numeric(n_Total),
  AvgYield_Total = as.numeric(AvgYield_Total),
  sdYield_Total = as.numeric(sdYield_Total),
  cvYield_Total = as.numeric(cvYield_Total),
  AvgYield_Irrig = as.numeric(AvgYield_Irrig),
  sdYield_Irrig = as.numeric(sdYield_Irrig),
  cvYield_Irrig = as.numeric(cvYield_Irrig),
  AvgYield_Temp = as.numeric(AvgYield_Temp),
  sdYield_Temp = as.numeric(sdYield_Temp),
  cvYield_Temp = as.numeric(cvYield_Temp),
  ITr_AvgYield = as.numeric(ITr_AvgYield),
  ITr_cvYield = as.numeric(ITr_cvYield),
  
  AvgYieldLoss_Total = as.numeric(AvgYieldLoss_Total),
  sdYieldLoss_Total = as.numeric(sdYieldLoss_Total),
  cvYieldLoss_Total = as.numeric(cvYieldLoss_Total),
  AvgYieldLoss_Irrig = as.numeric(AvgYieldLoss_Irrig),
  sdYieldLoss_Irrig = as.numeric(sdYieldLoss_Irrig),
  cvYieldLoss_Irrig = as.numeric(cvYieldLoss_Irrig),
  AvgYieldLoss_Temp = as.numeric(AvgYieldLoss_Temp),
  sdYieldLoss_Temp = as.numeric(sdYieldLoss_Temp),
  cvYieldLoss_Temp = as.numeric(cvYieldLoss_Temp),
  ITr_AvgYieldLoss = as.numeric(ITr_AvgYieldLoss),
  ITr_cvYieldLoss = as.numeric(ITr_cvYieldLoss),
  
  Pct_Tract_Mechaniz_pu = as.numeric(Pct_Tract_Mechaniz_pu),
  Pct_Tract_Animal_pu = as.numeric(Pct_Tract_Animal_pu),
  Pct_Tract_Manual_pu = as.numeric(Pct_Tract_Manual_pu),
  Riego_PU = as.numeric(Riego_PU),
  Temporal_PU = as.numeric(Temporal_PU)
  )

```

--n = 1 case--
***- Riego
Malinalco, Mexico 
Chicoloapan, Mexico
Chimalhuacan, Mexico

sdYield     cvYield sdYieldLoss cvYieldLoss sdHarvested cvHarvested      sdLost      cvLost 


***- Riego
Ixtapaluca, Mexico 
Valle de Chalco Solidaridad, Mexico
Milpa Alta, Distrito Federal
Tlahuac, Distrito Federal
Xochimilco, Distrito Federal
Axapusco, Mexico




-AvgYieldLoss_Irrig, -sdYieldLoss_Irrig, -cvYieldLoss_Irrig, -AvgYieldLoss_Temp, -sdYieldLoss_Temp, -cvYieldLoss_Temp, -ITr_AvgYieldLoss,  -ITr_cvYieldLoss


AvgYield_Irrig	
         sdYield_Irrig	
         cvYield_Irrig	
         AvgYield_Temp	
         sdYield_Temp	
         cvYield_Temp	
         ITr_AvgYield	
         ITr_cvYield

         AvgYieldLoss_Irrig	
         sdYieldLoss_Irrig	
         cvYieldLoss_Irrig	
         AvgYieldLoss_Temp	
         sdYieldLoss_Temp	
         cvYieldLoss_Temp	
         ITr_AvgYieldLoss	
         ITr_cvYieldLoss






## Merge Raster Data with AG Data

```{r}

Train_Total = Tot %>% select(-Estado_ID, -Municipio_ID) %>% 
  left_join(env_vals, by=c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>%
  select(AGType, AvgYield, sdYield, cvYield, AvgYieldLoss, sdYieldLoss, cvYieldLoss, Pop_Total, Pop_Urban, UrbRatio, Pct_Primary, Pct_Rented_ha, Pct_Rest_ha, Pct_Fallow_ha, Pct_FertilChem_ha, Pct_FertilManure_ha, Pct_ImprovSeed_ha, Pct_Herbicides_ha, Pct_Insecticides_ha, Pct_ControlledBurn_ha, TotalLabor, TotalLabor_perHa, PctContractLabor, Pct_Pasture_ha, LU_Total, LU_Total_perHa, mean.DEM, mean.Slope, mean.Accum, mean.TRI, mean.TWI, mean.STI, mean.SPI, mean.BD, mean.S, mean.Z, mean.C, mean.SOC, mean.CEC, mean.OCD, mean.N, mean.BDRICM, mean.BDTICM, mean.prec_04, mean.prec_05, mean.prec_06, mean.prec_07, mean.prec_08, mean.prec_09, mean.prec_10, mean.prec_11, mean.pr_04, mean.pr_05, mean.pr_06, mean.pr_07, mean.pr_08, mean.pr_09, mean.pr_10, mean.pr_11, mean.tmean_04, mean.tmean_05, mean.tmean_06, mean.tmean_07, mean.tmean_08, mean.tmean_09, mean.tmean_10, mean.tmean_11, mean.tmin_04, mean.tmin_05, mean.tmin_06, mean.tmin_07, mean.tmin_08, mean.tmin_09, mean.tmin_10, mean.tmin_11, mean.clt_04, mean.clt_05, mean.clt_06, mean.clt_07, mean.clt_08, mean.clt_09, mean.clt_10, mean.clt_11, mean.rsds_04, mean.rsds_05, mean.rsds_06, mean.rsds_07, mean.rsds_08, mean.rsds_09, mean.rsds_10, mean.rsds_11) %>%
  mutate(AGType = as.factor(AGType))

Train_Temp = Train %>% filter(AGType == "Temporal") %>% select(-AGType)

Train_Irrig = Train %>% filter(AGType == "Riego") %>% select(-AGType)

Train_Env = Tot %>% select(-Estado_ID, -Municipio_ID) %>% 
  left_join(env_vals, by=c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>%
  select(AGType, mean.DEM, mean.Slope, mean.Accum, mean.TRI, mean.TWI, mean.STI, mean.SPI, mean.BD, mean.S, mean.Z, mean.C, mean.SOC, mean.CEC, mean.OCD, mean.N, mean.BDRICM, mean.BDTICM, mean.prec_04, mean.prec_05, mean.prec_06, mean.prec_07, mean.prec_08, mean.prec_09, mean.prec_10, mean.prec_11, mean.pr_04, mean.pr_05, mean.pr_06, mean.pr_07, mean.pr_08, mean.pr_09, mean.pr_10, mean.pr_11, mean.tmean_04, mean.tmean_05, mean.tmean_06, mean.tmean_07, mean.tmean_08, mean.tmean_09, mean.tmean_10, mean.tmean_11, mean.tmin_04, mean.tmin_05, mean.tmin_06, mean.tmin_07, mean.tmin_08, mean.tmin_09, mean.tmin_10, mean.tmin_11, mean.clt_04, mean.clt_05, mean.clt_06, mean.clt_07, mean.clt_08, mean.clt_09, mean.clt_10, mean.clt_11, mean.rsds_04, mean.rsds_05, mean.rsds_06, mean.rsds_07, mean.rsds_08, mean.rsds_09, mean.rsds_10, mean.rsds_11) %>%
  mutate(AGType = as.factor(AGType))


```





### PCA for Variable Selection

```{r, label='PCA for Agricultural Variable Selection', message=FALSE,warning=FALSE}

# sdYield, cvYield, sdHarvested, cvHarvested, sdLost                

pca_tot <- prcomp(Train[,-c(1:4)], center = TRUE, scale. = TRUE)
loadings_tot = as.data.frame(pca_tot$rotation, row.names = colnames(Train[,-c(1:4)]))

pca_temp <- prcomp(Temp[,-c(1:3)], center = TRUE, scale. = TRUE)
loadings_temp = as.data.frame(pca_temp$rotation, row.names = colnames(Temp[,-c(1:3)]))

pca_irrig <- prcomp(Irrig[,-c(1:3)], center = TRUE, scale. = TRUE)
loadings_irrig = as.data.frame(pca_irrig$rotation, row.names = colnames(Irrig[,-c(1:3)]))

#res <- cor(y)
#res = as.data.frame(round(res, 2))

```


```{r}
hist(Temp$AvgYield, breaks = seq(0, 5200, by = 200), xlim = c(0,5200))
hist(Irrig$AvgYield, breaks = seq(2000, 10250, by = 250), xlim = c(2000,10250))
#rescale to 1500-8000
hist(Tot$AvgYield, breaks = seq(0, 10250, by = 250), xlim = c(0,10250))
hist(log(Irrig$AvgYield))
hist(log(Tot$AvgYield))

plot(Tot$LU_Total_perHa, Tot$AvgYield)
plot(log(Tot$LU_Total_perHa), log(Tot$AvgYield))
plot(Irrig$LU_Total_perHa, Irrig$AvgYield)
plot(log(Irrig$LU_Total_perHa), (Irrig$AvgYield))
plot(Temp$LU_Total_perHa, Temp$AvgYield)
plot(log(Temp$LU_Total_perHa), log(Temp$AvgYield))
```





### Boruta for Variable Selection

Random Forest feature selection, why we need feature selection?

When we have too many features in the datasets and we want to develop a prediction model like a neural network will take a lot of time and reduces the accuracy of the prediction model.

We need to make use of the Boruta algorithm and is based on random forest.

How Boruta works?
Suppose if you have 100 variables in the dataset, each attributes creates shadow attributes, and in each shadow attribute, all the values are shuffled and creates randomness in the dataset.

Based on these datasets will create a classification model with shadow attributes and original attributes and then assess the importance of the attributes.
https://www.r-bloggers.com/2021/05/random-forest-feature-selection/
Boruta is an all relevant feature selection wrapper algorithm, capable of working with any classification method that output variable importance measure (VIM); by default, Boruta uses Random
Forest. The method performs a top-down search for relevant features by comparing original attributes’ importance with importance achievable at random, estimated using their permuted copies,
and progressively eliminating irrelevant features to stabilise that test.
https://cran.r-project.org/web/packages/Boruta/Boruta.pdf

```{r}
#Response = Train$AvgYield
#Predictors = Train %>% select(-EstadoMunicipio, -Estado, -Municipio, -AvgYield)
TrainB = Train %>% select(-EstadoMunicipio, -Estado, -Municipio)

TrainB2 = Tot %>% select(-Estado_ID, -Municipio_ID) %>% 
  left_join(env_vals, by=c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>%
  select(-EstadoMunicipio, -Estado, -Municipio) %>%
  select(AGType, AvgYield, cvYield, AvgYieldLoss, cvYieldLoss, Pop_Total, Pop_Rural, Pop_Urban, UrbRatio, Pop_Pct_Rural, Primary, Pct_Primary, AG_Workers, Pct_AG_Workers, Pct_Rented_ha, Pct_Rest_ha, Pct_Fallow_ha, Pct_FertilChem_ha, Pct_FertilManure_ha, Pct_ImprovSeed_ha, Pct_Herbicides_ha, Pct_Insecticides_ha, Pct_ControlledBurn_ha, TotalLabor, TotalLabor_perHa, PrimaryEmploy_perHa, AG_Workers_perHa, PctContractLabor, LU_Total, LU_Total_perHa, PopDensRural, PopDens, mean.DEM, mean.Slope, mean.Accum, mean.TRI, mean.TWI, mean.STI, mean.SPI, mean.BD, mean.S, mean.Z, mean.C, mean.SOC, mean.CEC, mean.OCD, mean.N, mean.BDRICM, mean.BDTICM, mean.prec_04, mean.prec_05, mean.prec_06, mean.prec_07, mean.prec_08, mean.prec_09, mean.prec_10, mean.prec_11, mean.pr_04, mean.pr_05, mean.pr_06, mean.pr_07, mean.pr_08, mean.pr_09, mean.pr_10, mean.pr_11, mean.tmean_04, mean.tmean_05, mean.tmean_06, mean.tmean_07, mean.tmean_08, mean.tmean_09, mean.tmean_10, mean.tmean_11, mean.tmin_04, mean.tmin_05, mean.tmin_06, mean.tmin_07, mean.tmin_08, mean.tmin_09, mean.tmin_10, mean.tmin_11, mean.clt_04, mean.clt_05, mean.clt_06, mean.clt_07, mean.clt_08, mean.clt_09, mean.clt_10, mean.clt_11, mean.rsds_04, mean.rsds_05, mean.rsds_06, mean.rsds_07, mean.rsds_08, mean.rsds_09, mean.rsds_10, mean.rsds_11) %>% 
  mutate(Fertilizer = Pct_FertilManure_ha + Pct_FertilChem_ha) %>% 
  mutate(AGType = as.factor(AGType))

boruta <- Boruta(AvgYield ~ ., data = TrainB, maxRuns = 1000)#, doTrace = 2
boruta2 <- Boruta(AvgYield ~ ., data = TrainB2, maxRuns = 1000)#, doTrace = 2
print(boruta)
boruta[["finalDecision"]]
plot(boruta, las = 2, cex.axis = 0.7)
plot(boruta2, las = 2, cex.axis = 0.7)

bor <- TentativeRoughFix(boruta)
bor[["finalDecision"]]
bor2 <- TentativeRoughFix(boruta2)
bor2[["finalDecision"]]

b=attStats(boruta)
b2=attStats(boruta2)

form=getConfirmedFormula(boruta)
```
Pop_Total   
Pop_Urban 
Primary                                
Primary                                Rejected
Pct_Primary                            Rejected
AG_Workers                             Rejected
Pct_AG_Workers                         Rejected
Pct_Rented_ha                          Rejected
Pct_Rest_ha                            Rejected
Pct_Fallow_ha                          Rejected
Pct_FertilManure_ha                    Rejected
Pct_ImprovSeed_ha                      Rejected
Pct_Insecticides_ha                    Rejected
Pct_ControlledBurn_ha                  Rejected
Pct_Tract_Mechaniz_pu                  Rejected
Pct_Tract_Manual_pu                    Rejected
Pct_Pasture_ha                         Rejected
LU_FamLabor                            Rejected
LU_MechanizEquip                       Rejected
LU_DraftAnimals                        Rejected
PopDensRural                           Rejected
Temporal_PU                            Rejected
PopDensRural 






### Subset Agricultural Variables

```{r, label='Subset Agricultural Variables', message=FALSE,warning=FALSE}

Train = Tot %>% select(-Estado_ID, -Municipio_ID) %>% 
  left_join(env_vals, by=c("EstadoMunicipio","Estado", "Municipio", "AGType")) %>%
  select(AGType, Estado, Municipio, EstadoMunicipio, AvgYield, sdYield, cvYield, AvgYieldLoss, sdYieldLoss, cvYieldLoss, Pop_Total, Pop_Urban, UrbRatio, Pct_Primary, Pct_Rented_ha, Pct_Rest_ha, Pct_Fallow_ha, Pct_FertilChem_ha, Pct_FertilManure_ha, Pct_ImprovSeed_ha, Pct_Herbicides_ha, Pct_Insecticides_ha, Pct_ControlledBurn_ha, TotalLabor, TotalLabor_perHa, PctContractLabor, Pct_Pasture_ha, LU_Total, LU_Total_perHa, mean.Slope, mean.Accum, mean.TRI, mean.TWI, mean.STI, mean.SPI, mean.BD, mean.S, mean.Z, mean.C, mean.SOC, mean.CEC, mean.OCD, mean.N, mean.BDRICM, mean.BDTICM, mean.prec_04, mean.prec_05, mean.prec_06, mean.prec_07, mean.prec_08, mean.prec_09, mean.prec_10, mean.prec_11, mean.pr_04, mean.pr_05, mean.pr_06, mean.pr_07, mean.pr_08, mean.pr_09, mean.pr_10, mean.pr_11, mean.tmean_04, mean.tmean_05, mean.tmean_06, mean.tmean_07, mean.tmean_08, mean.tmean_09, mean.tmean_10, mean.tmean_11, mean.tmin_04, mean.tmin_05, mean.tmin_06, mean.tmin_07, mean.tmin_08, mean.tmin_09, mean.tmin_10, mean.tmin_11, mean.clt_04, mean.clt_05, mean.clt_06, mean.clt_07, mean.clt_08, mean.clt_09, mean.clt_10, mean.clt_11, mean.rsds_04, mean.rsds_05, mean.rsds_06, mean.rsds_07, mean.rsds_08, mean.rsds_09, mean.rsds_10, mean.rsds_11)%>%
  mutate(AGType = as.factor(AGType))

Temp = Train %>% filter(AGType == "Temporal") %>% select(-AGType)
Irrig = Train %>% filter(AGType == "Riego") %>% select(-AGType)

```






# Random Forest Model

When using a Random Forest model, there are several approaches you can employ to narrow down the variables used as input. These methods can help improve the model's performance, reduce overfitting, and enhance interpretability. Here are some commonly used approaches:

Feature Importance: Random Forest models provide a measure of feature importance, which indicates the relative contribution of each variable in predicting the target variable. You can use these importance scores to identify the most influential variables and select only the top-ranked ones for your model.

Recursive Feature Elimination (RFE): RFE is an iterative process that starts with all variables and progressively eliminates the least important ones. It trains the model on a subset of features, calculates their importance, and removes the least important feature. The process is repeated until a desired number of features is reached or a specified stopping criterion is met.

Selecting a Threshold: You can set a threshold for feature importance and select variables that exceed that threshold. This approach allows you to include only the most relevant variables in your model, discarding those with lower importance.

Correlation Analysis: Identify variables that have a high correlation with the target variable and retain those while eliminating highly correlated variables among themselves. This helps reduce redundancy and focuses on variables that have a stronger relationship with the target.

Domain Knowledge and Expert Opinion: Leverage your domain knowledge or consult subject matter experts to identify variables that are most likely to impact the target variable. This approach can help you narrow down the variables and focus on those that are known to be relevant in the specific context.

Stepwise Selection: Implement a stepwise selection algorithm, such as forward selection, backward elimination, or a combination of both. These methods iteratively add or remove variables based on statistical metrics like p-values, AIC, or BIC, to find the optimal subset of variables for your model.

L1 Regularization (LASSO): Apply L1 regularization, such as the LASSO (Least Absolute Shrinkage and Selection Operator), which can shrink the coefficients of irrelevant variables to zero, effectively excluding them from the model.

It is important to note that the selection of variables should be guided by the specific problem, the available data, and the goals of your analysis. Experimentation, validation, and careful consideration of the trade-offs between model complexity and performance are crucial in determining the final set of variables for your Random Forest model.
```{r}

train <- na.omit(train)


rf_yield <- ranger(formula=form, data = Train, num.trees = 1000, importance='impurity', write.forest = TRUE)

print(m.lzn.ra)

test_out <- predict(rf,test)
test$predicted <- test_out$predictions
test$error <- test$predicted - test$Maize

rsq <- 1 - (sd(test$error^2)/sd(test$Maize^2))
mse <- mean(test$error^2)
rmse <- sqrt(mse)
mae <- mean(abs(test$error))

{print(paste("Rsq:", rsq))
print(paste("RMSE:", rmse))
print(paste("MAE:", mae))}


null_irrigation <- all[["Slope"]]
null_irrigation[null_irrigation == null_irrigation] <- 0
null_fert <- null_irrigation
nulls <- stack(null_irrigation,null_fert)
names(nulls) <- c('Irr','Fert')


names(all) <- str_replace(names(all),"\\..*","")


n <- c(names(nulls),names(all))
n <- str_replace(names(n),"\\..*","")

predictors <- stack(nulls,all)

aoi <- extent(2710000,2950000,780000,950000)

predictors <- crop(predictors,aoi)
for (i in 1:nlayers(predictors)){
predictors[[i]] <- na.roughfix(predictors[[i]])
}

predictors <-approxNA(predictors)

output <- predict(rf,as.matrix(predictors),type="response")

new <- predictors[[1]]
new[1:length(new)] <- output$predictions


steep <- predictors[["Slope"]]
new[steep >= 7] <- 0
new[new > 2000] <- 2000

plot(new)

lake <- readOGR(dsn = "A:/Regional_Datasets/GIS/Lake_Texcoco",
layer = "Lake_Texcoco")
lake <- spTransform(lake,crs(new))
plot(lake,add=TRUE,col="cyan")

```





